
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model active_class
 * 
 */
export type active_class = $Result.DefaultSelection<Prisma.$active_classPayload>
/**
 * Model agenda
 * 
 */
export type agenda = $Result.DefaultSelection<Prisma.$agendaPayload>
/**
 * Model employee
 * 
 */
export type employee = $Result.DefaultSelection<Prisma.$employeePayload>
/**
 * Model employee_role
 * 
 */
export type employee_role = $Result.DefaultSelection<Prisma.$employee_rolePayload>
/**
 * Model final_grade
 * 
 */
export type final_grade = $Result.DefaultSelection<Prisma.$final_gradePayload>
/**
 * Model job
 * 
 */
export type job = $Result.DefaultSelection<Prisma.$jobPayload>
/**
 * Model parent
 * 
 */
export type parent = $Result.DefaultSelection<Prisma.$parentPayload>
/**
 * Model period
 * 
 */
export type period = $Result.DefaultSelection<Prisma.$periodPayload>
/**
 * Model roles
 * 
 */
export type roles = $Result.DefaultSelection<Prisma.$rolesPayload>
/**
 * Model school_email
 * 
 */
export type school_email = $Result.DefaultSelection<Prisma.$school_emailPayload>
/**
 * Model school_info
 * 
 */
export type school_info = $Result.DefaultSelection<Prisma.$school_infoPayload>
/**
 * Model school_num
 * 
 */
export type school_num = $Result.DefaultSelection<Prisma.$school_numPayload>
/**
 * Model student
 * 
 */
export type student = $Result.DefaultSelection<Prisma.$studentPayload>
/**
 * Model subject_class
 * 
 */
export type subject_class = $Result.DefaultSelection<Prisma.$subject_classPayload>
/**
 * Model subjects
 * 
 */
export type subjects = $Result.DefaultSelection<Prisma.$subjectsPayload>
/**
 * Model test
 * 
 */
export type test = $Result.DefaultSelection<Prisma.$testPayload>
/**
 * Model test_result
 * 
 */
export type test_result = $Result.DefaultSelection<Prisma.$test_resultPayload>
/**
 * Model classes
 * 
 */
export type classes = $Result.DefaultSelection<Prisma.$classesPayload>
/**
 * Model parent_form
 * 
 */
export type parent_form = $Result.DefaultSelection<Prisma.$parent_formPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const subjects_subject_cat: {
  Scientific: 'Scientific',
  Literature: 'Literature',
  Activity: 'Activity',
  Other: 'Other'
};

export type subjects_subject_cat = (typeof subjects_subject_cat)[keyof typeof subjects_subject_cat]


export const final_grade_test_period: {
  c1: 'c1',
  e1: 'e1',
  c2: 'c2',
  e2: 'e2',
  c3: 'c3',
  e3: 'e3',
  c4: 'c4',
  e4: 'e4'
};

export type final_grade_test_period = (typeof final_grade_test_period)[keyof typeof final_grade_test_period]


export const test_test_period: {
  c1: 'c1',
  e1: 'e1',
  c2: 'c2',
  e2: 'e2',
  c3: 'c3',
  e3: 'e3',
  c4: 'c4',
  e4: 'e4'
};

export type test_test_period = (typeof test_test_period)[keyof typeof test_test_period]

}

export type subjects_subject_cat = $Enums.subjects_subject_cat

export const subjects_subject_cat: typeof $Enums.subjects_subject_cat

export type final_grade_test_period = $Enums.final_grade_test_period

export const final_grade_test_period: typeof $Enums.final_grade_test_period

export type test_test_period = $Enums.test_test_period

export const test_test_period: typeof $Enums.test_test_period

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Active_classes
 * const active_classes = await prisma.active_class.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Active_classes
   * const active_classes = await prisma.active_class.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.active_class`: Exposes CRUD operations for the **active_class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Active_classes
    * const active_classes = await prisma.active_class.findMany()
    * ```
    */
  get active_class(): Prisma.active_classDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agenda`: Exposes CRUD operations for the **agenda** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agenda
    * const agenda = await prisma.agenda.findMany()
    * ```
    */
  get agenda(): Prisma.agendaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.employeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee_role`: Exposes CRUD operations for the **employee_role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employee_roles
    * const employee_roles = await prisma.employee_role.findMany()
    * ```
    */
  get employee_role(): Prisma.employee_roleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.final_grade`: Exposes CRUD operations for the **final_grade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Final_grades
    * const final_grades = await prisma.final_grade.findMany()
    * ```
    */
  get final_grade(): Prisma.final_gradeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job`: Exposes CRUD operations for the **job** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.job.findMany()
    * ```
    */
  get job(): Prisma.jobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parent`: Exposes CRUD operations for the **parent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parents
    * const parents = await prisma.parent.findMany()
    * ```
    */
  get parent(): Prisma.parentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.period`: Exposes CRUD operations for the **period** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Periods
    * const periods = await prisma.period.findMany()
    * ```
    */
  get period(): Prisma.periodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.rolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.school_email`: Exposes CRUD operations for the **school_email** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more School_emails
    * const school_emails = await prisma.school_email.findMany()
    * ```
    */
  get school_email(): Prisma.school_emailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.school_info`: Exposes CRUD operations for the **school_info** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more School_infos
    * const school_infos = await prisma.school_info.findMany()
    * ```
    */
  get school_info(): Prisma.school_infoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.school_num`: Exposes CRUD operations for the **school_num** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more School_nums
    * const school_nums = await prisma.school_num.findMany()
    * ```
    */
  get school_num(): Prisma.school_numDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.studentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subject_class`: Exposes CRUD operations for the **subject_class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subject_classes
    * const subject_classes = await prisma.subject_class.findMany()
    * ```
    */
  get subject_class(): Prisma.subject_classDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subjects`: Exposes CRUD operations for the **subjects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subjects.findMany()
    * ```
    */
  get subjects(): Prisma.subjectsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.test`: Exposes CRUD operations for the **test** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tests
    * const tests = await prisma.test.findMany()
    * ```
    */
  get test(): Prisma.testDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.test_result`: Exposes CRUD operations for the **test_result** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Test_results
    * const test_results = await prisma.test_result.findMany()
    * ```
    */
  get test_result(): Prisma.test_resultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classes`: Exposes CRUD operations for the **classes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.classes.findMany()
    * ```
    */
  get classes(): Prisma.classesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parent_form`: Exposes CRUD operations for the **parent_form** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parent_forms
    * const parent_forms = await prisma.parent_form.findMany()
    * ```
    */
  get parent_form(): Prisma.parent_formDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    active_class: 'active_class',
    agenda: 'agenda',
    employee: 'employee',
    employee_role: 'employee_role',
    final_grade: 'final_grade',
    job: 'job',
    parent: 'parent',
    period: 'period',
    roles: 'roles',
    school_email: 'school_email',
    school_info: 'school_info',
    school_num: 'school_num',
    student: 'student',
    subject_class: 'subject_class',
    subjects: 'subjects',
    test: 'test',
    test_result: 'test_result',
    classes: 'classes',
    parent_form: 'parent_form'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "active_class" | "agenda" | "employee" | "employee_role" | "final_grade" | "job" | "parent" | "period" | "roles" | "school_email" | "school_info" | "school_num" | "student" | "subject_class" | "subjects" | "test" | "test_result" | "classes" | "parent_form"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      active_class: {
        payload: Prisma.$active_classPayload<ExtArgs>
        fields: Prisma.active_classFieldRefs
        operations: {
          findUnique: {
            args: Prisma.active_classFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_classPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.active_classFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_classPayload>
          }
          findFirst: {
            args: Prisma.active_classFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_classPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.active_classFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_classPayload>
          }
          findMany: {
            args: Prisma.active_classFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_classPayload>[]
          }
          create: {
            args: Prisma.active_classCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_classPayload>
          }
          createMany: {
            args: Prisma.active_classCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.active_classDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_classPayload>
          }
          update: {
            args: Prisma.active_classUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_classPayload>
          }
          deleteMany: {
            args: Prisma.active_classDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.active_classUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.active_classUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_classPayload>
          }
          aggregate: {
            args: Prisma.Active_classAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActive_class>
          }
          groupBy: {
            args: Prisma.active_classGroupByArgs<ExtArgs>
            result: $Utils.Optional<Active_classGroupByOutputType>[]
          }
          count: {
            args: Prisma.active_classCountArgs<ExtArgs>
            result: $Utils.Optional<Active_classCountAggregateOutputType> | number
          }
        }
      }
      agenda: {
        payload: Prisma.$agendaPayload<ExtArgs>
        fields: Prisma.agendaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.agendaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.agendaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaPayload>
          }
          findFirst: {
            args: Prisma.agendaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.agendaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaPayload>
          }
          findMany: {
            args: Prisma.agendaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaPayload>[]
          }
          create: {
            args: Prisma.agendaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaPayload>
          }
          createMany: {
            args: Prisma.agendaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.agendaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaPayload>
          }
          update: {
            args: Prisma.agendaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaPayload>
          }
          deleteMany: {
            args: Prisma.agendaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.agendaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.agendaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaPayload>
          }
          aggregate: {
            args: Prisma.AgendaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgenda>
          }
          groupBy: {
            args: Prisma.agendaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgendaGroupByOutputType>[]
          }
          count: {
            args: Prisma.agendaCountArgs<ExtArgs>
            result: $Utils.Optional<AgendaCountAggregateOutputType> | number
          }
        }
      }
      employee: {
        payload: Prisma.$employeePayload<ExtArgs>
        fields: Prisma.employeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.employeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.employeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          findFirst: {
            args: Prisma.employeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.employeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          findMany: {
            args: Prisma.employeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>[]
          }
          create: {
            args: Prisma.employeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          createMany: {
            args: Prisma.employeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.employeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          update: {
            args: Prisma.employeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          deleteMany: {
            args: Prisma.employeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.employeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.employeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.employeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.employeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      employee_role: {
        payload: Prisma.$employee_rolePayload<ExtArgs>
        fields: Prisma.employee_roleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.employee_roleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_rolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.employee_roleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_rolePayload>
          }
          findFirst: {
            args: Prisma.employee_roleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_rolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.employee_roleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_rolePayload>
          }
          findMany: {
            args: Prisma.employee_roleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_rolePayload>[]
          }
          create: {
            args: Prisma.employee_roleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_rolePayload>
          }
          createMany: {
            args: Prisma.employee_roleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.employee_roleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_rolePayload>
          }
          update: {
            args: Prisma.employee_roleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_rolePayload>
          }
          deleteMany: {
            args: Prisma.employee_roleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.employee_roleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.employee_roleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employee_rolePayload>
          }
          aggregate: {
            args: Prisma.Employee_roleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee_role>
          }
          groupBy: {
            args: Prisma.employee_roleGroupByArgs<ExtArgs>
            result: $Utils.Optional<Employee_roleGroupByOutputType>[]
          }
          count: {
            args: Prisma.employee_roleCountArgs<ExtArgs>
            result: $Utils.Optional<Employee_roleCountAggregateOutputType> | number
          }
        }
      }
      final_grade: {
        payload: Prisma.$final_gradePayload<ExtArgs>
        fields: Prisma.final_gradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.final_gradeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$final_gradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.final_gradeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$final_gradePayload>
          }
          findFirst: {
            args: Prisma.final_gradeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$final_gradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.final_gradeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$final_gradePayload>
          }
          findMany: {
            args: Prisma.final_gradeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$final_gradePayload>[]
          }
          create: {
            args: Prisma.final_gradeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$final_gradePayload>
          }
          createMany: {
            args: Prisma.final_gradeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.final_gradeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$final_gradePayload>
          }
          update: {
            args: Prisma.final_gradeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$final_gradePayload>
          }
          deleteMany: {
            args: Prisma.final_gradeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.final_gradeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.final_gradeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$final_gradePayload>
          }
          aggregate: {
            args: Prisma.Final_gradeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinal_grade>
          }
          groupBy: {
            args: Prisma.final_gradeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Final_gradeGroupByOutputType>[]
          }
          count: {
            args: Prisma.final_gradeCountArgs<ExtArgs>
            result: $Utils.Optional<Final_gradeCountAggregateOutputType> | number
          }
        }
      }
      job: {
        payload: Prisma.$jobPayload<ExtArgs>
        fields: Prisma.jobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.jobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.jobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          findFirst: {
            args: Prisma.jobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.jobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          findMany: {
            args: Prisma.jobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>[]
          }
          create: {
            args: Prisma.jobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          createMany: {
            args: Prisma.jobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.jobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          update: {
            args: Prisma.jobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          deleteMany: {
            args: Prisma.jobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.jobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.jobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          aggregate: {
            args: Prisma.JobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob>
          }
          groupBy: {
            args: Prisma.jobGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobGroupByOutputType>[]
          }
          count: {
            args: Prisma.jobCountArgs<ExtArgs>
            result: $Utils.Optional<JobCountAggregateOutputType> | number
          }
        }
      }
      parent: {
        payload: Prisma.$parentPayload<ExtArgs>
        fields: Prisma.parentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.parentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.parentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentPayload>
          }
          findFirst: {
            args: Prisma.parentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.parentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentPayload>
          }
          findMany: {
            args: Prisma.parentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentPayload>[]
          }
          create: {
            args: Prisma.parentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentPayload>
          }
          createMany: {
            args: Prisma.parentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.parentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentPayload>
          }
          update: {
            args: Prisma.parentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentPayload>
          }
          deleteMany: {
            args: Prisma.parentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.parentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.parentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentPayload>
          }
          aggregate: {
            args: Prisma.ParentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParent>
          }
          groupBy: {
            args: Prisma.parentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentGroupByOutputType>[]
          }
          count: {
            args: Prisma.parentCountArgs<ExtArgs>
            result: $Utils.Optional<ParentCountAggregateOutputType> | number
          }
        }
      }
      period: {
        payload: Prisma.$periodPayload<ExtArgs>
        fields: Prisma.periodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.periodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$periodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.periodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$periodPayload>
          }
          findFirst: {
            args: Prisma.periodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$periodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.periodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$periodPayload>
          }
          findMany: {
            args: Prisma.periodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$periodPayload>[]
          }
          create: {
            args: Prisma.periodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$periodPayload>
          }
          createMany: {
            args: Prisma.periodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.periodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$periodPayload>
          }
          update: {
            args: Prisma.periodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$periodPayload>
          }
          deleteMany: {
            args: Prisma.periodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.periodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.periodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$periodPayload>
          }
          aggregate: {
            args: Prisma.PeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePeriod>
          }
          groupBy: {
            args: Prisma.periodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.periodCountArgs<ExtArgs>
            result: $Utils.Optional<PeriodCountAggregateOutputType> | number
          }
        }
      }
      roles: {
        payload: Prisma.$rolesPayload<ExtArgs>
        fields: Prisma.rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findFirst: {
            args: Prisma.rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findMany: {
            args: Prisma.rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          create: {
            args: Prisma.rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          createMany: {
            args: Prisma.rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          update: {
            args: Prisma.rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          deleteMany: {
            args: Prisma.rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      school_email: {
        payload: Prisma.$school_emailPayload<ExtArgs>
        fields: Prisma.school_emailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.school_emailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_emailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.school_emailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_emailPayload>
          }
          findFirst: {
            args: Prisma.school_emailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_emailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.school_emailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_emailPayload>
          }
          findMany: {
            args: Prisma.school_emailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_emailPayload>[]
          }
          create: {
            args: Prisma.school_emailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_emailPayload>
          }
          createMany: {
            args: Prisma.school_emailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.school_emailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_emailPayload>
          }
          update: {
            args: Prisma.school_emailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_emailPayload>
          }
          deleteMany: {
            args: Prisma.school_emailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.school_emailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.school_emailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_emailPayload>
          }
          aggregate: {
            args: Prisma.School_emailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchool_email>
          }
          groupBy: {
            args: Prisma.school_emailGroupByArgs<ExtArgs>
            result: $Utils.Optional<School_emailGroupByOutputType>[]
          }
          count: {
            args: Prisma.school_emailCountArgs<ExtArgs>
            result: $Utils.Optional<School_emailCountAggregateOutputType> | number
          }
        }
      }
      school_info: {
        payload: Prisma.$school_infoPayload<ExtArgs>
        fields: Prisma.school_infoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.school_infoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_infoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.school_infoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_infoPayload>
          }
          findFirst: {
            args: Prisma.school_infoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_infoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.school_infoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_infoPayload>
          }
          findMany: {
            args: Prisma.school_infoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_infoPayload>[]
          }
          create: {
            args: Prisma.school_infoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_infoPayload>
          }
          createMany: {
            args: Prisma.school_infoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.school_infoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_infoPayload>
          }
          update: {
            args: Prisma.school_infoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_infoPayload>
          }
          deleteMany: {
            args: Prisma.school_infoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.school_infoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.school_infoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_infoPayload>
          }
          aggregate: {
            args: Prisma.School_infoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchool_info>
          }
          groupBy: {
            args: Prisma.school_infoGroupByArgs<ExtArgs>
            result: $Utils.Optional<School_infoGroupByOutputType>[]
          }
          count: {
            args: Prisma.school_infoCountArgs<ExtArgs>
            result: $Utils.Optional<School_infoCountAggregateOutputType> | number
          }
        }
      }
      school_num: {
        payload: Prisma.$school_numPayload<ExtArgs>
        fields: Prisma.school_numFieldRefs
        operations: {
          findUnique: {
            args: Prisma.school_numFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_numPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.school_numFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_numPayload>
          }
          findFirst: {
            args: Prisma.school_numFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_numPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.school_numFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_numPayload>
          }
          findMany: {
            args: Prisma.school_numFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_numPayload>[]
          }
          create: {
            args: Prisma.school_numCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_numPayload>
          }
          createMany: {
            args: Prisma.school_numCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.school_numDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_numPayload>
          }
          update: {
            args: Prisma.school_numUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_numPayload>
          }
          deleteMany: {
            args: Prisma.school_numDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.school_numUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.school_numUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$school_numPayload>
          }
          aggregate: {
            args: Prisma.School_numAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchool_num>
          }
          groupBy: {
            args: Prisma.school_numGroupByArgs<ExtArgs>
            result: $Utils.Optional<School_numGroupByOutputType>[]
          }
          count: {
            args: Prisma.school_numCountArgs<ExtArgs>
            result: $Utils.Optional<School_numCountAggregateOutputType> | number
          }
        }
      }
      student: {
        payload: Prisma.$studentPayload<ExtArgs>
        fields: Prisma.studentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.studentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.studentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          findFirst: {
            args: Prisma.studentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.studentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          findMany: {
            args: Prisma.studentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>[]
          }
          create: {
            args: Prisma.studentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          createMany: {
            args: Prisma.studentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.studentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          update: {
            args: Prisma.studentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          deleteMany: {
            args: Prisma.studentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.studentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.studentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.studentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.studentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      subject_class: {
        payload: Prisma.$subject_classPayload<ExtArgs>
        fields: Prisma.subject_classFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subject_classFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_classPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subject_classFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_classPayload>
          }
          findFirst: {
            args: Prisma.subject_classFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_classPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subject_classFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_classPayload>
          }
          findMany: {
            args: Prisma.subject_classFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_classPayload>[]
          }
          create: {
            args: Prisma.subject_classCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_classPayload>
          }
          createMany: {
            args: Prisma.subject_classCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.subject_classDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_classPayload>
          }
          update: {
            args: Prisma.subject_classUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_classPayload>
          }
          deleteMany: {
            args: Prisma.subject_classDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subject_classUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.subject_classUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subject_classPayload>
          }
          aggregate: {
            args: Prisma.Subject_classAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject_class>
          }
          groupBy: {
            args: Prisma.subject_classGroupByArgs<ExtArgs>
            result: $Utils.Optional<Subject_classGroupByOutputType>[]
          }
          count: {
            args: Prisma.subject_classCountArgs<ExtArgs>
            result: $Utils.Optional<Subject_classCountAggregateOutputType> | number
          }
        }
      }
      subjects: {
        payload: Prisma.$subjectsPayload<ExtArgs>
        fields: Prisma.subjectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subjectsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subjectsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          findFirst: {
            args: Prisma.subjectsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subjectsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          findMany: {
            args: Prisma.subjectsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>[]
          }
          create: {
            args: Prisma.subjectsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          createMany: {
            args: Prisma.subjectsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.subjectsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          update: {
            args: Prisma.subjectsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          deleteMany: {
            args: Prisma.subjectsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subjectsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.subjectsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subjectsPayload>
          }
          aggregate: {
            args: Prisma.SubjectsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubjects>
          }
          groupBy: {
            args: Prisma.subjectsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectsGroupByOutputType>[]
          }
          count: {
            args: Prisma.subjectsCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectsCountAggregateOutputType> | number
          }
        }
      }
      test: {
        payload: Prisma.$testPayload<ExtArgs>
        fields: Prisma.testFieldRefs
        operations: {
          findUnique: {
            args: Prisma.testFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.testFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testPayload>
          }
          findFirst: {
            args: Prisma.testFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.testFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testPayload>
          }
          findMany: {
            args: Prisma.testFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testPayload>[]
          }
          create: {
            args: Prisma.testCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testPayload>
          }
          createMany: {
            args: Prisma.testCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.testDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testPayload>
          }
          update: {
            args: Prisma.testUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testPayload>
          }
          deleteMany: {
            args: Prisma.testDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.testUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.testUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testPayload>
          }
          aggregate: {
            args: Prisma.TestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest>
          }
          groupBy: {
            args: Prisma.testGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestGroupByOutputType>[]
          }
          count: {
            args: Prisma.testCountArgs<ExtArgs>
            result: $Utils.Optional<TestCountAggregateOutputType> | number
          }
        }
      }
      test_result: {
        payload: Prisma.$test_resultPayload<ExtArgs>
        fields: Prisma.test_resultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.test_resultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_resultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.test_resultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_resultPayload>
          }
          findFirst: {
            args: Prisma.test_resultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_resultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.test_resultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_resultPayload>
          }
          findMany: {
            args: Prisma.test_resultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_resultPayload>[]
          }
          create: {
            args: Prisma.test_resultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_resultPayload>
          }
          createMany: {
            args: Prisma.test_resultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.test_resultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_resultPayload>
          }
          update: {
            args: Prisma.test_resultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_resultPayload>
          }
          deleteMany: {
            args: Prisma.test_resultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.test_resultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.test_resultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$test_resultPayload>
          }
          aggregate: {
            args: Prisma.Test_resultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTest_result>
          }
          groupBy: {
            args: Prisma.test_resultGroupByArgs<ExtArgs>
            result: $Utils.Optional<Test_resultGroupByOutputType>[]
          }
          count: {
            args: Prisma.test_resultCountArgs<ExtArgs>
            result: $Utils.Optional<Test_resultCountAggregateOutputType> | number
          }
        }
      }
      classes: {
        payload: Prisma.$classesPayload<ExtArgs>
        fields: Prisma.classesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.classesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.classesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>
          }
          findFirst: {
            args: Prisma.classesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.classesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>
          }
          findMany: {
            args: Prisma.classesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>[]
          }
          create: {
            args: Prisma.classesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>
          }
          createMany: {
            args: Prisma.classesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.classesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>
          }
          update: {
            args: Prisma.classesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>
          }
          deleteMany: {
            args: Prisma.classesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.classesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.classesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classesPayload>
          }
          aggregate: {
            args: Prisma.ClassesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClasses>
          }
          groupBy: {
            args: Prisma.classesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassesGroupByOutputType>[]
          }
          count: {
            args: Prisma.classesCountArgs<ExtArgs>
            result: $Utils.Optional<ClassesCountAggregateOutputType> | number
          }
        }
      }
      parent_form: {
        payload: Prisma.$parent_formPayload<ExtArgs>
        fields: Prisma.parent_formFieldRefs
        operations: {
          findUnique: {
            args: Prisma.parent_formFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_formPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.parent_formFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_formPayload>
          }
          findFirst: {
            args: Prisma.parent_formFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_formPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.parent_formFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_formPayload>
          }
          findMany: {
            args: Prisma.parent_formFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_formPayload>[]
          }
          create: {
            args: Prisma.parent_formCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_formPayload>
          }
          createMany: {
            args: Prisma.parent_formCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.parent_formDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_formPayload>
          }
          update: {
            args: Prisma.parent_formUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_formPayload>
          }
          deleteMany: {
            args: Prisma.parent_formDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.parent_formUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.parent_formUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_formPayload>
          }
          aggregate: {
            args: Prisma.Parent_formAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParent_form>
          }
          groupBy: {
            args: Prisma.parent_formGroupByArgs<ExtArgs>
            result: $Utils.Optional<Parent_formGroupByOutputType>[]
          }
          count: {
            args: Prisma.parent_formCountArgs<ExtArgs>
            result: $Utils.Optional<Parent_formCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    active_class?: active_classOmit
    agenda?: agendaOmit
    employee?: employeeOmit
    employee_role?: employee_roleOmit
    final_grade?: final_gradeOmit
    job?: jobOmit
    parent?: parentOmit
    period?: periodOmit
    roles?: rolesOmit
    school_email?: school_emailOmit
    school_info?: school_infoOmit
    school_num?: school_numOmit
    student?: studentOmit
    subject_class?: subject_classOmit
    subjects?: subjectsOmit
    test?: testOmit
    test_result?: test_resultOmit
    classes?: classesOmit
    parent_form?: parent_formOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    active_class: number
    employee_role: number
    subject_class: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    active_class?: boolean | EmployeeCountOutputTypeCountActive_classArgs
    employee_role?: boolean | EmployeeCountOutputTypeCountEmployee_roleArgs
    subject_class?: boolean | EmployeeCountOutputTypeCountSubject_classArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountActive_classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: active_classWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountEmployee_roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employee_roleWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountSubject_classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subject_classWhereInput
  }


  /**
   * Count Type ParentCountOutputType
   */

  export type ParentCountOutputType = {
    job: number
    student_student_father_idToparent: number
    student_student_mother_idToparent: number
  }

  export type ParentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | ParentCountOutputTypeCountJobArgs
    student_student_father_idToparent?: boolean | ParentCountOutputTypeCountStudent_student_father_idToparentArgs
    student_student_mother_idToparent?: boolean | ParentCountOutputTypeCountStudent_student_mother_idToparentArgs
  }

  // Custom InputTypes
  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentCountOutputType
     */
    select?: ParentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeCountJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobWhereInput
  }

  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeCountStudent_student_father_idToparentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentWhereInput
  }

  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeCountStudent_student_mother_idToparentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentWhereInput
  }


  /**
   * Count Type PeriodCountOutputType
   */

  export type PeriodCountOutputType = {
    active_class_active_class_periodToperiod: number
  }

  export type PeriodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    active_class_active_class_periodToperiod?: boolean | PeriodCountOutputTypeCountActive_class_active_class_periodToperiodArgs
  }

  // Custom InputTypes
  /**
   * PeriodCountOutputType without action
   */
  export type PeriodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodCountOutputType
     */
    select?: PeriodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PeriodCountOutputType without action
   */
  export type PeriodCountOutputTypeCountActive_class_active_class_periodToperiodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: active_classWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    employee_role: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee_role?: boolean | RolesCountOutputTypeCountEmployee_roleArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountEmployee_roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employee_roleWhereInput
  }


  /**
   * Count Type School_infoCountOutputType
   */

  export type School_infoCountOutputType = {
    school_email: number
    school_num: number
  }

  export type School_infoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school_email?: boolean | School_infoCountOutputTypeCountSchool_emailArgs
    school_num?: boolean | School_infoCountOutputTypeCountSchool_numArgs
  }

  // Custom InputTypes
  /**
   * School_infoCountOutputType without action
   */
  export type School_infoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School_infoCountOutputType
     */
    select?: School_infoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * School_infoCountOutputType without action
   */
  export type School_infoCountOutputTypeCountSchool_emailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: school_emailWhereInput
  }

  /**
   * School_infoCountOutputType without action
   */
  export type School_infoCountOutputTypeCountSchool_numArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: school_numWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    final_grade: number
    test_result: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    final_grade?: boolean | StudentCountOutputTypeCountFinal_gradeArgs
    test_result?: boolean | StudentCountOutputTypeCountTest_resultArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountFinal_gradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: final_gradeWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountTest_resultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_resultWhereInput
  }


  /**
   * Count Type Subject_classCountOutputType
   */

  export type Subject_classCountOutputType = {
    agenda: number
    test: number
  }

  export type Subject_classCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agenda?: boolean | Subject_classCountOutputTypeCountAgendaArgs
    test?: boolean | Subject_classCountOutputTypeCountTestArgs
  }

  // Custom InputTypes
  /**
   * Subject_classCountOutputType without action
   */
  export type Subject_classCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject_classCountOutputType
     */
    select?: Subject_classCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Subject_classCountOutputType without action
   */
  export type Subject_classCountOutputTypeCountAgendaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: agendaWhereInput
  }

  /**
   * Subject_classCountOutputType without action
   */
  export type Subject_classCountOutputTypeCountTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: testWhereInput
  }


  /**
   * Count Type SubjectsCountOutputType
   */

  export type SubjectsCountOutputType = {
    final_grade: number
    subject_class: number
  }

  export type SubjectsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    final_grade?: boolean | SubjectsCountOutputTypeCountFinal_gradeArgs
    subject_class?: boolean | SubjectsCountOutputTypeCountSubject_classArgs
  }

  // Custom InputTypes
  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectsCountOutputType
     */
    select?: SubjectsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeCountFinal_gradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: final_gradeWhereInput
  }

  /**
   * SubjectsCountOutputType without action
   */
  export type SubjectsCountOutputTypeCountSubject_classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subject_classWhereInput
  }


  /**
   * Count Type TestCountOutputType
   */

  export type TestCountOutputType = {
    test_result: number
  }

  export type TestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test_result?: boolean | TestCountOutputTypeCountTest_resultArgs
  }

  // Custom InputTypes
  /**
   * TestCountOutputType without action
   */
  export type TestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestCountOutputType
     */
    select?: TestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestCountOutputType without action
   */
  export type TestCountOutputTypeCountTest_resultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_resultWhereInput
  }


  /**
   * Count Type ClassesCountOutputType
   */

  export type ClassesCountOutputType = {
    active_class: number
  }

  export type ClassesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    active_class?: boolean | ClassesCountOutputTypeCountActive_classArgs
  }

  // Custom InputTypes
  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassesCountOutputType
     */
    select?: ClassesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassesCountOutputType without action
   */
  export type ClassesCountOutputTypeCountActive_classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: active_classWhereInput
  }


  /**
   * Models
   */

  /**
   * Model active_class
   */

  export type AggregateActive_class = {
    _count: Active_classCountAggregateOutputType | null
    _avg: Active_classAvgAggregateOutputType | null
    _sum: Active_classSumAggregateOutputType | null
    _min: Active_classMinAggregateOutputType | null
    _max: Active_classMaxAggregateOutputType | null
  }

  export type Active_classAvgAggregateOutputType = {
    active_class_id: number | null
    period: number | null
    class_coordinator: number | null
  }

  export type Active_classSumAggregateOutputType = {
    active_class_id: number | null
    period: number | null
    class_coordinator: number | null
  }

  export type Active_classMinAggregateOutputType = {
    active_class_id: number | null
    class_code: string | null
    period: number | null
    class_coordinator: number | null
  }

  export type Active_classMaxAggregateOutputType = {
    active_class_id: number | null
    class_code: string | null
    period: number | null
    class_coordinator: number | null
  }

  export type Active_classCountAggregateOutputType = {
    active_class_id: number
    class_code: number
    period: number
    class_coordinator: number
    _all: number
  }


  export type Active_classAvgAggregateInputType = {
    active_class_id?: true
    period?: true
    class_coordinator?: true
  }

  export type Active_classSumAggregateInputType = {
    active_class_id?: true
    period?: true
    class_coordinator?: true
  }

  export type Active_classMinAggregateInputType = {
    active_class_id?: true
    class_code?: true
    period?: true
    class_coordinator?: true
  }

  export type Active_classMaxAggregateInputType = {
    active_class_id?: true
    class_code?: true
    period?: true
    class_coordinator?: true
  }

  export type Active_classCountAggregateInputType = {
    active_class_id?: true
    class_code?: true
    period?: true
    class_coordinator?: true
    _all?: true
  }

  export type Active_classAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which active_class to aggregate.
     */
    where?: active_classWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of active_classes to fetch.
     */
    orderBy?: active_classOrderByWithRelationInput | active_classOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: active_classWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` active_classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` active_classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned active_classes
    **/
    _count?: true | Active_classCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Active_classAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Active_classSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Active_classMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Active_classMaxAggregateInputType
  }

  export type GetActive_classAggregateType<T extends Active_classAggregateArgs> = {
        [P in keyof T & keyof AggregateActive_class]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActive_class[P]>
      : GetScalarType<T[P], AggregateActive_class[P]>
  }




  export type active_classGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: active_classWhereInput
    orderBy?: active_classOrderByWithAggregationInput | active_classOrderByWithAggregationInput[]
    by: Active_classScalarFieldEnum[] | Active_classScalarFieldEnum
    having?: active_classScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Active_classCountAggregateInputType | true
    _avg?: Active_classAvgAggregateInputType
    _sum?: Active_classSumAggregateInputType
    _min?: Active_classMinAggregateInputType
    _max?: Active_classMaxAggregateInputType
  }

  export type Active_classGroupByOutputType = {
    active_class_id: number
    class_code: string | null
    period: number | null
    class_coordinator: number | null
    _count: Active_classCountAggregateOutputType | null
    _avg: Active_classAvgAggregateOutputType | null
    _sum: Active_classSumAggregateOutputType | null
    _min: Active_classMinAggregateOutputType | null
    _max: Active_classMaxAggregateOutputType | null
  }

  type GetActive_classGroupByPayload<T extends active_classGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Active_classGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Active_classGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Active_classGroupByOutputType[P]>
            : GetScalarType<T[P], Active_classGroupByOutputType[P]>
        }
      >
    >


  export type active_classSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    active_class_id?: boolean
    class_code?: boolean
    period?: boolean
    class_coordinator?: boolean
    Renamedclass?: boolean | active_class$RenamedclassArgs<ExtArgs>
    period_active_class_periodToperiod?: boolean | active_class$period_active_class_periodToperiodArgs<ExtArgs>
    employee?: boolean | active_class$employeeArgs<ExtArgs>
  }, ExtArgs["result"]["active_class"]>



  export type active_classSelectScalar = {
    active_class_id?: boolean
    class_code?: boolean
    period?: boolean
    class_coordinator?: boolean
  }

  export type active_classOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"active_class_id" | "class_code" | "period" | "class_coordinator", ExtArgs["result"]["active_class"]>
  export type active_classInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Renamedclass?: boolean | active_class$RenamedclassArgs<ExtArgs>
    period_active_class_periodToperiod?: boolean | active_class$period_active_class_periodToperiodArgs<ExtArgs>
    employee?: boolean | active_class$employeeArgs<ExtArgs>
  }

  export type $active_classPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "active_class"
    objects: {
      Renamedclass: Prisma.$classesPayload<ExtArgs> | null
      period_active_class_periodToperiod: Prisma.$periodPayload<ExtArgs> | null
      employee: Prisma.$employeePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      active_class_id: number
      class_code: string | null
      period: number | null
      class_coordinator: number | null
    }, ExtArgs["result"]["active_class"]>
    composites: {}
  }

  type active_classGetPayload<S extends boolean | null | undefined | active_classDefaultArgs> = $Result.GetResult<Prisma.$active_classPayload, S>

  type active_classCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<active_classFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Active_classCountAggregateInputType | true
    }

  export interface active_classDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['active_class'], meta: { name: 'active_class' } }
    /**
     * Find zero or one Active_class that matches the filter.
     * @param {active_classFindUniqueArgs} args - Arguments to find a Active_class
     * @example
     * // Get one Active_class
     * const active_class = await prisma.active_class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends active_classFindUniqueArgs>(args: SelectSubset<T, active_classFindUniqueArgs<ExtArgs>>): Prisma__active_classClient<$Result.GetResult<Prisma.$active_classPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Active_class that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {active_classFindUniqueOrThrowArgs} args - Arguments to find a Active_class
     * @example
     * // Get one Active_class
     * const active_class = await prisma.active_class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends active_classFindUniqueOrThrowArgs>(args: SelectSubset<T, active_classFindUniqueOrThrowArgs<ExtArgs>>): Prisma__active_classClient<$Result.GetResult<Prisma.$active_classPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Active_class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_classFindFirstArgs} args - Arguments to find a Active_class
     * @example
     * // Get one Active_class
     * const active_class = await prisma.active_class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends active_classFindFirstArgs>(args?: SelectSubset<T, active_classFindFirstArgs<ExtArgs>>): Prisma__active_classClient<$Result.GetResult<Prisma.$active_classPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Active_class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_classFindFirstOrThrowArgs} args - Arguments to find a Active_class
     * @example
     * // Get one Active_class
     * const active_class = await prisma.active_class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends active_classFindFirstOrThrowArgs>(args?: SelectSubset<T, active_classFindFirstOrThrowArgs<ExtArgs>>): Prisma__active_classClient<$Result.GetResult<Prisma.$active_classPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Active_classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_classFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Active_classes
     * const active_classes = await prisma.active_class.findMany()
     * 
     * // Get first 10 Active_classes
     * const active_classes = await prisma.active_class.findMany({ take: 10 })
     * 
     * // Only select the `active_class_id`
     * const active_classWithActive_class_idOnly = await prisma.active_class.findMany({ select: { active_class_id: true } })
     * 
     */
    findMany<T extends active_classFindManyArgs>(args?: SelectSubset<T, active_classFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$active_classPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Active_class.
     * @param {active_classCreateArgs} args - Arguments to create a Active_class.
     * @example
     * // Create one Active_class
     * const Active_class = await prisma.active_class.create({
     *   data: {
     *     // ... data to create a Active_class
     *   }
     * })
     * 
     */
    create<T extends active_classCreateArgs>(args: SelectSubset<T, active_classCreateArgs<ExtArgs>>): Prisma__active_classClient<$Result.GetResult<Prisma.$active_classPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Active_classes.
     * @param {active_classCreateManyArgs} args - Arguments to create many Active_classes.
     * @example
     * // Create many Active_classes
     * const active_class = await prisma.active_class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends active_classCreateManyArgs>(args?: SelectSubset<T, active_classCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Active_class.
     * @param {active_classDeleteArgs} args - Arguments to delete one Active_class.
     * @example
     * // Delete one Active_class
     * const Active_class = await prisma.active_class.delete({
     *   where: {
     *     // ... filter to delete one Active_class
     *   }
     * })
     * 
     */
    delete<T extends active_classDeleteArgs>(args: SelectSubset<T, active_classDeleteArgs<ExtArgs>>): Prisma__active_classClient<$Result.GetResult<Prisma.$active_classPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Active_class.
     * @param {active_classUpdateArgs} args - Arguments to update one Active_class.
     * @example
     * // Update one Active_class
     * const active_class = await prisma.active_class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends active_classUpdateArgs>(args: SelectSubset<T, active_classUpdateArgs<ExtArgs>>): Prisma__active_classClient<$Result.GetResult<Prisma.$active_classPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Active_classes.
     * @param {active_classDeleteManyArgs} args - Arguments to filter Active_classes to delete.
     * @example
     * // Delete a few Active_classes
     * const { count } = await prisma.active_class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends active_classDeleteManyArgs>(args?: SelectSubset<T, active_classDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Active_classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_classUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Active_classes
     * const active_class = await prisma.active_class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends active_classUpdateManyArgs>(args: SelectSubset<T, active_classUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Active_class.
     * @param {active_classUpsertArgs} args - Arguments to update or create a Active_class.
     * @example
     * // Update or create a Active_class
     * const active_class = await prisma.active_class.upsert({
     *   create: {
     *     // ... data to create a Active_class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Active_class we want to update
     *   }
     * })
     */
    upsert<T extends active_classUpsertArgs>(args: SelectSubset<T, active_classUpsertArgs<ExtArgs>>): Prisma__active_classClient<$Result.GetResult<Prisma.$active_classPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Active_classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_classCountArgs} args - Arguments to filter Active_classes to count.
     * @example
     * // Count the number of Active_classes
     * const count = await prisma.active_class.count({
     *   where: {
     *     // ... the filter for the Active_classes we want to count
     *   }
     * })
    **/
    count<T extends active_classCountArgs>(
      args?: Subset<T, active_classCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Active_classCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Active_class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Active_classAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Active_classAggregateArgs>(args: Subset<T, Active_classAggregateArgs>): Prisma.PrismaPromise<GetActive_classAggregateType<T>>

    /**
     * Group by Active_class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_classGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends active_classGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: active_classGroupByArgs['orderBy'] }
        : { orderBy?: active_classGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, active_classGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActive_classGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the active_class model
   */
  readonly fields: active_classFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for active_class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__active_classClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Renamedclass<T extends active_class$RenamedclassArgs<ExtArgs> = {}>(args?: Subset<T, active_class$RenamedclassArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    period_active_class_periodToperiod<T extends active_class$period_active_class_periodToperiodArgs<ExtArgs> = {}>(args?: Subset<T, active_class$period_active_class_periodToperiodArgs<ExtArgs>>): Prisma__periodClient<$Result.GetResult<Prisma.$periodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employee<T extends active_class$employeeArgs<ExtArgs> = {}>(args?: Subset<T, active_class$employeeArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the active_class model
   */
  interface active_classFieldRefs {
    readonly active_class_id: FieldRef<"active_class", 'Int'>
    readonly class_code: FieldRef<"active_class", 'String'>
    readonly period: FieldRef<"active_class", 'Int'>
    readonly class_coordinator: FieldRef<"active_class", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * active_class findUnique
   */
  export type active_classFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_class
     */
    select?: active_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_class
     */
    omit?: active_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_classInclude<ExtArgs> | null
    /**
     * Filter, which active_class to fetch.
     */
    where: active_classWhereUniqueInput
  }

  /**
   * active_class findUniqueOrThrow
   */
  export type active_classFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_class
     */
    select?: active_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_class
     */
    omit?: active_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_classInclude<ExtArgs> | null
    /**
     * Filter, which active_class to fetch.
     */
    where: active_classWhereUniqueInput
  }

  /**
   * active_class findFirst
   */
  export type active_classFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_class
     */
    select?: active_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_class
     */
    omit?: active_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_classInclude<ExtArgs> | null
    /**
     * Filter, which active_class to fetch.
     */
    where?: active_classWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of active_classes to fetch.
     */
    orderBy?: active_classOrderByWithRelationInput | active_classOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for active_classes.
     */
    cursor?: active_classWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` active_classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` active_classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of active_classes.
     */
    distinct?: Active_classScalarFieldEnum | Active_classScalarFieldEnum[]
  }

  /**
   * active_class findFirstOrThrow
   */
  export type active_classFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_class
     */
    select?: active_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_class
     */
    omit?: active_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_classInclude<ExtArgs> | null
    /**
     * Filter, which active_class to fetch.
     */
    where?: active_classWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of active_classes to fetch.
     */
    orderBy?: active_classOrderByWithRelationInput | active_classOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for active_classes.
     */
    cursor?: active_classWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` active_classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` active_classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of active_classes.
     */
    distinct?: Active_classScalarFieldEnum | Active_classScalarFieldEnum[]
  }

  /**
   * active_class findMany
   */
  export type active_classFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_class
     */
    select?: active_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_class
     */
    omit?: active_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_classInclude<ExtArgs> | null
    /**
     * Filter, which active_classes to fetch.
     */
    where?: active_classWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of active_classes to fetch.
     */
    orderBy?: active_classOrderByWithRelationInput | active_classOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing active_classes.
     */
    cursor?: active_classWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` active_classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` active_classes.
     */
    skip?: number
    distinct?: Active_classScalarFieldEnum | Active_classScalarFieldEnum[]
  }

  /**
   * active_class create
   */
  export type active_classCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_class
     */
    select?: active_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_class
     */
    omit?: active_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_classInclude<ExtArgs> | null
    /**
     * The data needed to create a active_class.
     */
    data?: XOR<active_classCreateInput, active_classUncheckedCreateInput>
  }

  /**
   * active_class createMany
   */
  export type active_classCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many active_classes.
     */
    data: active_classCreateManyInput | active_classCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * active_class update
   */
  export type active_classUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_class
     */
    select?: active_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_class
     */
    omit?: active_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_classInclude<ExtArgs> | null
    /**
     * The data needed to update a active_class.
     */
    data: XOR<active_classUpdateInput, active_classUncheckedUpdateInput>
    /**
     * Choose, which active_class to update.
     */
    where: active_classWhereUniqueInput
  }

  /**
   * active_class updateMany
   */
  export type active_classUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update active_classes.
     */
    data: XOR<active_classUpdateManyMutationInput, active_classUncheckedUpdateManyInput>
    /**
     * Filter which active_classes to update
     */
    where?: active_classWhereInput
    /**
     * Limit how many active_classes to update.
     */
    limit?: number
  }

  /**
   * active_class upsert
   */
  export type active_classUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_class
     */
    select?: active_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_class
     */
    omit?: active_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_classInclude<ExtArgs> | null
    /**
     * The filter to search for the active_class to update in case it exists.
     */
    where: active_classWhereUniqueInput
    /**
     * In case the active_class found by the `where` argument doesn't exist, create a new active_class with this data.
     */
    create: XOR<active_classCreateInput, active_classUncheckedCreateInput>
    /**
     * In case the active_class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<active_classUpdateInput, active_classUncheckedUpdateInput>
  }

  /**
   * active_class delete
   */
  export type active_classDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_class
     */
    select?: active_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_class
     */
    omit?: active_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_classInclude<ExtArgs> | null
    /**
     * Filter which active_class to delete.
     */
    where: active_classWhereUniqueInput
  }

  /**
   * active_class deleteMany
   */
  export type active_classDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which active_classes to delete
     */
    where?: active_classWhereInput
    /**
     * Limit how many active_classes to delete.
     */
    limit?: number
  }

  /**
   * active_class.Renamedclass
   */
  export type active_class$RenamedclassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    where?: classesWhereInput
  }

  /**
   * active_class.period_active_class_periodToperiod
   */
  export type active_class$period_active_class_periodToperiodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the period
     */
    select?: periodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the period
     */
    omit?: periodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: periodInclude<ExtArgs> | null
    where?: periodWhereInput
  }

  /**
   * active_class.employee
   */
  export type active_class$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    where?: employeeWhereInput
  }

  /**
   * active_class without action
   */
  export type active_classDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_class
     */
    select?: active_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_class
     */
    omit?: active_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_classInclude<ExtArgs> | null
  }


  /**
   * Model agenda
   */

  export type AggregateAgenda = {
    _count: AgendaCountAggregateOutputType | null
    _avg: AgendaAvgAggregateOutputType | null
    _sum: AgendaSumAggregateOutputType | null
    _min: AgendaMinAggregateOutputType | null
    _max: AgendaMaxAggregateOutputType | null
  }

  export type AgendaAvgAggregateOutputType = {
    agenda_id: number | null
    subject_class_id: number | null
  }

  export type AgendaSumAggregateOutputType = {
    agenda_id: number | null
    subject_class_id: number | null
  }

  export type AgendaMinAggregateOutputType = {
    agenda_id: number | null
    subject_class_id: number | null
    agenda_title: string | null
    agenda_context: string | null
    agenda_annouced: Date | null
    agenda_due: Date | null
  }

  export type AgendaMaxAggregateOutputType = {
    agenda_id: number | null
    subject_class_id: number | null
    agenda_title: string | null
    agenda_context: string | null
    agenda_annouced: Date | null
    agenda_due: Date | null
  }

  export type AgendaCountAggregateOutputType = {
    agenda_id: number
    subject_class_id: number
    agenda_title: number
    agenda_context: number
    agenda_annouced: number
    agenda_due: number
    _all: number
  }


  export type AgendaAvgAggregateInputType = {
    agenda_id?: true
    subject_class_id?: true
  }

  export type AgendaSumAggregateInputType = {
    agenda_id?: true
    subject_class_id?: true
  }

  export type AgendaMinAggregateInputType = {
    agenda_id?: true
    subject_class_id?: true
    agenda_title?: true
    agenda_context?: true
    agenda_annouced?: true
    agenda_due?: true
  }

  export type AgendaMaxAggregateInputType = {
    agenda_id?: true
    subject_class_id?: true
    agenda_title?: true
    agenda_context?: true
    agenda_annouced?: true
    agenda_due?: true
  }

  export type AgendaCountAggregateInputType = {
    agenda_id?: true
    subject_class_id?: true
    agenda_title?: true
    agenda_context?: true
    agenda_annouced?: true
    agenda_due?: true
    _all?: true
  }

  export type AgendaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agenda to aggregate.
     */
    where?: agendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agenda to fetch.
     */
    orderBy?: agendaOrderByWithRelationInput | agendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: agendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agenda from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agenda.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned agenda
    **/
    _count?: true | AgendaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgendaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgendaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgendaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgendaMaxAggregateInputType
  }

  export type GetAgendaAggregateType<T extends AgendaAggregateArgs> = {
        [P in keyof T & keyof AggregateAgenda]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgenda[P]>
      : GetScalarType<T[P], AggregateAgenda[P]>
  }




  export type agendaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: agendaWhereInput
    orderBy?: agendaOrderByWithAggregationInput | agendaOrderByWithAggregationInput[]
    by: AgendaScalarFieldEnum[] | AgendaScalarFieldEnum
    having?: agendaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgendaCountAggregateInputType | true
    _avg?: AgendaAvgAggregateInputType
    _sum?: AgendaSumAggregateInputType
    _min?: AgendaMinAggregateInputType
    _max?: AgendaMaxAggregateInputType
  }

  export type AgendaGroupByOutputType = {
    agenda_id: number
    subject_class_id: number | null
    agenda_title: string
    agenda_context: string
    agenda_annouced: Date | null
    agenda_due: Date | null
    _count: AgendaCountAggregateOutputType | null
    _avg: AgendaAvgAggregateOutputType | null
    _sum: AgendaSumAggregateOutputType | null
    _min: AgendaMinAggregateOutputType | null
    _max: AgendaMaxAggregateOutputType | null
  }

  type GetAgendaGroupByPayload<T extends agendaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgendaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgendaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgendaGroupByOutputType[P]>
            : GetScalarType<T[P], AgendaGroupByOutputType[P]>
        }
      >
    >


  export type agendaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    agenda_id?: boolean
    subject_class_id?: boolean
    agenda_title?: boolean
    agenda_context?: boolean
    agenda_annouced?: boolean
    agenda_due?: boolean
    subject_class?: boolean | agenda$subject_classArgs<ExtArgs>
  }, ExtArgs["result"]["agenda"]>



  export type agendaSelectScalar = {
    agenda_id?: boolean
    subject_class_id?: boolean
    agenda_title?: boolean
    agenda_context?: boolean
    agenda_annouced?: boolean
    agenda_due?: boolean
  }

  export type agendaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"agenda_id" | "subject_class_id" | "agenda_title" | "agenda_context" | "agenda_annouced" | "agenda_due", ExtArgs["result"]["agenda"]>
  export type agendaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject_class?: boolean | agenda$subject_classArgs<ExtArgs>
  }

  export type $agendaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "agenda"
    objects: {
      subject_class: Prisma.$subject_classPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      agenda_id: number
      subject_class_id: number | null
      agenda_title: string
      agenda_context: string
      agenda_annouced: Date | null
      agenda_due: Date | null
    }, ExtArgs["result"]["agenda"]>
    composites: {}
  }

  type agendaGetPayload<S extends boolean | null | undefined | agendaDefaultArgs> = $Result.GetResult<Prisma.$agendaPayload, S>

  type agendaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<agendaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgendaCountAggregateInputType | true
    }

  export interface agendaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['agenda'], meta: { name: 'agenda' } }
    /**
     * Find zero or one Agenda that matches the filter.
     * @param {agendaFindUniqueArgs} args - Arguments to find a Agenda
     * @example
     * // Get one Agenda
     * const agenda = await prisma.agenda.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends agendaFindUniqueArgs>(args: SelectSubset<T, agendaFindUniqueArgs<ExtArgs>>): Prisma__agendaClient<$Result.GetResult<Prisma.$agendaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agenda that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {agendaFindUniqueOrThrowArgs} args - Arguments to find a Agenda
     * @example
     * // Get one Agenda
     * const agenda = await prisma.agenda.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends agendaFindUniqueOrThrowArgs>(args: SelectSubset<T, agendaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__agendaClient<$Result.GetResult<Prisma.$agendaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agenda that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendaFindFirstArgs} args - Arguments to find a Agenda
     * @example
     * // Get one Agenda
     * const agenda = await prisma.agenda.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends agendaFindFirstArgs>(args?: SelectSubset<T, agendaFindFirstArgs<ExtArgs>>): Prisma__agendaClient<$Result.GetResult<Prisma.$agendaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agenda that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendaFindFirstOrThrowArgs} args - Arguments to find a Agenda
     * @example
     * // Get one Agenda
     * const agenda = await prisma.agenda.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends agendaFindFirstOrThrowArgs>(args?: SelectSubset<T, agendaFindFirstOrThrowArgs<ExtArgs>>): Prisma__agendaClient<$Result.GetResult<Prisma.$agendaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agenda that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agenda
     * const agenda = await prisma.agenda.findMany()
     * 
     * // Get first 10 Agenda
     * const agenda = await prisma.agenda.findMany({ take: 10 })
     * 
     * // Only select the `agenda_id`
     * const agendaWithAgenda_idOnly = await prisma.agenda.findMany({ select: { agenda_id: true } })
     * 
     */
    findMany<T extends agendaFindManyArgs>(args?: SelectSubset<T, agendaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agendaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agenda.
     * @param {agendaCreateArgs} args - Arguments to create a Agenda.
     * @example
     * // Create one Agenda
     * const Agenda = await prisma.agenda.create({
     *   data: {
     *     // ... data to create a Agenda
     *   }
     * })
     * 
     */
    create<T extends agendaCreateArgs>(args: SelectSubset<T, agendaCreateArgs<ExtArgs>>): Prisma__agendaClient<$Result.GetResult<Prisma.$agendaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agenda.
     * @param {agendaCreateManyArgs} args - Arguments to create many Agenda.
     * @example
     * // Create many Agenda
     * const agenda = await prisma.agenda.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends agendaCreateManyArgs>(args?: SelectSubset<T, agendaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Agenda.
     * @param {agendaDeleteArgs} args - Arguments to delete one Agenda.
     * @example
     * // Delete one Agenda
     * const Agenda = await prisma.agenda.delete({
     *   where: {
     *     // ... filter to delete one Agenda
     *   }
     * })
     * 
     */
    delete<T extends agendaDeleteArgs>(args: SelectSubset<T, agendaDeleteArgs<ExtArgs>>): Prisma__agendaClient<$Result.GetResult<Prisma.$agendaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agenda.
     * @param {agendaUpdateArgs} args - Arguments to update one Agenda.
     * @example
     * // Update one Agenda
     * const agenda = await prisma.agenda.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends agendaUpdateArgs>(args: SelectSubset<T, agendaUpdateArgs<ExtArgs>>): Prisma__agendaClient<$Result.GetResult<Prisma.$agendaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agenda.
     * @param {agendaDeleteManyArgs} args - Arguments to filter Agenda to delete.
     * @example
     * // Delete a few Agenda
     * const { count } = await prisma.agenda.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends agendaDeleteManyArgs>(args?: SelectSubset<T, agendaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agenda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agenda
     * const agenda = await prisma.agenda.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends agendaUpdateManyArgs>(args: SelectSubset<T, agendaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agenda.
     * @param {agendaUpsertArgs} args - Arguments to update or create a Agenda.
     * @example
     * // Update or create a Agenda
     * const agenda = await prisma.agenda.upsert({
     *   create: {
     *     // ... data to create a Agenda
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agenda we want to update
     *   }
     * })
     */
    upsert<T extends agendaUpsertArgs>(args: SelectSubset<T, agendaUpsertArgs<ExtArgs>>): Prisma__agendaClient<$Result.GetResult<Prisma.$agendaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agenda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendaCountArgs} args - Arguments to filter Agenda to count.
     * @example
     * // Count the number of Agenda
     * const count = await prisma.agenda.count({
     *   where: {
     *     // ... the filter for the Agenda we want to count
     *   }
     * })
    **/
    count<T extends agendaCountArgs>(
      args?: Subset<T, agendaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgendaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agenda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgendaAggregateArgs>(args: Subset<T, AgendaAggregateArgs>): Prisma.PrismaPromise<GetAgendaAggregateType<T>>

    /**
     * Group by Agenda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends agendaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: agendaGroupByArgs['orderBy'] }
        : { orderBy?: agendaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, agendaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgendaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the agenda model
   */
  readonly fields: agendaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for agenda.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__agendaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject_class<T extends agenda$subject_classArgs<ExtArgs> = {}>(args?: Subset<T, agenda$subject_classArgs<ExtArgs>>): Prisma__subject_classClient<$Result.GetResult<Prisma.$subject_classPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the agenda model
   */
  interface agendaFieldRefs {
    readonly agenda_id: FieldRef<"agenda", 'Int'>
    readonly subject_class_id: FieldRef<"agenda", 'Int'>
    readonly agenda_title: FieldRef<"agenda", 'String'>
    readonly agenda_context: FieldRef<"agenda", 'String'>
    readonly agenda_annouced: FieldRef<"agenda", 'DateTime'>
    readonly agenda_due: FieldRef<"agenda", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * agenda findUnique
   */
  export type agendaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda
     */
    select?: agendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agenda
     */
    omit?: agendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agendaInclude<ExtArgs> | null
    /**
     * Filter, which agenda to fetch.
     */
    where: agendaWhereUniqueInput
  }

  /**
   * agenda findUniqueOrThrow
   */
  export type agendaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda
     */
    select?: agendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agenda
     */
    omit?: agendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agendaInclude<ExtArgs> | null
    /**
     * Filter, which agenda to fetch.
     */
    where: agendaWhereUniqueInput
  }

  /**
   * agenda findFirst
   */
  export type agendaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda
     */
    select?: agendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agenda
     */
    omit?: agendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agendaInclude<ExtArgs> | null
    /**
     * Filter, which agenda to fetch.
     */
    where?: agendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agenda to fetch.
     */
    orderBy?: agendaOrderByWithRelationInput | agendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agenda.
     */
    cursor?: agendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agenda from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agenda.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agenda.
     */
    distinct?: AgendaScalarFieldEnum | AgendaScalarFieldEnum[]
  }

  /**
   * agenda findFirstOrThrow
   */
  export type agendaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda
     */
    select?: agendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agenda
     */
    omit?: agendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agendaInclude<ExtArgs> | null
    /**
     * Filter, which agenda to fetch.
     */
    where?: agendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agenda to fetch.
     */
    orderBy?: agendaOrderByWithRelationInput | agendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agenda.
     */
    cursor?: agendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agenda from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agenda.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agenda.
     */
    distinct?: AgendaScalarFieldEnum | AgendaScalarFieldEnum[]
  }

  /**
   * agenda findMany
   */
  export type agendaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda
     */
    select?: agendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agenda
     */
    omit?: agendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agendaInclude<ExtArgs> | null
    /**
     * Filter, which agenda to fetch.
     */
    where?: agendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agenda to fetch.
     */
    orderBy?: agendaOrderByWithRelationInput | agendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing agenda.
     */
    cursor?: agendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agenda from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agenda.
     */
    skip?: number
    distinct?: AgendaScalarFieldEnum | AgendaScalarFieldEnum[]
  }

  /**
   * agenda create
   */
  export type agendaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda
     */
    select?: agendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agenda
     */
    omit?: agendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agendaInclude<ExtArgs> | null
    /**
     * The data needed to create a agenda.
     */
    data: XOR<agendaCreateInput, agendaUncheckedCreateInput>
  }

  /**
   * agenda createMany
   */
  export type agendaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many agenda.
     */
    data: agendaCreateManyInput | agendaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * agenda update
   */
  export type agendaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda
     */
    select?: agendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agenda
     */
    omit?: agendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agendaInclude<ExtArgs> | null
    /**
     * The data needed to update a agenda.
     */
    data: XOR<agendaUpdateInput, agendaUncheckedUpdateInput>
    /**
     * Choose, which agenda to update.
     */
    where: agendaWhereUniqueInput
  }

  /**
   * agenda updateMany
   */
  export type agendaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update agenda.
     */
    data: XOR<agendaUpdateManyMutationInput, agendaUncheckedUpdateManyInput>
    /**
     * Filter which agenda to update
     */
    where?: agendaWhereInput
    /**
     * Limit how many agenda to update.
     */
    limit?: number
  }

  /**
   * agenda upsert
   */
  export type agendaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda
     */
    select?: agendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agenda
     */
    omit?: agendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agendaInclude<ExtArgs> | null
    /**
     * The filter to search for the agenda to update in case it exists.
     */
    where: agendaWhereUniqueInput
    /**
     * In case the agenda found by the `where` argument doesn't exist, create a new agenda with this data.
     */
    create: XOR<agendaCreateInput, agendaUncheckedCreateInput>
    /**
     * In case the agenda was found with the provided `where` argument, update it with this data.
     */
    update: XOR<agendaUpdateInput, agendaUncheckedUpdateInput>
  }

  /**
   * agenda delete
   */
  export type agendaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda
     */
    select?: agendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agenda
     */
    omit?: agendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agendaInclude<ExtArgs> | null
    /**
     * Filter which agenda to delete.
     */
    where: agendaWhereUniqueInput
  }

  /**
   * agenda deleteMany
   */
  export type agendaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agenda to delete
     */
    where?: agendaWhereInput
    /**
     * Limit how many agenda to delete.
     */
    limit?: number
  }

  /**
   * agenda.subject_class
   */
  export type agenda$subject_classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_class
     */
    select?: subject_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_class
     */
    omit?: subject_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_classInclude<ExtArgs> | null
    where?: subject_classWhereInput
  }

  /**
   * agenda without action
   */
  export type agendaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda
     */
    select?: agendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agenda
     */
    omit?: agendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agendaInclude<ExtArgs> | null
  }


  /**
   * Model employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    employee_id: number | null
    employee_sal1: number | null
    employee_sal2: number | null
    employee_wh: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    employee_id: number | null
    employee_sal1: number | null
    employee_sal2: number | null
    employee_wh: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    employee_id: number | null
    employee_fn: string | null
    employee_ln: string | null
    employee_dob: Date | null
    employee_join: Date | null
    employee_img: string | null
    employee_info: string | null
    employee_degree: string | null
    employee_exp: Date | null
    employee_sal1: number | null
    employee_sal2: number | null
    employee_wh: number | null
  }

  export type EmployeeMaxAggregateOutputType = {
    employee_id: number | null
    employee_fn: string | null
    employee_ln: string | null
    employee_dob: Date | null
    employee_join: Date | null
    employee_img: string | null
    employee_info: string | null
    employee_degree: string | null
    employee_exp: Date | null
    employee_sal1: number | null
    employee_sal2: number | null
    employee_wh: number | null
  }

  export type EmployeeCountAggregateOutputType = {
    employee_id: number
    employee_fn: number
    employee_ln: number
    employee_dob: number
    employee_join: number
    employee_img: number
    employee_info: number
    employee_degree: number
    employee_exp: number
    employee_sal1: number
    employee_sal2: number
    employee_wh: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    employee_id?: true
    employee_sal1?: true
    employee_sal2?: true
    employee_wh?: true
  }

  export type EmployeeSumAggregateInputType = {
    employee_id?: true
    employee_sal1?: true
    employee_sal2?: true
    employee_wh?: true
  }

  export type EmployeeMinAggregateInputType = {
    employee_id?: true
    employee_fn?: true
    employee_ln?: true
    employee_dob?: true
    employee_join?: true
    employee_img?: true
    employee_info?: true
    employee_degree?: true
    employee_exp?: true
    employee_sal1?: true
    employee_sal2?: true
    employee_wh?: true
  }

  export type EmployeeMaxAggregateInputType = {
    employee_id?: true
    employee_fn?: true
    employee_ln?: true
    employee_dob?: true
    employee_join?: true
    employee_img?: true
    employee_info?: true
    employee_degree?: true
    employee_exp?: true
    employee_sal1?: true
    employee_sal2?: true
    employee_wh?: true
  }

  export type EmployeeCountAggregateInputType = {
    employee_id?: true
    employee_fn?: true
    employee_ln?: true
    employee_dob?: true
    employee_join?: true
    employee_img?: true
    employee_info?: true
    employee_degree?: true
    employee_exp?: true
    employee_sal1?: true
    employee_sal2?: true
    employee_wh?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employee to aggregate.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type employeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeWhereInput
    orderBy?: employeeOrderByWithAggregationInput | employeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: employeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    employee_id: number
    employee_fn: string
    employee_ln: string
    employee_dob: Date
    employee_join: Date | null
    employee_img: string | null
    employee_info: string | null
    employee_degree: string | null
    employee_exp: Date | null
    employee_sal1: number
    employee_sal2: number | null
    employee_wh: number | null
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends employeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type employeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employee_id?: boolean
    employee_fn?: boolean
    employee_ln?: boolean
    employee_dob?: boolean
    employee_join?: boolean
    employee_img?: boolean
    employee_info?: boolean
    employee_degree?: boolean
    employee_exp?: boolean
    employee_sal1?: boolean
    employee_sal2?: boolean
    employee_wh?: boolean
    active_class?: boolean | employee$active_classArgs<ExtArgs>
    employee_role?: boolean | employee$employee_roleArgs<ExtArgs>
    subject_class?: boolean | employee$subject_classArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>



  export type employeeSelectScalar = {
    employee_id?: boolean
    employee_fn?: boolean
    employee_ln?: boolean
    employee_dob?: boolean
    employee_join?: boolean
    employee_img?: boolean
    employee_info?: boolean
    employee_degree?: boolean
    employee_exp?: boolean
    employee_sal1?: boolean
    employee_sal2?: boolean
    employee_wh?: boolean
  }

  export type employeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"employee_id" | "employee_fn" | "employee_ln" | "employee_dob" | "employee_join" | "employee_img" | "employee_info" | "employee_degree" | "employee_exp" | "employee_sal1" | "employee_sal2" | "employee_wh", ExtArgs["result"]["employee"]>
  export type employeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    active_class?: boolean | employee$active_classArgs<ExtArgs>
    employee_role?: boolean | employee$employee_roleArgs<ExtArgs>
    subject_class?: boolean | employee$subject_classArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $employeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "employee"
    objects: {
      active_class: Prisma.$active_classPayload<ExtArgs>[]
      employee_role: Prisma.$employee_rolePayload<ExtArgs>[]
      subject_class: Prisma.$subject_classPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      employee_id: number
      employee_fn: string
      employee_ln: string
      employee_dob: Date
      employee_join: Date | null
      employee_img: string | null
      employee_info: string | null
      employee_degree: string | null
      employee_exp: Date | null
      employee_sal1: number
      employee_sal2: number | null
      employee_wh: number | null
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type employeeGetPayload<S extends boolean | null | undefined | employeeDefaultArgs> = $Result.GetResult<Prisma.$employeePayload, S>

  type employeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<employeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface employeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['employee'], meta: { name: 'employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {employeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends employeeFindUniqueArgs>(args: SelectSubset<T, employeeFindUniqueArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {employeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends employeeFindUniqueOrThrowArgs>(args: SelectSubset<T, employeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends employeeFindFirstArgs>(args?: SelectSubset<T, employeeFindFirstArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends employeeFindFirstOrThrowArgs>(args?: SelectSubset<T, employeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `employee_id`
     * const employeeWithEmployee_idOnly = await prisma.employee.findMany({ select: { employee_id: true } })
     * 
     */
    findMany<T extends employeeFindManyArgs>(args?: SelectSubset<T, employeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {employeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends employeeCreateArgs>(args: SelectSubset<T, employeeCreateArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {employeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends employeeCreateManyArgs>(args?: SelectSubset<T, employeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Employee.
     * @param {employeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends employeeDeleteArgs>(args: SelectSubset<T, employeeDeleteArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {employeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends employeeUpdateArgs>(args: SelectSubset<T, employeeUpdateArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {employeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends employeeDeleteManyArgs>(args?: SelectSubset<T, employeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends employeeUpdateManyArgs>(args: SelectSubset<T, employeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee.
     * @param {employeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends employeeUpsertArgs>(args: SelectSubset<T, employeeUpsertArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends employeeCountArgs>(
      args?: Subset<T, employeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends employeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: employeeGroupByArgs['orderBy'] }
        : { orderBy?: employeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, employeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the employee model
   */
  readonly fields: employeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__employeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    active_class<T extends employee$active_classArgs<ExtArgs> = {}>(args?: Subset<T, employee$active_classArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$active_classPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employee_role<T extends employee$employee_roleArgs<ExtArgs> = {}>(args?: Subset<T, employee$employee_roleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employee_rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subject_class<T extends employee$subject_classArgs<ExtArgs> = {}>(args?: Subset<T, employee$subject_classArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subject_classPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the employee model
   */
  interface employeeFieldRefs {
    readonly employee_id: FieldRef<"employee", 'Int'>
    readonly employee_fn: FieldRef<"employee", 'String'>
    readonly employee_ln: FieldRef<"employee", 'String'>
    readonly employee_dob: FieldRef<"employee", 'DateTime'>
    readonly employee_join: FieldRef<"employee", 'DateTime'>
    readonly employee_img: FieldRef<"employee", 'String'>
    readonly employee_info: FieldRef<"employee", 'String'>
    readonly employee_degree: FieldRef<"employee", 'String'>
    readonly employee_exp: FieldRef<"employee", 'DateTime'>
    readonly employee_sal1: FieldRef<"employee", 'Float'>
    readonly employee_sal2: FieldRef<"employee", 'Float'>
    readonly employee_wh: FieldRef<"employee", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * employee findUnique
   */
  export type employeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee findUniqueOrThrow
   */
  export type employeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee findFirst
   */
  export type employeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employees.
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * employee findFirstOrThrow
   */
  export type employeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employees.
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * employee findMany
   */
  export type employeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employees to fetch.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing employees.
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * employee create
   */
  export type employeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * The data needed to create a employee.
     */
    data: XOR<employeeCreateInput, employeeUncheckedCreateInput>
  }

  /**
   * employee createMany
   */
  export type employeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many employees.
     */
    data: employeeCreateManyInput | employeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * employee update
   */
  export type employeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * The data needed to update a employee.
     */
    data: XOR<employeeUpdateInput, employeeUncheckedUpdateInput>
    /**
     * Choose, which employee to update.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee updateMany
   */
  export type employeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update employees.
     */
    data: XOR<employeeUpdateManyMutationInput, employeeUncheckedUpdateManyInput>
    /**
     * Filter which employees to update
     */
    where?: employeeWhereInput
    /**
     * Limit how many employees to update.
     */
    limit?: number
  }

  /**
   * employee upsert
   */
  export type employeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * The filter to search for the employee to update in case it exists.
     */
    where: employeeWhereUniqueInput
    /**
     * In case the employee found by the `where` argument doesn't exist, create a new employee with this data.
     */
    create: XOR<employeeCreateInput, employeeUncheckedCreateInput>
    /**
     * In case the employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<employeeUpdateInput, employeeUncheckedUpdateInput>
  }

  /**
   * employee delete
   */
  export type employeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter which employee to delete.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee deleteMany
   */
  export type employeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employees to delete
     */
    where?: employeeWhereInput
    /**
     * Limit how many employees to delete.
     */
    limit?: number
  }

  /**
   * employee.active_class
   */
  export type employee$active_classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_class
     */
    select?: active_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_class
     */
    omit?: active_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_classInclude<ExtArgs> | null
    where?: active_classWhereInput
    orderBy?: active_classOrderByWithRelationInput | active_classOrderByWithRelationInput[]
    cursor?: active_classWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Active_classScalarFieldEnum | Active_classScalarFieldEnum[]
  }

  /**
   * employee.employee_role
   */
  export type employee$employee_roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_role
     */
    select?: employee_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_role
     */
    omit?: employee_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_roleInclude<ExtArgs> | null
    where?: employee_roleWhereInput
    orderBy?: employee_roleOrderByWithRelationInput | employee_roleOrderByWithRelationInput[]
    cursor?: employee_roleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Employee_roleScalarFieldEnum | Employee_roleScalarFieldEnum[]
  }

  /**
   * employee.subject_class
   */
  export type employee$subject_classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_class
     */
    select?: subject_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_class
     */
    omit?: subject_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_classInclude<ExtArgs> | null
    where?: subject_classWhereInput
    orderBy?: subject_classOrderByWithRelationInput | subject_classOrderByWithRelationInput[]
    cursor?: subject_classWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Subject_classScalarFieldEnum | Subject_classScalarFieldEnum[]
  }

  /**
   * employee without action
   */
  export type employeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
  }


  /**
   * Model employee_role
   */

  export type AggregateEmployee_role = {
    _count: Employee_roleCountAggregateOutputType | null
    _avg: Employee_roleAvgAggregateOutputType | null
    _sum: Employee_roleSumAggregateOutputType | null
    _min: Employee_roleMinAggregateOutputType | null
    _max: Employee_roleMaxAggregateOutputType | null
  }

  export type Employee_roleAvgAggregateOutputType = {
    employee_role_id: number | null
    role_id: number | null
    employee_id: number | null
  }

  export type Employee_roleSumAggregateOutputType = {
    employee_role_id: number | null
    role_id: number | null
    employee_id: number | null
  }

  export type Employee_roleMinAggregateOutputType = {
    employee_role_id: number | null
    role_id: number | null
    employee_id: number | null
  }

  export type Employee_roleMaxAggregateOutputType = {
    employee_role_id: number | null
    role_id: number | null
    employee_id: number | null
  }

  export type Employee_roleCountAggregateOutputType = {
    employee_role_id: number
    role_id: number
    employee_id: number
    _all: number
  }


  export type Employee_roleAvgAggregateInputType = {
    employee_role_id?: true
    role_id?: true
    employee_id?: true
  }

  export type Employee_roleSumAggregateInputType = {
    employee_role_id?: true
    role_id?: true
    employee_id?: true
  }

  export type Employee_roleMinAggregateInputType = {
    employee_role_id?: true
    role_id?: true
    employee_id?: true
  }

  export type Employee_roleMaxAggregateInputType = {
    employee_role_id?: true
    role_id?: true
    employee_id?: true
  }

  export type Employee_roleCountAggregateInputType = {
    employee_role_id?: true
    role_id?: true
    employee_id?: true
    _all?: true
  }

  export type Employee_roleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employee_role to aggregate.
     */
    where?: employee_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employee_roles to fetch.
     */
    orderBy?: employee_roleOrderByWithRelationInput | employee_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: employee_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employee_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employee_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned employee_roles
    **/
    _count?: true | Employee_roleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Employee_roleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Employee_roleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Employee_roleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Employee_roleMaxAggregateInputType
  }

  export type GetEmployee_roleAggregateType<T extends Employee_roleAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee_role]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee_role[P]>
      : GetScalarType<T[P], AggregateEmployee_role[P]>
  }




  export type employee_roleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employee_roleWhereInput
    orderBy?: employee_roleOrderByWithAggregationInput | employee_roleOrderByWithAggregationInput[]
    by: Employee_roleScalarFieldEnum[] | Employee_roleScalarFieldEnum
    having?: employee_roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Employee_roleCountAggregateInputType | true
    _avg?: Employee_roleAvgAggregateInputType
    _sum?: Employee_roleSumAggregateInputType
    _min?: Employee_roleMinAggregateInputType
    _max?: Employee_roleMaxAggregateInputType
  }

  export type Employee_roleGroupByOutputType = {
    employee_role_id: number
    role_id: number
    employee_id: number
    _count: Employee_roleCountAggregateOutputType | null
    _avg: Employee_roleAvgAggregateOutputType | null
    _sum: Employee_roleSumAggregateOutputType | null
    _min: Employee_roleMinAggregateOutputType | null
    _max: Employee_roleMaxAggregateOutputType | null
  }

  type GetEmployee_roleGroupByPayload<T extends employee_roleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Employee_roleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Employee_roleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Employee_roleGroupByOutputType[P]>
            : GetScalarType<T[P], Employee_roleGroupByOutputType[P]>
        }
      >
    >


  export type employee_roleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employee_role_id?: boolean
    role_id?: boolean
    employee_id?: boolean
    roles?: boolean | rolesDefaultArgs<ExtArgs>
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee_role"]>



  export type employee_roleSelectScalar = {
    employee_role_id?: boolean
    role_id?: boolean
    employee_id?: boolean
  }

  export type employee_roleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"employee_role_id" | "role_id" | "employee_id", ExtArgs["result"]["employee_role"]>
  export type employee_roleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | rolesDefaultArgs<ExtArgs>
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }

  export type $employee_rolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "employee_role"
    objects: {
      roles: Prisma.$rolesPayload<ExtArgs>
      employee: Prisma.$employeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      employee_role_id: number
      role_id: number
      employee_id: number
    }, ExtArgs["result"]["employee_role"]>
    composites: {}
  }

  type employee_roleGetPayload<S extends boolean | null | undefined | employee_roleDefaultArgs> = $Result.GetResult<Prisma.$employee_rolePayload, S>

  type employee_roleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<employee_roleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Employee_roleCountAggregateInputType | true
    }

  export interface employee_roleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['employee_role'], meta: { name: 'employee_role' } }
    /**
     * Find zero or one Employee_role that matches the filter.
     * @param {employee_roleFindUniqueArgs} args - Arguments to find a Employee_role
     * @example
     * // Get one Employee_role
     * const employee_role = await prisma.employee_role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends employee_roleFindUniqueArgs>(args: SelectSubset<T, employee_roleFindUniqueArgs<ExtArgs>>): Prisma__employee_roleClient<$Result.GetResult<Prisma.$employee_rolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee_role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {employee_roleFindUniqueOrThrowArgs} args - Arguments to find a Employee_role
     * @example
     * // Get one Employee_role
     * const employee_role = await prisma.employee_role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends employee_roleFindUniqueOrThrowArgs>(args: SelectSubset<T, employee_roleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__employee_roleClient<$Result.GetResult<Prisma.$employee_rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee_role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_roleFindFirstArgs} args - Arguments to find a Employee_role
     * @example
     * // Get one Employee_role
     * const employee_role = await prisma.employee_role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends employee_roleFindFirstArgs>(args?: SelectSubset<T, employee_roleFindFirstArgs<ExtArgs>>): Prisma__employee_roleClient<$Result.GetResult<Prisma.$employee_rolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee_role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_roleFindFirstOrThrowArgs} args - Arguments to find a Employee_role
     * @example
     * // Get one Employee_role
     * const employee_role = await prisma.employee_role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends employee_roleFindFirstOrThrowArgs>(args?: SelectSubset<T, employee_roleFindFirstOrThrowArgs<ExtArgs>>): Prisma__employee_roleClient<$Result.GetResult<Prisma.$employee_rolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employee_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_roleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employee_roles
     * const employee_roles = await prisma.employee_role.findMany()
     * 
     * // Get first 10 Employee_roles
     * const employee_roles = await prisma.employee_role.findMany({ take: 10 })
     * 
     * // Only select the `employee_role_id`
     * const employee_roleWithEmployee_role_idOnly = await prisma.employee_role.findMany({ select: { employee_role_id: true } })
     * 
     */
    findMany<T extends employee_roleFindManyArgs>(args?: SelectSubset<T, employee_roleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employee_rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee_role.
     * @param {employee_roleCreateArgs} args - Arguments to create a Employee_role.
     * @example
     * // Create one Employee_role
     * const Employee_role = await prisma.employee_role.create({
     *   data: {
     *     // ... data to create a Employee_role
     *   }
     * })
     * 
     */
    create<T extends employee_roleCreateArgs>(args: SelectSubset<T, employee_roleCreateArgs<ExtArgs>>): Prisma__employee_roleClient<$Result.GetResult<Prisma.$employee_rolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employee_roles.
     * @param {employee_roleCreateManyArgs} args - Arguments to create many Employee_roles.
     * @example
     * // Create many Employee_roles
     * const employee_role = await prisma.employee_role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends employee_roleCreateManyArgs>(args?: SelectSubset<T, employee_roleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Employee_role.
     * @param {employee_roleDeleteArgs} args - Arguments to delete one Employee_role.
     * @example
     * // Delete one Employee_role
     * const Employee_role = await prisma.employee_role.delete({
     *   where: {
     *     // ... filter to delete one Employee_role
     *   }
     * })
     * 
     */
    delete<T extends employee_roleDeleteArgs>(args: SelectSubset<T, employee_roleDeleteArgs<ExtArgs>>): Prisma__employee_roleClient<$Result.GetResult<Prisma.$employee_rolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee_role.
     * @param {employee_roleUpdateArgs} args - Arguments to update one Employee_role.
     * @example
     * // Update one Employee_role
     * const employee_role = await prisma.employee_role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends employee_roleUpdateArgs>(args: SelectSubset<T, employee_roleUpdateArgs<ExtArgs>>): Prisma__employee_roleClient<$Result.GetResult<Prisma.$employee_rolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employee_roles.
     * @param {employee_roleDeleteManyArgs} args - Arguments to filter Employee_roles to delete.
     * @example
     * // Delete a few Employee_roles
     * const { count } = await prisma.employee_role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends employee_roleDeleteManyArgs>(args?: SelectSubset<T, employee_roleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employee_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employee_roles
     * const employee_role = await prisma.employee_role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends employee_roleUpdateManyArgs>(args: SelectSubset<T, employee_roleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee_role.
     * @param {employee_roleUpsertArgs} args - Arguments to update or create a Employee_role.
     * @example
     * // Update or create a Employee_role
     * const employee_role = await prisma.employee_role.upsert({
     *   create: {
     *     // ... data to create a Employee_role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee_role we want to update
     *   }
     * })
     */
    upsert<T extends employee_roleUpsertArgs>(args: SelectSubset<T, employee_roleUpsertArgs<ExtArgs>>): Prisma__employee_roleClient<$Result.GetResult<Prisma.$employee_rolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employee_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_roleCountArgs} args - Arguments to filter Employee_roles to count.
     * @example
     * // Count the number of Employee_roles
     * const count = await prisma.employee_role.count({
     *   where: {
     *     // ... the filter for the Employee_roles we want to count
     *   }
     * })
    **/
    count<T extends employee_roleCountArgs>(
      args?: Subset<T, employee_roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Employee_roleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee_role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Employee_roleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Employee_roleAggregateArgs>(args: Subset<T, Employee_roleAggregateArgs>): Prisma.PrismaPromise<GetEmployee_roleAggregateType<T>>

    /**
     * Group by Employee_role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employee_roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends employee_roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: employee_roleGroupByArgs['orderBy'] }
        : { orderBy?: employee_roleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, employee_roleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployee_roleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the employee_role model
   */
  readonly fields: employee_roleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for employee_role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__employee_roleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeeDefaultArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the employee_role model
   */
  interface employee_roleFieldRefs {
    readonly employee_role_id: FieldRef<"employee_role", 'Int'>
    readonly role_id: FieldRef<"employee_role", 'Int'>
    readonly employee_id: FieldRef<"employee_role", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * employee_role findUnique
   */
  export type employee_roleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_role
     */
    select?: employee_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_role
     */
    omit?: employee_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_roleInclude<ExtArgs> | null
    /**
     * Filter, which employee_role to fetch.
     */
    where: employee_roleWhereUniqueInput
  }

  /**
   * employee_role findUniqueOrThrow
   */
  export type employee_roleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_role
     */
    select?: employee_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_role
     */
    omit?: employee_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_roleInclude<ExtArgs> | null
    /**
     * Filter, which employee_role to fetch.
     */
    where: employee_roleWhereUniqueInput
  }

  /**
   * employee_role findFirst
   */
  export type employee_roleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_role
     */
    select?: employee_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_role
     */
    omit?: employee_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_roleInclude<ExtArgs> | null
    /**
     * Filter, which employee_role to fetch.
     */
    where?: employee_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employee_roles to fetch.
     */
    orderBy?: employee_roleOrderByWithRelationInput | employee_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employee_roles.
     */
    cursor?: employee_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employee_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employee_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employee_roles.
     */
    distinct?: Employee_roleScalarFieldEnum | Employee_roleScalarFieldEnum[]
  }

  /**
   * employee_role findFirstOrThrow
   */
  export type employee_roleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_role
     */
    select?: employee_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_role
     */
    omit?: employee_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_roleInclude<ExtArgs> | null
    /**
     * Filter, which employee_role to fetch.
     */
    where?: employee_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employee_roles to fetch.
     */
    orderBy?: employee_roleOrderByWithRelationInput | employee_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employee_roles.
     */
    cursor?: employee_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employee_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employee_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employee_roles.
     */
    distinct?: Employee_roleScalarFieldEnum | Employee_roleScalarFieldEnum[]
  }

  /**
   * employee_role findMany
   */
  export type employee_roleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_role
     */
    select?: employee_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_role
     */
    omit?: employee_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_roleInclude<ExtArgs> | null
    /**
     * Filter, which employee_roles to fetch.
     */
    where?: employee_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employee_roles to fetch.
     */
    orderBy?: employee_roleOrderByWithRelationInput | employee_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing employee_roles.
     */
    cursor?: employee_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employee_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employee_roles.
     */
    skip?: number
    distinct?: Employee_roleScalarFieldEnum | Employee_roleScalarFieldEnum[]
  }

  /**
   * employee_role create
   */
  export type employee_roleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_role
     */
    select?: employee_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_role
     */
    omit?: employee_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_roleInclude<ExtArgs> | null
    /**
     * The data needed to create a employee_role.
     */
    data: XOR<employee_roleCreateInput, employee_roleUncheckedCreateInput>
  }

  /**
   * employee_role createMany
   */
  export type employee_roleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many employee_roles.
     */
    data: employee_roleCreateManyInput | employee_roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * employee_role update
   */
  export type employee_roleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_role
     */
    select?: employee_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_role
     */
    omit?: employee_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_roleInclude<ExtArgs> | null
    /**
     * The data needed to update a employee_role.
     */
    data: XOR<employee_roleUpdateInput, employee_roleUncheckedUpdateInput>
    /**
     * Choose, which employee_role to update.
     */
    where: employee_roleWhereUniqueInput
  }

  /**
   * employee_role updateMany
   */
  export type employee_roleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update employee_roles.
     */
    data: XOR<employee_roleUpdateManyMutationInput, employee_roleUncheckedUpdateManyInput>
    /**
     * Filter which employee_roles to update
     */
    where?: employee_roleWhereInput
    /**
     * Limit how many employee_roles to update.
     */
    limit?: number
  }

  /**
   * employee_role upsert
   */
  export type employee_roleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_role
     */
    select?: employee_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_role
     */
    omit?: employee_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_roleInclude<ExtArgs> | null
    /**
     * The filter to search for the employee_role to update in case it exists.
     */
    where: employee_roleWhereUniqueInput
    /**
     * In case the employee_role found by the `where` argument doesn't exist, create a new employee_role with this data.
     */
    create: XOR<employee_roleCreateInput, employee_roleUncheckedCreateInput>
    /**
     * In case the employee_role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<employee_roleUpdateInput, employee_roleUncheckedUpdateInput>
  }

  /**
   * employee_role delete
   */
  export type employee_roleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_role
     */
    select?: employee_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_role
     */
    omit?: employee_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_roleInclude<ExtArgs> | null
    /**
     * Filter which employee_role to delete.
     */
    where: employee_roleWhereUniqueInput
  }

  /**
   * employee_role deleteMany
   */
  export type employee_roleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employee_roles to delete
     */
    where?: employee_roleWhereInput
    /**
     * Limit how many employee_roles to delete.
     */
    limit?: number
  }

  /**
   * employee_role without action
   */
  export type employee_roleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_role
     */
    select?: employee_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_role
     */
    omit?: employee_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_roleInclude<ExtArgs> | null
  }


  /**
   * Model final_grade
   */

  export type AggregateFinal_grade = {
    _count: Final_gradeCountAggregateOutputType | null
    _avg: Final_gradeAvgAggregateOutputType | null
    _sum: Final_gradeSumAggregateOutputType | null
    _min: Final_gradeMinAggregateOutputType | null
    _max: Final_gradeMaxAggregateOutputType | null
  }

  export type Final_gradeAvgAggregateOutputType = {
    final_grade_id: number | null
    final_grade: number | null
  }

  export type Final_gradeSumAggregateOutputType = {
    final_grade_id: number | null
    final_grade: number | null
  }

  export type Final_gradeMinAggregateOutputType = {
    final_grade_id: number | null
    subject_code: string | null
    final_grade: number | null
    student_id: string | null
    test_period: $Enums.final_grade_test_period | null
    created_at: Date | null
    final_status: string | null
  }

  export type Final_gradeMaxAggregateOutputType = {
    final_grade_id: number | null
    subject_code: string | null
    final_grade: number | null
    student_id: string | null
    test_period: $Enums.final_grade_test_period | null
    created_at: Date | null
    final_status: string | null
  }

  export type Final_gradeCountAggregateOutputType = {
    final_grade_id: number
    subject_code: number
    final_grade: number
    student_id: number
    test_period: number
    created_at: number
    final_status: number
    _all: number
  }


  export type Final_gradeAvgAggregateInputType = {
    final_grade_id?: true
    final_grade?: true
  }

  export type Final_gradeSumAggregateInputType = {
    final_grade_id?: true
    final_grade?: true
  }

  export type Final_gradeMinAggregateInputType = {
    final_grade_id?: true
    subject_code?: true
    final_grade?: true
    student_id?: true
    test_period?: true
    created_at?: true
    final_status?: true
  }

  export type Final_gradeMaxAggregateInputType = {
    final_grade_id?: true
    subject_code?: true
    final_grade?: true
    student_id?: true
    test_period?: true
    created_at?: true
    final_status?: true
  }

  export type Final_gradeCountAggregateInputType = {
    final_grade_id?: true
    subject_code?: true
    final_grade?: true
    student_id?: true
    test_period?: true
    created_at?: true
    final_status?: true
    _all?: true
  }

  export type Final_gradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which final_grade to aggregate.
     */
    where?: final_gradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of final_grades to fetch.
     */
    orderBy?: final_gradeOrderByWithRelationInput | final_gradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: final_gradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` final_grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` final_grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned final_grades
    **/
    _count?: true | Final_gradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Final_gradeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Final_gradeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Final_gradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Final_gradeMaxAggregateInputType
  }

  export type GetFinal_gradeAggregateType<T extends Final_gradeAggregateArgs> = {
        [P in keyof T & keyof AggregateFinal_grade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinal_grade[P]>
      : GetScalarType<T[P], AggregateFinal_grade[P]>
  }




  export type final_gradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: final_gradeWhereInput
    orderBy?: final_gradeOrderByWithAggregationInput | final_gradeOrderByWithAggregationInput[]
    by: Final_gradeScalarFieldEnum[] | Final_gradeScalarFieldEnum
    having?: final_gradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Final_gradeCountAggregateInputType | true
    _avg?: Final_gradeAvgAggregateInputType
    _sum?: Final_gradeSumAggregateInputType
    _min?: Final_gradeMinAggregateInputType
    _max?: Final_gradeMaxAggregateInputType
  }

  export type Final_gradeGroupByOutputType = {
    final_grade_id: number
    subject_code: string | null
    final_grade: number | null
    student_id: string | null
    test_period: $Enums.final_grade_test_period | null
    created_at: Date | null
    final_status: string | null
    _count: Final_gradeCountAggregateOutputType | null
    _avg: Final_gradeAvgAggregateOutputType | null
    _sum: Final_gradeSumAggregateOutputType | null
    _min: Final_gradeMinAggregateOutputType | null
    _max: Final_gradeMaxAggregateOutputType | null
  }

  type GetFinal_gradeGroupByPayload<T extends final_gradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Final_gradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Final_gradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Final_gradeGroupByOutputType[P]>
            : GetScalarType<T[P], Final_gradeGroupByOutputType[P]>
        }
      >
    >


  export type final_gradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    final_grade_id?: boolean
    subject_code?: boolean
    final_grade?: boolean
    student_id?: boolean
    test_period?: boolean
    created_at?: boolean
    final_status?: boolean
    subjects?: boolean | final_grade$subjectsArgs<ExtArgs>
    student?: boolean | final_grade$studentArgs<ExtArgs>
  }, ExtArgs["result"]["final_grade"]>



  export type final_gradeSelectScalar = {
    final_grade_id?: boolean
    subject_code?: boolean
    final_grade?: boolean
    student_id?: boolean
    test_period?: boolean
    created_at?: boolean
    final_status?: boolean
  }

  export type final_gradeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"final_grade_id" | "subject_code" | "final_grade" | "student_id" | "test_period" | "created_at" | "final_status", ExtArgs["result"]["final_grade"]>
  export type final_gradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subjects?: boolean | final_grade$subjectsArgs<ExtArgs>
    student?: boolean | final_grade$studentArgs<ExtArgs>
  }

  export type $final_gradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "final_grade"
    objects: {
      subjects: Prisma.$subjectsPayload<ExtArgs> | null
      student: Prisma.$studentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      final_grade_id: number
      subject_code: string | null
      final_grade: number | null
      student_id: string | null
      test_period: $Enums.final_grade_test_period | null
      created_at: Date | null
      final_status: string | null
    }, ExtArgs["result"]["final_grade"]>
    composites: {}
  }

  type final_gradeGetPayload<S extends boolean | null | undefined | final_gradeDefaultArgs> = $Result.GetResult<Prisma.$final_gradePayload, S>

  type final_gradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<final_gradeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Final_gradeCountAggregateInputType | true
    }

  export interface final_gradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['final_grade'], meta: { name: 'final_grade' } }
    /**
     * Find zero or one Final_grade that matches the filter.
     * @param {final_gradeFindUniqueArgs} args - Arguments to find a Final_grade
     * @example
     * // Get one Final_grade
     * const final_grade = await prisma.final_grade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends final_gradeFindUniqueArgs>(args: SelectSubset<T, final_gradeFindUniqueArgs<ExtArgs>>): Prisma__final_gradeClient<$Result.GetResult<Prisma.$final_gradePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Final_grade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {final_gradeFindUniqueOrThrowArgs} args - Arguments to find a Final_grade
     * @example
     * // Get one Final_grade
     * const final_grade = await prisma.final_grade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends final_gradeFindUniqueOrThrowArgs>(args: SelectSubset<T, final_gradeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__final_gradeClient<$Result.GetResult<Prisma.$final_gradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Final_grade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {final_gradeFindFirstArgs} args - Arguments to find a Final_grade
     * @example
     * // Get one Final_grade
     * const final_grade = await prisma.final_grade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends final_gradeFindFirstArgs>(args?: SelectSubset<T, final_gradeFindFirstArgs<ExtArgs>>): Prisma__final_gradeClient<$Result.GetResult<Prisma.$final_gradePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Final_grade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {final_gradeFindFirstOrThrowArgs} args - Arguments to find a Final_grade
     * @example
     * // Get one Final_grade
     * const final_grade = await prisma.final_grade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends final_gradeFindFirstOrThrowArgs>(args?: SelectSubset<T, final_gradeFindFirstOrThrowArgs<ExtArgs>>): Prisma__final_gradeClient<$Result.GetResult<Prisma.$final_gradePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Final_grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {final_gradeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Final_grades
     * const final_grades = await prisma.final_grade.findMany()
     * 
     * // Get first 10 Final_grades
     * const final_grades = await prisma.final_grade.findMany({ take: 10 })
     * 
     * // Only select the `final_grade_id`
     * const final_gradeWithFinal_grade_idOnly = await prisma.final_grade.findMany({ select: { final_grade_id: true } })
     * 
     */
    findMany<T extends final_gradeFindManyArgs>(args?: SelectSubset<T, final_gradeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$final_gradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Final_grade.
     * @param {final_gradeCreateArgs} args - Arguments to create a Final_grade.
     * @example
     * // Create one Final_grade
     * const Final_grade = await prisma.final_grade.create({
     *   data: {
     *     // ... data to create a Final_grade
     *   }
     * })
     * 
     */
    create<T extends final_gradeCreateArgs>(args: SelectSubset<T, final_gradeCreateArgs<ExtArgs>>): Prisma__final_gradeClient<$Result.GetResult<Prisma.$final_gradePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Final_grades.
     * @param {final_gradeCreateManyArgs} args - Arguments to create many Final_grades.
     * @example
     * // Create many Final_grades
     * const final_grade = await prisma.final_grade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends final_gradeCreateManyArgs>(args?: SelectSubset<T, final_gradeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Final_grade.
     * @param {final_gradeDeleteArgs} args - Arguments to delete one Final_grade.
     * @example
     * // Delete one Final_grade
     * const Final_grade = await prisma.final_grade.delete({
     *   where: {
     *     // ... filter to delete one Final_grade
     *   }
     * })
     * 
     */
    delete<T extends final_gradeDeleteArgs>(args: SelectSubset<T, final_gradeDeleteArgs<ExtArgs>>): Prisma__final_gradeClient<$Result.GetResult<Prisma.$final_gradePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Final_grade.
     * @param {final_gradeUpdateArgs} args - Arguments to update one Final_grade.
     * @example
     * // Update one Final_grade
     * const final_grade = await prisma.final_grade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends final_gradeUpdateArgs>(args: SelectSubset<T, final_gradeUpdateArgs<ExtArgs>>): Prisma__final_gradeClient<$Result.GetResult<Prisma.$final_gradePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Final_grades.
     * @param {final_gradeDeleteManyArgs} args - Arguments to filter Final_grades to delete.
     * @example
     * // Delete a few Final_grades
     * const { count } = await prisma.final_grade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends final_gradeDeleteManyArgs>(args?: SelectSubset<T, final_gradeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Final_grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {final_gradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Final_grades
     * const final_grade = await prisma.final_grade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends final_gradeUpdateManyArgs>(args: SelectSubset<T, final_gradeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Final_grade.
     * @param {final_gradeUpsertArgs} args - Arguments to update or create a Final_grade.
     * @example
     * // Update or create a Final_grade
     * const final_grade = await prisma.final_grade.upsert({
     *   create: {
     *     // ... data to create a Final_grade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Final_grade we want to update
     *   }
     * })
     */
    upsert<T extends final_gradeUpsertArgs>(args: SelectSubset<T, final_gradeUpsertArgs<ExtArgs>>): Prisma__final_gradeClient<$Result.GetResult<Prisma.$final_gradePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Final_grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {final_gradeCountArgs} args - Arguments to filter Final_grades to count.
     * @example
     * // Count the number of Final_grades
     * const count = await prisma.final_grade.count({
     *   where: {
     *     // ... the filter for the Final_grades we want to count
     *   }
     * })
    **/
    count<T extends final_gradeCountArgs>(
      args?: Subset<T, final_gradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Final_gradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Final_grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Final_gradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Final_gradeAggregateArgs>(args: Subset<T, Final_gradeAggregateArgs>): Prisma.PrismaPromise<GetFinal_gradeAggregateType<T>>

    /**
     * Group by Final_grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {final_gradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends final_gradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: final_gradeGroupByArgs['orderBy'] }
        : { orderBy?: final_gradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, final_gradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinal_gradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the final_grade model
   */
  readonly fields: final_gradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for final_grade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__final_gradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subjects<T extends final_grade$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, final_grade$subjectsArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    student<T extends final_grade$studentArgs<ExtArgs> = {}>(args?: Subset<T, final_grade$studentArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the final_grade model
   */
  interface final_gradeFieldRefs {
    readonly final_grade_id: FieldRef<"final_grade", 'Int'>
    readonly subject_code: FieldRef<"final_grade", 'String'>
    readonly final_grade: FieldRef<"final_grade", 'Float'>
    readonly student_id: FieldRef<"final_grade", 'String'>
    readonly test_period: FieldRef<"final_grade", 'final_grade_test_period'>
    readonly created_at: FieldRef<"final_grade", 'DateTime'>
    readonly final_status: FieldRef<"final_grade", 'String'>
  }
    

  // Custom InputTypes
  /**
   * final_grade findUnique
   */
  export type final_gradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grade
     */
    select?: final_gradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the final_grade
     */
    omit?: final_gradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradeInclude<ExtArgs> | null
    /**
     * Filter, which final_grade to fetch.
     */
    where: final_gradeWhereUniqueInput
  }

  /**
   * final_grade findUniqueOrThrow
   */
  export type final_gradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grade
     */
    select?: final_gradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the final_grade
     */
    omit?: final_gradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradeInclude<ExtArgs> | null
    /**
     * Filter, which final_grade to fetch.
     */
    where: final_gradeWhereUniqueInput
  }

  /**
   * final_grade findFirst
   */
  export type final_gradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grade
     */
    select?: final_gradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the final_grade
     */
    omit?: final_gradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradeInclude<ExtArgs> | null
    /**
     * Filter, which final_grade to fetch.
     */
    where?: final_gradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of final_grades to fetch.
     */
    orderBy?: final_gradeOrderByWithRelationInput | final_gradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for final_grades.
     */
    cursor?: final_gradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` final_grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` final_grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of final_grades.
     */
    distinct?: Final_gradeScalarFieldEnum | Final_gradeScalarFieldEnum[]
  }

  /**
   * final_grade findFirstOrThrow
   */
  export type final_gradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grade
     */
    select?: final_gradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the final_grade
     */
    omit?: final_gradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradeInclude<ExtArgs> | null
    /**
     * Filter, which final_grade to fetch.
     */
    where?: final_gradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of final_grades to fetch.
     */
    orderBy?: final_gradeOrderByWithRelationInput | final_gradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for final_grades.
     */
    cursor?: final_gradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` final_grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` final_grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of final_grades.
     */
    distinct?: Final_gradeScalarFieldEnum | Final_gradeScalarFieldEnum[]
  }

  /**
   * final_grade findMany
   */
  export type final_gradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grade
     */
    select?: final_gradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the final_grade
     */
    omit?: final_gradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradeInclude<ExtArgs> | null
    /**
     * Filter, which final_grades to fetch.
     */
    where?: final_gradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of final_grades to fetch.
     */
    orderBy?: final_gradeOrderByWithRelationInput | final_gradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing final_grades.
     */
    cursor?: final_gradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` final_grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` final_grades.
     */
    skip?: number
    distinct?: Final_gradeScalarFieldEnum | Final_gradeScalarFieldEnum[]
  }

  /**
   * final_grade create
   */
  export type final_gradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grade
     */
    select?: final_gradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the final_grade
     */
    omit?: final_gradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradeInclude<ExtArgs> | null
    /**
     * The data needed to create a final_grade.
     */
    data?: XOR<final_gradeCreateInput, final_gradeUncheckedCreateInput>
  }

  /**
   * final_grade createMany
   */
  export type final_gradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many final_grades.
     */
    data: final_gradeCreateManyInput | final_gradeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * final_grade update
   */
  export type final_gradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grade
     */
    select?: final_gradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the final_grade
     */
    omit?: final_gradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradeInclude<ExtArgs> | null
    /**
     * The data needed to update a final_grade.
     */
    data: XOR<final_gradeUpdateInput, final_gradeUncheckedUpdateInput>
    /**
     * Choose, which final_grade to update.
     */
    where: final_gradeWhereUniqueInput
  }

  /**
   * final_grade updateMany
   */
  export type final_gradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update final_grades.
     */
    data: XOR<final_gradeUpdateManyMutationInput, final_gradeUncheckedUpdateManyInput>
    /**
     * Filter which final_grades to update
     */
    where?: final_gradeWhereInput
    /**
     * Limit how many final_grades to update.
     */
    limit?: number
  }

  /**
   * final_grade upsert
   */
  export type final_gradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grade
     */
    select?: final_gradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the final_grade
     */
    omit?: final_gradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradeInclude<ExtArgs> | null
    /**
     * The filter to search for the final_grade to update in case it exists.
     */
    where: final_gradeWhereUniqueInput
    /**
     * In case the final_grade found by the `where` argument doesn't exist, create a new final_grade with this data.
     */
    create: XOR<final_gradeCreateInput, final_gradeUncheckedCreateInput>
    /**
     * In case the final_grade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<final_gradeUpdateInput, final_gradeUncheckedUpdateInput>
  }

  /**
   * final_grade delete
   */
  export type final_gradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grade
     */
    select?: final_gradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the final_grade
     */
    omit?: final_gradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradeInclude<ExtArgs> | null
    /**
     * Filter which final_grade to delete.
     */
    where: final_gradeWhereUniqueInput
  }

  /**
   * final_grade deleteMany
   */
  export type final_gradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which final_grades to delete
     */
    where?: final_gradeWhereInput
    /**
     * Limit how many final_grades to delete.
     */
    limit?: number
  }

  /**
   * final_grade.subjects
   */
  export type final_grade$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    where?: subjectsWhereInput
  }

  /**
   * final_grade.student
   */
  export type final_grade$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    where?: studentWhereInput
  }

  /**
   * final_grade without action
   */
  export type final_gradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grade
     */
    select?: final_gradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the final_grade
     */
    omit?: final_gradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradeInclude<ExtArgs> | null
  }


  /**
   * Model job
   */

  export type AggregateJob = {
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  export type JobAvgAggregateOutputType = {
    job_id: number | null
    parent_id: number | null
  }

  export type JobSumAggregateOutputType = {
    job_id: number | null
    parent_id: number | null
  }

  export type JobMinAggregateOutputType = {
    job_id: number | null
    parent_id: number | null
    job_company: string | null
    job_title: string | null
    work_email: string | null
    work_number: string | null
  }

  export type JobMaxAggregateOutputType = {
    job_id: number | null
    parent_id: number | null
    job_company: string | null
    job_title: string | null
    work_email: string | null
    work_number: string | null
  }

  export type JobCountAggregateOutputType = {
    job_id: number
    parent_id: number
    job_company: number
    job_title: number
    work_email: number
    work_number: number
    _all: number
  }


  export type JobAvgAggregateInputType = {
    job_id?: true
    parent_id?: true
  }

  export type JobSumAggregateInputType = {
    job_id?: true
    parent_id?: true
  }

  export type JobMinAggregateInputType = {
    job_id?: true
    parent_id?: true
    job_company?: true
    job_title?: true
    work_email?: true
    work_number?: true
  }

  export type JobMaxAggregateInputType = {
    job_id?: true
    parent_id?: true
    job_company?: true
    job_title?: true
    work_email?: true
    work_number?: true
  }

  export type JobCountAggregateInputType = {
    job_id?: true
    parent_id?: true
    job_company?: true
    job_title?: true
    work_email?: true
    work_number?: true
    _all?: true
  }

  export type JobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job to aggregate.
     */
    where?: jobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobOrderByWithRelationInput | jobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: jobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned jobs
    **/
    _count?: true | JobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobMaxAggregateInputType
  }

  export type GetJobAggregateType<T extends JobAggregateArgs> = {
        [P in keyof T & keyof AggregateJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob[P]>
      : GetScalarType<T[P], AggregateJob[P]>
  }




  export type jobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobWhereInput
    orderBy?: jobOrderByWithAggregationInput | jobOrderByWithAggregationInput[]
    by: JobScalarFieldEnum[] | JobScalarFieldEnum
    having?: jobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobCountAggregateInputType | true
    _avg?: JobAvgAggregateInputType
    _sum?: JobSumAggregateInputType
    _min?: JobMinAggregateInputType
    _max?: JobMaxAggregateInputType
  }

  export type JobGroupByOutputType = {
    job_id: number
    parent_id: number
    job_company: string
    job_title: string
    work_email: string | null
    work_number: string | null
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  type GetJobGroupByPayload<T extends jobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobGroupByOutputType[P]>
            : GetScalarType<T[P], JobGroupByOutputType[P]>
        }
      >
    >


  export type jobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    job_id?: boolean
    parent_id?: boolean
    job_company?: boolean
    job_title?: boolean
    work_email?: boolean
    work_number?: boolean
    parent?: boolean | parentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>



  export type jobSelectScalar = {
    job_id?: boolean
    parent_id?: boolean
    job_company?: boolean
    job_title?: boolean
    work_email?: boolean
    work_number?: boolean
  }

  export type jobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"job_id" | "parent_id" | "job_company" | "job_title" | "work_email" | "work_number", ExtArgs["result"]["job"]>
  export type jobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | parentDefaultArgs<ExtArgs>
  }

  export type $jobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job"
    objects: {
      parent: Prisma.$parentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      job_id: number
      parent_id: number
      job_company: string
      job_title: string
      work_email: string | null
      work_number: string | null
    }, ExtArgs["result"]["job"]>
    composites: {}
  }

  type jobGetPayload<S extends boolean | null | undefined | jobDefaultArgs> = $Result.GetResult<Prisma.$jobPayload, S>

  type jobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<jobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobCountAggregateInputType | true
    }

  export interface jobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job'], meta: { name: 'job' } }
    /**
     * Find zero or one Job that matches the filter.
     * @param {jobFindUniqueArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends jobFindUniqueArgs>(args: SelectSubset<T, jobFindUniqueArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {jobFindUniqueOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends jobFindUniqueOrThrowArgs>(args: SelectSubset<T, jobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobFindFirstArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends jobFindFirstArgs>(args?: SelectSubset<T, jobFindFirstArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobFindFirstOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends jobFindFirstOrThrowArgs>(args?: SelectSubset<T, jobFindFirstOrThrowArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.job.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.job.findMany({ take: 10 })
     * 
     * // Only select the `job_id`
     * const jobWithJob_idOnly = await prisma.job.findMany({ select: { job_id: true } })
     * 
     */
    findMany<T extends jobFindManyArgs>(args?: SelectSubset<T, jobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job.
     * @param {jobCreateArgs} args - Arguments to create a Job.
     * @example
     * // Create one Job
     * const Job = await prisma.job.create({
     *   data: {
     *     // ... data to create a Job
     *   }
     * })
     * 
     */
    create<T extends jobCreateArgs>(args: SelectSubset<T, jobCreateArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobs.
     * @param {jobCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends jobCreateManyArgs>(args?: SelectSubset<T, jobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Job.
     * @param {jobDeleteArgs} args - Arguments to delete one Job.
     * @example
     * // Delete one Job
     * const Job = await prisma.job.delete({
     *   where: {
     *     // ... filter to delete one Job
     *   }
     * })
     * 
     */
    delete<T extends jobDeleteArgs>(args: SelectSubset<T, jobDeleteArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job.
     * @param {jobUpdateArgs} args - Arguments to update one Job.
     * @example
     * // Update one Job
     * const job = await prisma.job.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends jobUpdateArgs>(args: SelectSubset<T, jobUpdateArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobs.
     * @param {jobDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.job.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends jobDeleteManyArgs>(args?: SelectSubset<T, jobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends jobUpdateManyArgs>(args: SelectSubset<T, jobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Job.
     * @param {jobUpsertArgs} args - Arguments to update or create a Job.
     * @example
     * // Update or create a Job
     * const job = await prisma.job.upsert({
     *   create: {
     *     // ... data to create a Job
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job we want to update
     *   }
     * })
     */
    upsert<T extends jobUpsertArgs>(args: SelectSubset<T, jobUpsertArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.job.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends jobCountArgs>(
      args?: Subset<T, jobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobAggregateArgs>(args: Subset<T, JobAggregateArgs>): Prisma.PrismaPromise<GetJobAggregateType<T>>

    /**
     * Group by Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends jobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: jobGroupByArgs['orderBy'] }
        : { orderBy?: jobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, jobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job model
   */
  readonly fields: jobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__jobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends parentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, parentDefaultArgs<ExtArgs>>): Prisma__parentClient<$Result.GetResult<Prisma.$parentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job model
   */
  interface jobFieldRefs {
    readonly job_id: FieldRef<"job", 'Int'>
    readonly parent_id: FieldRef<"job", 'Int'>
    readonly job_company: FieldRef<"job", 'String'>
    readonly job_title: FieldRef<"job", 'String'>
    readonly work_email: FieldRef<"job", 'String'>
    readonly work_number: FieldRef<"job", 'String'>
  }
    

  // Custom InputTypes
  /**
   * job findUnique
   */
  export type jobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter, which job to fetch.
     */
    where: jobWhereUniqueInput
  }

  /**
   * job findUniqueOrThrow
   */
  export type jobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter, which job to fetch.
     */
    where: jobWhereUniqueInput
  }

  /**
   * job findFirst
   */
  export type jobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter, which job to fetch.
     */
    where?: jobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobOrderByWithRelationInput | jobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobs.
     */
    cursor?: jobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * job findFirstOrThrow
   */
  export type jobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter, which job to fetch.
     */
    where?: jobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobOrderByWithRelationInput | jobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobs.
     */
    cursor?: jobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * job findMany
   */
  export type jobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where?: jobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobOrderByWithRelationInput | jobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing jobs.
     */
    cursor?: jobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * job create
   */
  export type jobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * The data needed to create a job.
     */
    data: XOR<jobCreateInput, jobUncheckedCreateInput>
  }

  /**
   * job createMany
   */
  export type jobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many jobs.
     */
    data: jobCreateManyInput | jobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job update
   */
  export type jobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * The data needed to update a job.
     */
    data: XOR<jobUpdateInput, jobUncheckedUpdateInput>
    /**
     * Choose, which job to update.
     */
    where: jobWhereUniqueInput
  }

  /**
   * job updateMany
   */
  export type jobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update jobs.
     */
    data: XOR<jobUpdateManyMutationInput, jobUncheckedUpdateManyInput>
    /**
     * Filter which jobs to update
     */
    where?: jobWhereInput
    /**
     * Limit how many jobs to update.
     */
    limit?: number
  }

  /**
   * job upsert
   */
  export type jobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * The filter to search for the job to update in case it exists.
     */
    where: jobWhereUniqueInput
    /**
     * In case the job found by the `where` argument doesn't exist, create a new job with this data.
     */
    create: XOR<jobCreateInput, jobUncheckedCreateInput>
    /**
     * In case the job was found with the provided `where` argument, update it with this data.
     */
    update: XOR<jobUpdateInput, jobUncheckedUpdateInput>
  }

  /**
   * job delete
   */
  export type jobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter which job to delete.
     */
    where: jobWhereUniqueInput
  }

  /**
   * job deleteMany
   */
  export type jobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobs to delete
     */
    where?: jobWhereInput
    /**
     * Limit how many jobs to delete.
     */
    limit?: number
  }

  /**
   * job without action
   */
  export type jobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
  }


  /**
   * Model parent
   */

  export type AggregateParent = {
    _count: ParentCountAggregateOutputType | null
    _avg: ParentAvgAggregateOutputType | null
    _sum: ParentSumAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  export type ParentAvgAggregateOutputType = {
    parent_id: number | null
  }

  export type ParentSumAggregateOutputType = {
    parent_id: number | null
  }

  export type ParentMinAggregateOutputType = {
    parent_id: number | null
    parent_fn: string | null
    parent_ln: string | null
    parent_dob: Date | null
    parent_pers_number: string | null
    parent_pers_email: string | null
  }

  export type ParentMaxAggregateOutputType = {
    parent_id: number | null
    parent_fn: string | null
    parent_ln: string | null
    parent_dob: Date | null
    parent_pers_number: string | null
    parent_pers_email: string | null
  }

  export type ParentCountAggregateOutputType = {
    parent_id: number
    parent_fn: number
    parent_ln: number
    parent_dob: number
    parent_pers_number: number
    parent_pers_email: number
    _all: number
  }


  export type ParentAvgAggregateInputType = {
    parent_id?: true
  }

  export type ParentSumAggregateInputType = {
    parent_id?: true
  }

  export type ParentMinAggregateInputType = {
    parent_id?: true
    parent_fn?: true
    parent_ln?: true
    parent_dob?: true
    parent_pers_number?: true
    parent_pers_email?: true
  }

  export type ParentMaxAggregateInputType = {
    parent_id?: true
    parent_fn?: true
    parent_ln?: true
    parent_dob?: true
    parent_pers_number?: true
    parent_pers_email?: true
  }

  export type ParentCountAggregateInputType = {
    parent_id?: true
    parent_fn?: true
    parent_ln?: true
    parent_dob?: true
    parent_pers_number?: true
    parent_pers_email?: true
    _all?: true
  }

  export type ParentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parent to aggregate.
     */
    where?: parentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parents to fetch.
     */
    orderBy?: parentOrderByWithRelationInput | parentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: parentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parents
    **/
    _count?: true | ParentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentMaxAggregateInputType
  }

  export type GetParentAggregateType<T extends ParentAggregateArgs> = {
        [P in keyof T & keyof AggregateParent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParent[P]>
      : GetScalarType<T[P], AggregateParent[P]>
  }




  export type parentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: parentWhereInput
    orderBy?: parentOrderByWithAggregationInput | parentOrderByWithAggregationInput[]
    by: ParentScalarFieldEnum[] | ParentScalarFieldEnum
    having?: parentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentCountAggregateInputType | true
    _avg?: ParentAvgAggregateInputType
    _sum?: ParentSumAggregateInputType
    _min?: ParentMinAggregateInputType
    _max?: ParentMaxAggregateInputType
  }

  export type ParentGroupByOutputType = {
    parent_id: number
    parent_fn: string
    parent_ln: string
    parent_dob: Date
    parent_pers_number: string
    parent_pers_email: string | null
    _count: ParentCountAggregateOutputType | null
    _avg: ParentAvgAggregateOutputType | null
    _sum: ParentSumAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  type GetParentGroupByPayload<T extends parentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentGroupByOutputType[P]>
            : GetScalarType<T[P], ParentGroupByOutputType[P]>
        }
      >
    >


  export type parentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    parent_id?: boolean
    parent_fn?: boolean
    parent_ln?: boolean
    parent_dob?: boolean
    parent_pers_number?: boolean
    parent_pers_email?: boolean
    job?: boolean | parent$jobArgs<ExtArgs>
    student_student_father_idToparent?: boolean | parent$student_student_father_idToparentArgs<ExtArgs>
    student_student_mother_idToparent?: boolean | parent$student_student_mother_idToparentArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>



  export type parentSelectScalar = {
    parent_id?: boolean
    parent_fn?: boolean
    parent_ln?: boolean
    parent_dob?: boolean
    parent_pers_number?: boolean
    parent_pers_email?: boolean
  }

  export type parentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"parent_id" | "parent_fn" | "parent_ln" | "parent_dob" | "parent_pers_number" | "parent_pers_email", ExtArgs["result"]["parent"]>
  export type parentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | parent$jobArgs<ExtArgs>
    student_student_father_idToparent?: boolean | parent$student_student_father_idToparentArgs<ExtArgs>
    student_student_mother_idToparent?: boolean | parent$student_student_mother_idToparentArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $parentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "parent"
    objects: {
      job: Prisma.$jobPayload<ExtArgs>[]
      student_student_father_idToparent: Prisma.$studentPayload<ExtArgs>[]
      student_student_mother_idToparent: Prisma.$studentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      parent_id: number
      parent_fn: string
      parent_ln: string
      parent_dob: Date
      parent_pers_number: string
      parent_pers_email: string | null
    }, ExtArgs["result"]["parent"]>
    composites: {}
  }

  type parentGetPayload<S extends boolean | null | undefined | parentDefaultArgs> = $Result.GetResult<Prisma.$parentPayload, S>

  type parentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<parentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParentCountAggregateInputType | true
    }

  export interface parentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['parent'], meta: { name: 'parent' } }
    /**
     * Find zero or one Parent that matches the filter.
     * @param {parentFindUniqueArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends parentFindUniqueArgs>(args: SelectSubset<T, parentFindUniqueArgs<ExtArgs>>): Prisma__parentClient<$Result.GetResult<Prisma.$parentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Parent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {parentFindUniqueOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends parentFindUniqueOrThrowArgs>(args: SelectSubset<T, parentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__parentClient<$Result.GetResult<Prisma.$parentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentFindFirstArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends parentFindFirstArgs>(args?: SelectSubset<T, parentFindFirstArgs<ExtArgs>>): Prisma__parentClient<$Result.GetResult<Prisma.$parentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentFindFirstOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends parentFindFirstOrThrowArgs>(args?: SelectSubset<T, parentFindFirstOrThrowArgs<ExtArgs>>): Prisma__parentClient<$Result.GetResult<Prisma.$parentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parents
     * const parents = await prisma.parent.findMany()
     * 
     * // Get first 10 Parents
     * const parents = await prisma.parent.findMany({ take: 10 })
     * 
     * // Only select the `parent_id`
     * const parentWithParent_idOnly = await prisma.parent.findMany({ select: { parent_id: true } })
     * 
     */
    findMany<T extends parentFindManyArgs>(args?: SelectSubset<T, parentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Parent.
     * @param {parentCreateArgs} args - Arguments to create a Parent.
     * @example
     * // Create one Parent
     * const Parent = await prisma.parent.create({
     *   data: {
     *     // ... data to create a Parent
     *   }
     * })
     * 
     */
    create<T extends parentCreateArgs>(args: SelectSubset<T, parentCreateArgs<ExtArgs>>): Prisma__parentClient<$Result.GetResult<Prisma.$parentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parents.
     * @param {parentCreateManyArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parent = await prisma.parent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends parentCreateManyArgs>(args?: SelectSubset<T, parentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Parent.
     * @param {parentDeleteArgs} args - Arguments to delete one Parent.
     * @example
     * // Delete one Parent
     * const Parent = await prisma.parent.delete({
     *   where: {
     *     // ... filter to delete one Parent
     *   }
     * })
     * 
     */
    delete<T extends parentDeleteArgs>(args: SelectSubset<T, parentDeleteArgs<ExtArgs>>): Prisma__parentClient<$Result.GetResult<Prisma.$parentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Parent.
     * @param {parentUpdateArgs} args - Arguments to update one Parent.
     * @example
     * // Update one Parent
     * const parent = await prisma.parent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends parentUpdateArgs>(args: SelectSubset<T, parentUpdateArgs<ExtArgs>>): Prisma__parentClient<$Result.GetResult<Prisma.$parentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parents.
     * @param {parentDeleteManyArgs} args - Arguments to filter Parents to delete.
     * @example
     * // Delete a few Parents
     * const { count } = await prisma.parent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends parentDeleteManyArgs>(args?: SelectSubset<T, parentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parents
     * const parent = await prisma.parent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends parentUpdateManyArgs>(args: SelectSubset<T, parentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parent.
     * @param {parentUpsertArgs} args - Arguments to update or create a Parent.
     * @example
     * // Update or create a Parent
     * const parent = await prisma.parent.upsert({
     *   create: {
     *     // ... data to create a Parent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parent we want to update
     *   }
     * })
     */
    upsert<T extends parentUpsertArgs>(args: SelectSubset<T, parentUpsertArgs<ExtArgs>>): Prisma__parentClient<$Result.GetResult<Prisma.$parentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentCountArgs} args - Arguments to filter Parents to count.
     * @example
     * // Count the number of Parents
     * const count = await prisma.parent.count({
     *   where: {
     *     // ... the filter for the Parents we want to count
     *   }
     * })
    **/
    count<T extends parentCountArgs>(
      args?: Subset<T, parentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentAggregateArgs>(args: Subset<T, ParentAggregateArgs>): Prisma.PrismaPromise<GetParentAggregateType<T>>

    /**
     * Group by Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends parentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: parentGroupByArgs['orderBy'] }
        : { orderBy?: parentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, parentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the parent model
   */
  readonly fields: parentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for parent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__parentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends parent$jobArgs<ExtArgs> = {}>(args?: Subset<T, parent$jobArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student_student_father_idToparent<T extends parent$student_student_father_idToparentArgs<ExtArgs> = {}>(args?: Subset<T, parent$student_student_father_idToparentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student_student_mother_idToparent<T extends parent$student_student_mother_idToparentArgs<ExtArgs> = {}>(args?: Subset<T, parent$student_student_mother_idToparentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the parent model
   */
  interface parentFieldRefs {
    readonly parent_id: FieldRef<"parent", 'Int'>
    readonly parent_fn: FieldRef<"parent", 'String'>
    readonly parent_ln: FieldRef<"parent", 'String'>
    readonly parent_dob: FieldRef<"parent", 'DateTime'>
    readonly parent_pers_number: FieldRef<"parent", 'String'>
    readonly parent_pers_email: FieldRef<"parent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * parent findUnique
   */
  export type parentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent
     */
    select?: parentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent
     */
    omit?: parentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentInclude<ExtArgs> | null
    /**
     * Filter, which parent to fetch.
     */
    where: parentWhereUniqueInput
  }

  /**
   * parent findUniqueOrThrow
   */
  export type parentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent
     */
    select?: parentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent
     */
    omit?: parentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentInclude<ExtArgs> | null
    /**
     * Filter, which parent to fetch.
     */
    where: parentWhereUniqueInput
  }

  /**
   * parent findFirst
   */
  export type parentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent
     */
    select?: parentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent
     */
    omit?: parentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentInclude<ExtArgs> | null
    /**
     * Filter, which parent to fetch.
     */
    where?: parentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parents to fetch.
     */
    orderBy?: parentOrderByWithRelationInput | parentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parents.
     */
    cursor?: parentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * parent findFirstOrThrow
   */
  export type parentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent
     */
    select?: parentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent
     */
    omit?: parentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentInclude<ExtArgs> | null
    /**
     * Filter, which parent to fetch.
     */
    where?: parentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parents to fetch.
     */
    orderBy?: parentOrderByWithRelationInput | parentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parents.
     */
    cursor?: parentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * parent findMany
   */
  export type parentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent
     */
    select?: parentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent
     */
    omit?: parentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentInclude<ExtArgs> | null
    /**
     * Filter, which parents to fetch.
     */
    where?: parentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parents to fetch.
     */
    orderBy?: parentOrderByWithRelationInput | parentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parents.
     */
    cursor?: parentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parents.
     */
    skip?: number
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * parent create
   */
  export type parentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent
     */
    select?: parentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent
     */
    omit?: parentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentInclude<ExtArgs> | null
    /**
     * The data needed to create a parent.
     */
    data: XOR<parentCreateInput, parentUncheckedCreateInput>
  }

  /**
   * parent createMany
   */
  export type parentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many parents.
     */
    data: parentCreateManyInput | parentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * parent update
   */
  export type parentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent
     */
    select?: parentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent
     */
    omit?: parentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentInclude<ExtArgs> | null
    /**
     * The data needed to update a parent.
     */
    data: XOR<parentUpdateInput, parentUncheckedUpdateInput>
    /**
     * Choose, which parent to update.
     */
    where: parentWhereUniqueInput
  }

  /**
   * parent updateMany
   */
  export type parentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update parents.
     */
    data: XOR<parentUpdateManyMutationInput, parentUncheckedUpdateManyInput>
    /**
     * Filter which parents to update
     */
    where?: parentWhereInput
    /**
     * Limit how many parents to update.
     */
    limit?: number
  }

  /**
   * parent upsert
   */
  export type parentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent
     */
    select?: parentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent
     */
    omit?: parentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentInclude<ExtArgs> | null
    /**
     * The filter to search for the parent to update in case it exists.
     */
    where: parentWhereUniqueInput
    /**
     * In case the parent found by the `where` argument doesn't exist, create a new parent with this data.
     */
    create: XOR<parentCreateInput, parentUncheckedCreateInput>
    /**
     * In case the parent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<parentUpdateInput, parentUncheckedUpdateInput>
  }

  /**
   * parent delete
   */
  export type parentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent
     */
    select?: parentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent
     */
    omit?: parentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentInclude<ExtArgs> | null
    /**
     * Filter which parent to delete.
     */
    where: parentWhereUniqueInput
  }

  /**
   * parent deleteMany
   */
  export type parentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parents to delete
     */
    where?: parentWhereInput
    /**
     * Limit how many parents to delete.
     */
    limit?: number
  }

  /**
   * parent.job
   */
  export type parent$jobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job
     */
    omit?: jobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobInclude<ExtArgs> | null
    where?: jobWhereInput
    orderBy?: jobOrderByWithRelationInput | jobOrderByWithRelationInput[]
    cursor?: jobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * parent.student_student_father_idToparent
   */
  export type parent$student_student_father_idToparentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    where?: studentWhereInput
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    cursor?: studentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * parent.student_student_mother_idToparent
   */
  export type parent$student_student_mother_idToparentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    where?: studentWhereInput
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    cursor?: studentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * parent without action
   */
  export type parentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent
     */
    select?: parentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent
     */
    omit?: parentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentInclude<ExtArgs> | null
  }


  /**
   * Model period
   */

  export type AggregatePeriod = {
    _count: PeriodCountAggregateOutputType | null
    _avg: PeriodAvgAggregateOutputType | null
    _sum: PeriodSumAggregateOutputType | null
    _min: PeriodMinAggregateOutputType | null
    _max: PeriodMaxAggregateOutputType | null
  }

  export type PeriodAvgAggregateOutputType = {
    period: number | null
  }

  export type PeriodSumAggregateOutputType = {
    period: number | null
  }

  export type PeriodMinAggregateOutputType = {
    period: number | null
    period_status: string | null
  }

  export type PeriodMaxAggregateOutputType = {
    period: number | null
    period_status: string | null
  }

  export type PeriodCountAggregateOutputType = {
    period: number
    period_status: number
    _all: number
  }


  export type PeriodAvgAggregateInputType = {
    period?: true
  }

  export type PeriodSumAggregateInputType = {
    period?: true
  }

  export type PeriodMinAggregateInputType = {
    period?: true
    period_status?: true
  }

  export type PeriodMaxAggregateInputType = {
    period?: true
    period_status?: true
  }

  export type PeriodCountAggregateInputType = {
    period?: true
    period_status?: true
    _all?: true
  }

  export type PeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which period to aggregate.
     */
    where?: periodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of periods to fetch.
     */
    orderBy?: periodOrderByWithRelationInput | periodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: periodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` periods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` periods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned periods
    **/
    _count?: true | PeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PeriodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PeriodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PeriodMaxAggregateInputType
  }

  export type GetPeriodAggregateType<T extends PeriodAggregateArgs> = {
        [P in keyof T & keyof AggregatePeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePeriod[P]>
      : GetScalarType<T[P], AggregatePeriod[P]>
  }




  export type periodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: periodWhereInput
    orderBy?: periodOrderByWithAggregationInput | periodOrderByWithAggregationInput[]
    by: PeriodScalarFieldEnum[] | PeriodScalarFieldEnum
    having?: periodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PeriodCountAggregateInputType | true
    _avg?: PeriodAvgAggregateInputType
    _sum?: PeriodSumAggregateInputType
    _min?: PeriodMinAggregateInputType
    _max?: PeriodMaxAggregateInputType
  }

  export type PeriodGroupByOutputType = {
    period: number
    period_status: string
    _count: PeriodCountAggregateOutputType | null
    _avg: PeriodAvgAggregateOutputType | null
    _sum: PeriodSumAggregateOutputType | null
    _min: PeriodMinAggregateOutputType | null
    _max: PeriodMaxAggregateOutputType | null
  }

  type GetPeriodGroupByPayload<T extends periodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PeriodGroupByOutputType[P]>
            : GetScalarType<T[P], PeriodGroupByOutputType[P]>
        }
      >
    >


  export type periodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    period?: boolean
    period_status?: boolean
    active_class_active_class_periodToperiod?: boolean | period$active_class_active_class_periodToperiodArgs<ExtArgs>
    _count?: boolean | PeriodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["period"]>



  export type periodSelectScalar = {
    period?: boolean
    period_status?: boolean
  }

  export type periodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"period" | "period_status", ExtArgs["result"]["period"]>
  export type periodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    active_class_active_class_periodToperiod?: boolean | period$active_class_active_class_periodToperiodArgs<ExtArgs>
    _count?: boolean | PeriodCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $periodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "period"
    objects: {
      active_class_active_class_periodToperiod: Prisma.$active_classPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      period: number
      period_status: string
    }, ExtArgs["result"]["period"]>
    composites: {}
  }

  type periodGetPayload<S extends boolean | null | undefined | periodDefaultArgs> = $Result.GetResult<Prisma.$periodPayload, S>

  type periodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<periodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PeriodCountAggregateInputType | true
    }

  export interface periodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['period'], meta: { name: 'period' } }
    /**
     * Find zero or one Period that matches the filter.
     * @param {periodFindUniqueArgs} args - Arguments to find a Period
     * @example
     * // Get one Period
     * const period = await prisma.period.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends periodFindUniqueArgs>(args: SelectSubset<T, periodFindUniqueArgs<ExtArgs>>): Prisma__periodClient<$Result.GetResult<Prisma.$periodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Period that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {periodFindUniqueOrThrowArgs} args - Arguments to find a Period
     * @example
     * // Get one Period
     * const period = await prisma.period.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends periodFindUniqueOrThrowArgs>(args: SelectSubset<T, periodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__periodClient<$Result.GetResult<Prisma.$periodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Period that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {periodFindFirstArgs} args - Arguments to find a Period
     * @example
     * // Get one Period
     * const period = await prisma.period.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends periodFindFirstArgs>(args?: SelectSubset<T, periodFindFirstArgs<ExtArgs>>): Prisma__periodClient<$Result.GetResult<Prisma.$periodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Period that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {periodFindFirstOrThrowArgs} args - Arguments to find a Period
     * @example
     * // Get one Period
     * const period = await prisma.period.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends periodFindFirstOrThrowArgs>(args?: SelectSubset<T, periodFindFirstOrThrowArgs<ExtArgs>>): Prisma__periodClient<$Result.GetResult<Prisma.$periodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Periods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {periodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Periods
     * const periods = await prisma.period.findMany()
     * 
     * // Get first 10 Periods
     * const periods = await prisma.period.findMany({ take: 10 })
     * 
     * // Only select the `period`
     * const periodWithPeriodOnly = await prisma.period.findMany({ select: { period: true } })
     * 
     */
    findMany<T extends periodFindManyArgs>(args?: SelectSubset<T, periodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$periodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Period.
     * @param {periodCreateArgs} args - Arguments to create a Period.
     * @example
     * // Create one Period
     * const Period = await prisma.period.create({
     *   data: {
     *     // ... data to create a Period
     *   }
     * })
     * 
     */
    create<T extends periodCreateArgs>(args: SelectSubset<T, periodCreateArgs<ExtArgs>>): Prisma__periodClient<$Result.GetResult<Prisma.$periodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Periods.
     * @param {periodCreateManyArgs} args - Arguments to create many Periods.
     * @example
     * // Create many Periods
     * const period = await prisma.period.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends periodCreateManyArgs>(args?: SelectSubset<T, periodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Period.
     * @param {periodDeleteArgs} args - Arguments to delete one Period.
     * @example
     * // Delete one Period
     * const Period = await prisma.period.delete({
     *   where: {
     *     // ... filter to delete one Period
     *   }
     * })
     * 
     */
    delete<T extends periodDeleteArgs>(args: SelectSubset<T, periodDeleteArgs<ExtArgs>>): Prisma__periodClient<$Result.GetResult<Prisma.$periodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Period.
     * @param {periodUpdateArgs} args - Arguments to update one Period.
     * @example
     * // Update one Period
     * const period = await prisma.period.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends periodUpdateArgs>(args: SelectSubset<T, periodUpdateArgs<ExtArgs>>): Prisma__periodClient<$Result.GetResult<Prisma.$periodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Periods.
     * @param {periodDeleteManyArgs} args - Arguments to filter Periods to delete.
     * @example
     * // Delete a few Periods
     * const { count } = await prisma.period.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends periodDeleteManyArgs>(args?: SelectSubset<T, periodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Periods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {periodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Periods
     * const period = await prisma.period.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends periodUpdateManyArgs>(args: SelectSubset<T, periodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Period.
     * @param {periodUpsertArgs} args - Arguments to update or create a Period.
     * @example
     * // Update or create a Period
     * const period = await prisma.period.upsert({
     *   create: {
     *     // ... data to create a Period
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Period we want to update
     *   }
     * })
     */
    upsert<T extends periodUpsertArgs>(args: SelectSubset<T, periodUpsertArgs<ExtArgs>>): Prisma__periodClient<$Result.GetResult<Prisma.$periodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Periods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {periodCountArgs} args - Arguments to filter Periods to count.
     * @example
     * // Count the number of Periods
     * const count = await prisma.period.count({
     *   where: {
     *     // ... the filter for the Periods we want to count
     *   }
     * })
    **/
    count<T extends periodCountArgs>(
      args?: Subset<T, periodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Period.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PeriodAggregateArgs>(args: Subset<T, PeriodAggregateArgs>): Prisma.PrismaPromise<GetPeriodAggregateType<T>>

    /**
     * Group by Period.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {periodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends periodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: periodGroupByArgs['orderBy'] }
        : { orderBy?: periodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, periodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the period model
   */
  readonly fields: periodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for period.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__periodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    active_class_active_class_periodToperiod<T extends period$active_class_active_class_periodToperiodArgs<ExtArgs> = {}>(args?: Subset<T, period$active_class_active_class_periodToperiodArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$active_classPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the period model
   */
  interface periodFieldRefs {
    readonly period: FieldRef<"period", 'Int'>
    readonly period_status: FieldRef<"period", 'String'>
  }
    

  // Custom InputTypes
  /**
   * period findUnique
   */
  export type periodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the period
     */
    select?: periodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the period
     */
    omit?: periodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: periodInclude<ExtArgs> | null
    /**
     * Filter, which period to fetch.
     */
    where: periodWhereUniqueInput
  }

  /**
   * period findUniqueOrThrow
   */
  export type periodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the period
     */
    select?: periodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the period
     */
    omit?: periodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: periodInclude<ExtArgs> | null
    /**
     * Filter, which period to fetch.
     */
    where: periodWhereUniqueInput
  }

  /**
   * period findFirst
   */
  export type periodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the period
     */
    select?: periodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the period
     */
    omit?: periodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: periodInclude<ExtArgs> | null
    /**
     * Filter, which period to fetch.
     */
    where?: periodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of periods to fetch.
     */
    orderBy?: periodOrderByWithRelationInput | periodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for periods.
     */
    cursor?: periodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` periods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` periods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of periods.
     */
    distinct?: PeriodScalarFieldEnum | PeriodScalarFieldEnum[]
  }

  /**
   * period findFirstOrThrow
   */
  export type periodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the period
     */
    select?: periodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the period
     */
    omit?: periodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: periodInclude<ExtArgs> | null
    /**
     * Filter, which period to fetch.
     */
    where?: periodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of periods to fetch.
     */
    orderBy?: periodOrderByWithRelationInput | periodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for periods.
     */
    cursor?: periodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` periods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` periods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of periods.
     */
    distinct?: PeriodScalarFieldEnum | PeriodScalarFieldEnum[]
  }

  /**
   * period findMany
   */
  export type periodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the period
     */
    select?: periodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the period
     */
    omit?: periodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: periodInclude<ExtArgs> | null
    /**
     * Filter, which periods to fetch.
     */
    where?: periodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of periods to fetch.
     */
    orderBy?: periodOrderByWithRelationInput | periodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing periods.
     */
    cursor?: periodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` periods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` periods.
     */
    skip?: number
    distinct?: PeriodScalarFieldEnum | PeriodScalarFieldEnum[]
  }

  /**
   * period create
   */
  export type periodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the period
     */
    select?: periodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the period
     */
    omit?: periodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: periodInclude<ExtArgs> | null
    /**
     * The data needed to create a period.
     */
    data: XOR<periodCreateInput, periodUncheckedCreateInput>
  }

  /**
   * period createMany
   */
  export type periodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many periods.
     */
    data: periodCreateManyInput | periodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * period update
   */
  export type periodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the period
     */
    select?: periodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the period
     */
    omit?: periodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: periodInclude<ExtArgs> | null
    /**
     * The data needed to update a period.
     */
    data: XOR<periodUpdateInput, periodUncheckedUpdateInput>
    /**
     * Choose, which period to update.
     */
    where: periodWhereUniqueInput
  }

  /**
   * period updateMany
   */
  export type periodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update periods.
     */
    data: XOR<periodUpdateManyMutationInput, periodUncheckedUpdateManyInput>
    /**
     * Filter which periods to update
     */
    where?: periodWhereInput
    /**
     * Limit how many periods to update.
     */
    limit?: number
  }

  /**
   * period upsert
   */
  export type periodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the period
     */
    select?: periodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the period
     */
    omit?: periodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: periodInclude<ExtArgs> | null
    /**
     * The filter to search for the period to update in case it exists.
     */
    where: periodWhereUniqueInput
    /**
     * In case the period found by the `where` argument doesn't exist, create a new period with this data.
     */
    create: XOR<periodCreateInput, periodUncheckedCreateInput>
    /**
     * In case the period was found with the provided `where` argument, update it with this data.
     */
    update: XOR<periodUpdateInput, periodUncheckedUpdateInput>
  }

  /**
   * period delete
   */
  export type periodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the period
     */
    select?: periodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the period
     */
    omit?: periodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: periodInclude<ExtArgs> | null
    /**
     * Filter which period to delete.
     */
    where: periodWhereUniqueInput
  }

  /**
   * period deleteMany
   */
  export type periodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which periods to delete
     */
    where?: periodWhereInput
    /**
     * Limit how many periods to delete.
     */
    limit?: number
  }

  /**
   * period.active_class_active_class_periodToperiod
   */
  export type period$active_class_active_class_periodToperiodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_class
     */
    select?: active_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_class
     */
    omit?: active_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_classInclude<ExtArgs> | null
    where?: active_classWhereInput
    orderBy?: active_classOrderByWithRelationInput | active_classOrderByWithRelationInput[]
    cursor?: active_classWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Active_classScalarFieldEnum | Active_classScalarFieldEnum[]
  }

  /**
   * period without action
   */
  export type periodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the period
     */
    select?: periodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the period
     */
    omit?: periodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: periodInclude<ExtArgs> | null
  }


  /**
   * Model roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    role_id: number | null
  }

  export type RolesSumAggregateOutputType = {
    role_id: number | null
  }

  export type RolesMinAggregateOutputType = {
    role_id: number | null
    role_name: string | null
    role_description: string | null
  }

  export type RolesMaxAggregateOutputType = {
    role_id: number | null
    role_name: string | null
    role_description: string | null
  }

  export type RolesCountAggregateOutputType = {
    role_id: number
    role_name: number
    role_description: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    role_id?: true
  }

  export type RolesSumAggregateInputType = {
    role_id?: true
  }

  export type RolesMinAggregateInputType = {
    role_id?: true
    role_name?: true
    role_description?: true
  }

  export type RolesMaxAggregateInputType = {
    role_id?: true
    role_name?: true
    role_description?: true
  }

  export type RolesCountAggregateInputType = {
    role_id?: true
    role_name?: true
    role_description?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to aggregate.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesWhereInput
    orderBy?: rolesOrderByWithAggregationInput | rolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    role_id: number
    role_name: string
    role_description: string | null
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    role_name?: boolean
    role_description?: boolean
    employee_role?: boolean | roles$employee_roleArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>



  export type rolesSelectScalar = {
    role_id?: boolean
    role_name?: boolean
    role_description?: boolean
  }

  export type rolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"role_id" | "role_name" | "role_description", ExtArgs["result"]["roles"]>
  export type rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee_role?: boolean | roles$employee_roleArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roles"
    objects: {
      employee_role: Prisma.$employee_rolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      role_id: number
      role_name: string
      role_description: string | null
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type rolesGetPayload<S extends boolean | null | undefined | rolesDefaultArgs> = $Result.GetResult<Prisma.$rolesPayload, S>

  type rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roles'], meta: { name: 'roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {rolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rolesFindUniqueArgs>(args: SelectSubset<T, rolesFindUniqueArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rolesFindFirstArgs>(args?: SelectSubset<T, rolesFindFirstArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `role_id`
     * const rolesWithRole_idOnly = await prisma.roles.findMany({ select: { role_id: true } })
     * 
     */
    findMany<T extends rolesFindManyArgs>(args?: SelectSubset<T, rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Roles.
     * @param {rolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends rolesCreateArgs>(args: SelectSubset<T, rolesCreateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {rolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rolesCreateManyArgs>(args?: SelectSubset<T, rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roles.
     * @param {rolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends rolesDeleteArgs>(args: SelectSubset<T, rolesDeleteArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Roles.
     * @param {rolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rolesUpdateArgs>(args: SelectSubset<T, rolesUpdateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {rolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rolesDeleteManyArgs>(args?: SelectSubset<T, rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rolesUpdateManyArgs>(args: SelectSubset<T, rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {rolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends rolesUpsertArgs>(args: SelectSubset<T, rolesUpsertArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends rolesCountArgs>(
      args?: Subset<T, rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolesGroupByArgs['orderBy'] }
        : { orderBy?: rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roles model
   */
  readonly fields: rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee_role<T extends roles$employee_roleArgs<ExtArgs> = {}>(args?: Subset<T, roles$employee_roleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employee_rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the roles model
   */
  interface rolesFieldRefs {
    readonly role_id: FieldRef<"roles", 'Int'>
    readonly role_name: FieldRef<"roles", 'String'>
    readonly role_description: FieldRef<"roles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * roles findUnique
   */
  export type rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findUniqueOrThrow
   */
  export type rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findFirst
   */
  export type rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findFirstOrThrow
   */
  export type rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findMany
   */
  export type rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles create
   */
  export type rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a roles.
     */
    data: XOR<rolesCreateInput, rolesUncheckedCreateInput>
  }

  /**
   * roles createMany
   */
  export type rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles update
   */
  export type rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a roles.
     */
    data: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
    /**
     * Choose, which roles to update.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles updateMany
   */
  export type rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * roles upsert
   */
  export type rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the roles to update in case it exists.
     */
    where: rolesWhereUniqueInput
    /**
     * In case the roles found by the `where` argument doesn't exist, create a new roles with this data.
     */
    create: XOR<rolesCreateInput, rolesUncheckedCreateInput>
    /**
     * In case the roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
  }

  /**
   * roles delete
   */
  export type rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter which roles to delete.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles deleteMany
   */
  export type rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: rolesWhereInput
    /**
     * Limit how many roles to delete.
     */
    limit?: number
  }

  /**
   * roles.employee_role
   */
  export type roles$employee_roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee_role
     */
    select?: employee_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee_role
     */
    omit?: employee_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employee_roleInclude<ExtArgs> | null
    where?: employee_roleWhereInput
    orderBy?: employee_roleOrderByWithRelationInput | employee_roleOrderByWithRelationInput[]
    cursor?: employee_roleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Employee_roleScalarFieldEnum | Employee_roleScalarFieldEnum[]
  }

  /**
   * roles without action
   */
  export type rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
  }


  /**
   * Model school_email
   */

  export type AggregateSchool_email = {
    _count: School_emailCountAggregateOutputType | null
    _avg: School_emailAvgAggregateOutputType | null
    _sum: School_emailSumAggregateOutputType | null
    _min: School_emailMinAggregateOutputType | null
    _max: School_emailMaxAggregateOutputType | null
  }

  export type School_emailAvgAggregateOutputType = {
    school_num_id: number | null
    school_reg: number | null
  }

  export type School_emailSumAggregateOutputType = {
    school_num_id: number | null
    school_reg: number | null
  }

  export type School_emailMinAggregateOutputType = {
    school_num_id: number | null
    school_reg: number | null
    school_email: string | null
    school_email_label: string | null
  }

  export type School_emailMaxAggregateOutputType = {
    school_num_id: number | null
    school_reg: number | null
    school_email: string | null
    school_email_label: string | null
  }

  export type School_emailCountAggregateOutputType = {
    school_num_id: number
    school_reg: number
    school_email: number
    school_email_label: number
    _all: number
  }


  export type School_emailAvgAggregateInputType = {
    school_num_id?: true
    school_reg?: true
  }

  export type School_emailSumAggregateInputType = {
    school_num_id?: true
    school_reg?: true
  }

  export type School_emailMinAggregateInputType = {
    school_num_id?: true
    school_reg?: true
    school_email?: true
    school_email_label?: true
  }

  export type School_emailMaxAggregateInputType = {
    school_num_id?: true
    school_reg?: true
    school_email?: true
    school_email_label?: true
  }

  export type School_emailCountAggregateInputType = {
    school_num_id?: true
    school_reg?: true
    school_email?: true
    school_email_label?: true
    _all?: true
  }

  export type School_emailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which school_email to aggregate.
     */
    where?: school_emailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of school_emails to fetch.
     */
    orderBy?: school_emailOrderByWithRelationInput | school_emailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: school_emailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` school_emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` school_emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned school_emails
    **/
    _count?: true | School_emailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: School_emailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: School_emailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: School_emailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: School_emailMaxAggregateInputType
  }

  export type GetSchool_emailAggregateType<T extends School_emailAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool_email]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool_email[P]>
      : GetScalarType<T[P], AggregateSchool_email[P]>
  }




  export type school_emailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: school_emailWhereInput
    orderBy?: school_emailOrderByWithAggregationInput | school_emailOrderByWithAggregationInput[]
    by: School_emailScalarFieldEnum[] | School_emailScalarFieldEnum
    having?: school_emailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: School_emailCountAggregateInputType | true
    _avg?: School_emailAvgAggregateInputType
    _sum?: School_emailSumAggregateInputType
    _min?: School_emailMinAggregateInputType
    _max?: School_emailMaxAggregateInputType
  }

  export type School_emailGroupByOutputType = {
    school_num_id: number
    school_reg: number
    school_email: string
    school_email_label: string
    _count: School_emailCountAggregateOutputType | null
    _avg: School_emailAvgAggregateOutputType | null
    _sum: School_emailSumAggregateOutputType | null
    _min: School_emailMinAggregateOutputType | null
    _max: School_emailMaxAggregateOutputType | null
  }

  type GetSchool_emailGroupByPayload<T extends school_emailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<School_emailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof School_emailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], School_emailGroupByOutputType[P]>
            : GetScalarType<T[P], School_emailGroupByOutputType[P]>
        }
      >
    >


  export type school_emailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    school_num_id?: boolean
    school_reg?: boolean
    school_email?: boolean
    school_email_label?: boolean
    school_info?: boolean | school_infoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school_email"]>



  export type school_emailSelectScalar = {
    school_num_id?: boolean
    school_reg?: boolean
    school_email?: boolean
    school_email_label?: boolean
  }

  export type school_emailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"school_num_id" | "school_reg" | "school_email" | "school_email_label", ExtArgs["result"]["school_email"]>
  export type school_emailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school_info?: boolean | school_infoDefaultArgs<ExtArgs>
  }

  export type $school_emailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "school_email"
    objects: {
      school_info: Prisma.$school_infoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      school_num_id: number
      school_reg: number
      school_email: string
      school_email_label: string
    }, ExtArgs["result"]["school_email"]>
    composites: {}
  }

  type school_emailGetPayload<S extends boolean | null | undefined | school_emailDefaultArgs> = $Result.GetResult<Prisma.$school_emailPayload, S>

  type school_emailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<school_emailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: School_emailCountAggregateInputType | true
    }

  export interface school_emailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['school_email'], meta: { name: 'school_email' } }
    /**
     * Find zero or one School_email that matches the filter.
     * @param {school_emailFindUniqueArgs} args - Arguments to find a School_email
     * @example
     * // Get one School_email
     * const school_email = await prisma.school_email.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends school_emailFindUniqueArgs>(args: SelectSubset<T, school_emailFindUniqueArgs<ExtArgs>>): Prisma__school_emailClient<$Result.GetResult<Prisma.$school_emailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one School_email that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {school_emailFindUniqueOrThrowArgs} args - Arguments to find a School_email
     * @example
     * // Get one School_email
     * const school_email = await prisma.school_email.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends school_emailFindUniqueOrThrowArgs>(args: SelectSubset<T, school_emailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__school_emailClient<$Result.GetResult<Prisma.$school_emailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School_email that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_emailFindFirstArgs} args - Arguments to find a School_email
     * @example
     * // Get one School_email
     * const school_email = await prisma.school_email.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends school_emailFindFirstArgs>(args?: SelectSubset<T, school_emailFindFirstArgs<ExtArgs>>): Prisma__school_emailClient<$Result.GetResult<Prisma.$school_emailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School_email that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_emailFindFirstOrThrowArgs} args - Arguments to find a School_email
     * @example
     * // Get one School_email
     * const school_email = await prisma.school_email.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends school_emailFindFirstOrThrowArgs>(args?: SelectSubset<T, school_emailFindFirstOrThrowArgs<ExtArgs>>): Prisma__school_emailClient<$Result.GetResult<Prisma.$school_emailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more School_emails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_emailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all School_emails
     * const school_emails = await prisma.school_email.findMany()
     * 
     * // Get first 10 School_emails
     * const school_emails = await prisma.school_email.findMany({ take: 10 })
     * 
     * // Only select the `school_num_id`
     * const school_emailWithSchool_num_idOnly = await prisma.school_email.findMany({ select: { school_num_id: true } })
     * 
     */
    findMany<T extends school_emailFindManyArgs>(args?: SelectSubset<T, school_emailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$school_emailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a School_email.
     * @param {school_emailCreateArgs} args - Arguments to create a School_email.
     * @example
     * // Create one School_email
     * const School_email = await prisma.school_email.create({
     *   data: {
     *     // ... data to create a School_email
     *   }
     * })
     * 
     */
    create<T extends school_emailCreateArgs>(args: SelectSubset<T, school_emailCreateArgs<ExtArgs>>): Prisma__school_emailClient<$Result.GetResult<Prisma.$school_emailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many School_emails.
     * @param {school_emailCreateManyArgs} args - Arguments to create many School_emails.
     * @example
     * // Create many School_emails
     * const school_email = await prisma.school_email.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends school_emailCreateManyArgs>(args?: SelectSubset<T, school_emailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a School_email.
     * @param {school_emailDeleteArgs} args - Arguments to delete one School_email.
     * @example
     * // Delete one School_email
     * const School_email = await prisma.school_email.delete({
     *   where: {
     *     // ... filter to delete one School_email
     *   }
     * })
     * 
     */
    delete<T extends school_emailDeleteArgs>(args: SelectSubset<T, school_emailDeleteArgs<ExtArgs>>): Prisma__school_emailClient<$Result.GetResult<Prisma.$school_emailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one School_email.
     * @param {school_emailUpdateArgs} args - Arguments to update one School_email.
     * @example
     * // Update one School_email
     * const school_email = await prisma.school_email.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends school_emailUpdateArgs>(args: SelectSubset<T, school_emailUpdateArgs<ExtArgs>>): Prisma__school_emailClient<$Result.GetResult<Prisma.$school_emailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more School_emails.
     * @param {school_emailDeleteManyArgs} args - Arguments to filter School_emails to delete.
     * @example
     * // Delete a few School_emails
     * const { count } = await prisma.school_email.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends school_emailDeleteManyArgs>(args?: SelectSubset<T, school_emailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more School_emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_emailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many School_emails
     * const school_email = await prisma.school_email.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends school_emailUpdateManyArgs>(args: SelectSubset<T, school_emailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one School_email.
     * @param {school_emailUpsertArgs} args - Arguments to update or create a School_email.
     * @example
     * // Update or create a School_email
     * const school_email = await prisma.school_email.upsert({
     *   create: {
     *     // ... data to create a School_email
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School_email we want to update
     *   }
     * })
     */
    upsert<T extends school_emailUpsertArgs>(args: SelectSubset<T, school_emailUpsertArgs<ExtArgs>>): Prisma__school_emailClient<$Result.GetResult<Prisma.$school_emailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of School_emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_emailCountArgs} args - Arguments to filter School_emails to count.
     * @example
     * // Count the number of School_emails
     * const count = await prisma.school_email.count({
     *   where: {
     *     // ... the filter for the School_emails we want to count
     *   }
     * })
    **/
    count<T extends school_emailCountArgs>(
      args?: Subset<T, school_emailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], School_emailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School_email.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {School_emailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends School_emailAggregateArgs>(args: Subset<T, School_emailAggregateArgs>): Prisma.PrismaPromise<GetSchool_emailAggregateType<T>>

    /**
     * Group by School_email.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_emailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends school_emailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: school_emailGroupByArgs['orderBy'] }
        : { orderBy?: school_emailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, school_emailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchool_emailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the school_email model
   */
  readonly fields: school_emailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for school_email.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__school_emailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school_info<T extends school_infoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, school_infoDefaultArgs<ExtArgs>>): Prisma__school_infoClient<$Result.GetResult<Prisma.$school_infoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the school_email model
   */
  interface school_emailFieldRefs {
    readonly school_num_id: FieldRef<"school_email", 'Int'>
    readonly school_reg: FieldRef<"school_email", 'Int'>
    readonly school_email: FieldRef<"school_email", 'String'>
    readonly school_email_label: FieldRef<"school_email", 'String'>
  }
    

  // Custom InputTypes
  /**
   * school_email findUnique
   */
  export type school_emailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_email
     */
    select?: school_emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_email
     */
    omit?: school_emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_emailInclude<ExtArgs> | null
    /**
     * Filter, which school_email to fetch.
     */
    where: school_emailWhereUniqueInput
  }

  /**
   * school_email findUniqueOrThrow
   */
  export type school_emailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_email
     */
    select?: school_emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_email
     */
    omit?: school_emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_emailInclude<ExtArgs> | null
    /**
     * Filter, which school_email to fetch.
     */
    where: school_emailWhereUniqueInput
  }

  /**
   * school_email findFirst
   */
  export type school_emailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_email
     */
    select?: school_emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_email
     */
    omit?: school_emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_emailInclude<ExtArgs> | null
    /**
     * Filter, which school_email to fetch.
     */
    where?: school_emailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of school_emails to fetch.
     */
    orderBy?: school_emailOrderByWithRelationInput | school_emailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for school_emails.
     */
    cursor?: school_emailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` school_emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` school_emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of school_emails.
     */
    distinct?: School_emailScalarFieldEnum | School_emailScalarFieldEnum[]
  }

  /**
   * school_email findFirstOrThrow
   */
  export type school_emailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_email
     */
    select?: school_emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_email
     */
    omit?: school_emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_emailInclude<ExtArgs> | null
    /**
     * Filter, which school_email to fetch.
     */
    where?: school_emailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of school_emails to fetch.
     */
    orderBy?: school_emailOrderByWithRelationInput | school_emailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for school_emails.
     */
    cursor?: school_emailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` school_emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` school_emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of school_emails.
     */
    distinct?: School_emailScalarFieldEnum | School_emailScalarFieldEnum[]
  }

  /**
   * school_email findMany
   */
  export type school_emailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_email
     */
    select?: school_emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_email
     */
    omit?: school_emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_emailInclude<ExtArgs> | null
    /**
     * Filter, which school_emails to fetch.
     */
    where?: school_emailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of school_emails to fetch.
     */
    orderBy?: school_emailOrderByWithRelationInput | school_emailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing school_emails.
     */
    cursor?: school_emailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` school_emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` school_emails.
     */
    skip?: number
    distinct?: School_emailScalarFieldEnum | School_emailScalarFieldEnum[]
  }

  /**
   * school_email create
   */
  export type school_emailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_email
     */
    select?: school_emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_email
     */
    omit?: school_emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_emailInclude<ExtArgs> | null
    /**
     * The data needed to create a school_email.
     */
    data: XOR<school_emailCreateInput, school_emailUncheckedCreateInput>
  }

  /**
   * school_email createMany
   */
  export type school_emailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many school_emails.
     */
    data: school_emailCreateManyInput | school_emailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * school_email update
   */
  export type school_emailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_email
     */
    select?: school_emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_email
     */
    omit?: school_emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_emailInclude<ExtArgs> | null
    /**
     * The data needed to update a school_email.
     */
    data: XOR<school_emailUpdateInput, school_emailUncheckedUpdateInput>
    /**
     * Choose, which school_email to update.
     */
    where: school_emailWhereUniqueInput
  }

  /**
   * school_email updateMany
   */
  export type school_emailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update school_emails.
     */
    data: XOR<school_emailUpdateManyMutationInput, school_emailUncheckedUpdateManyInput>
    /**
     * Filter which school_emails to update
     */
    where?: school_emailWhereInput
    /**
     * Limit how many school_emails to update.
     */
    limit?: number
  }

  /**
   * school_email upsert
   */
  export type school_emailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_email
     */
    select?: school_emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_email
     */
    omit?: school_emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_emailInclude<ExtArgs> | null
    /**
     * The filter to search for the school_email to update in case it exists.
     */
    where: school_emailWhereUniqueInput
    /**
     * In case the school_email found by the `where` argument doesn't exist, create a new school_email with this data.
     */
    create: XOR<school_emailCreateInput, school_emailUncheckedCreateInput>
    /**
     * In case the school_email was found with the provided `where` argument, update it with this data.
     */
    update: XOR<school_emailUpdateInput, school_emailUncheckedUpdateInput>
  }

  /**
   * school_email delete
   */
  export type school_emailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_email
     */
    select?: school_emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_email
     */
    omit?: school_emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_emailInclude<ExtArgs> | null
    /**
     * Filter which school_email to delete.
     */
    where: school_emailWhereUniqueInput
  }

  /**
   * school_email deleteMany
   */
  export type school_emailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which school_emails to delete
     */
    where?: school_emailWhereInput
    /**
     * Limit how many school_emails to delete.
     */
    limit?: number
  }

  /**
   * school_email without action
   */
  export type school_emailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_email
     */
    select?: school_emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_email
     */
    omit?: school_emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_emailInclude<ExtArgs> | null
  }


  /**
   * Model school_info
   */

  export type AggregateSchool_info = {
    _count: School_infoCountAggregateOutputType | null
    _avg: School_infoAvgAggregateOutputType | null
    _sum: School_infoSumAggregateOutputType | null
    _min: School_infoMinAggregateOutputType | null
    _max: School_infoMaxAggregateOutputType | null
  }

  export type School_infoAvgAggregateOutputType = {
    school_reg: number | null
    school_lat: number | null
    school_long: number | null
  }

  export type School_infoSumAggregateOutputType = {
    school_reg: number | null
    school_lat: number | null
    school_long: number | null
  }

  export type School_infoMinAggregateOutputType = {
    school_reg: number | null
    school_name: string | null
    school_address: string | null
    school_lat: number | null
    school_long: number | null
    school_princ: string | null
  }

  export type School_infoMaxAggregateOutputType = {
    school_reg: number | null
    school_name: string | null
    school_address: string | null
    school_lat: number | null
    school_long: number | null
    school_princ: string | null
  }

  export type School_infoCountAggregateOutputType = {
    school_reg: number
    school_name: number
    school_address: number
    school_lat: number
    school_long: number
    school_princ: number
    _all: number
  }


  export type School_infoAvgAggregateInputType = {
    school_reg?: true
    school_lat?: true
    school_long?: true
  }

  export type School_infoSumAggregateInputType = {
    school_reg?: true
    school_lat?: true
    school_long?: true
  }

  export type School_infoMinAggregateInputType = {
    school_reg?: true
    school_name?: true
    school_address?: true
    school_lat?: true
    school_long?: true
    school_princ?: true
  }

  export type School_infoMaxAggregateInputType = {
    school_reg?: true
    school_name?: true
    school_address?: true
    school_lat?: true
    school_long?: true
    school_princ?: true
  }

  export type School_infoCountAggregateInputType = {
    school_reg?: true
    school_name?: true
    school_address?: true
    school_lat?: true
    school_long?: true
    school_princ?: true
    _all?: true
  }

  export type School_infoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which school_info to aggregate.
     */
    where?: school_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of school_infos to fetch.
     */
    orderBy?: school_infoOrderByWithRelationInput | school_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: school_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` school_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` school_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned school_infos
    **/
    _count?: true | School_infoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: School_infoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: School_infoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: School_infoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: School_infoMaxAggregateInputType
  }

  export type GetSchool_infoAggregateType<T extends School_infoAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool_info]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool_info[P]>
      : GetScalarType<T[P], AggregateSchool_info[P]>
  }




  export type school_infoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: school_infoWhereInput
    orderBy?: school_infoOrderByWithAggregationInput | school_infoOrderByWithAggregationInput[]
    by: School_infoScalarFieldEnum[] | School_infoScalarFieldEnum
    having?: school_infoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: School_infoCountAggregateInputType | true
    _avg?: School_infoAvgAggregateInputType
    _sum?: School_infoSumAggregateInputType
    _min?: School_infoMinAggregateInputType
    _max?: School_infoMaxAggregateInputType
  }

  export type School_infoGroupByOutputType = {
    school_reg: number
    school_name: string
    school_address: string
    school_lat: number
    school_long: number
    school_princ: string
    _count: School_infoCountAggregateOutputType | null
    _avg: School_infoAvgAggregateOutputType | null
    _sum: School_infoSumAggregateOutputType | null
    _min: School_infoMinAggregateOutputType | null
    _max: School_infoMaxAggregateOutputType | null
  }

  type GetSchool_infoGroupByPayload<T extends school_infoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<School_infoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof School_infoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], School_infoGroupByOutputType[P]>
            : GetScalarType<T[P], School_infoGroupByOutputType[P]>
        }
      >
    >


  export type school_infoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    school_reg?: boolean
    school_name?: boolean
    school_address?: boolean
    school_lat?: boolean
    school_long?: boolean
    school_princ?: boolean
    school_email?: boolean | school_info$school_emailArgs<ExtArgs>
    school_num?: boolean | school_info$school_numArgs<ExtArgs>
    _count?: boolean | School_infoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school_info"]>



  export type school_infoSelectScalar = {
    school_reg?: boolean
    school_name?: boolean
    school_address?: boolean
    school_lat?: boolean
    school_long?: boolean
    school_princ?: boolean
  }

  export type school_infoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"school_reg" | "school_name" | "school_address" | "school_lat" | "school_long" | "school_princ", ExtArgs["result"]["school_info"]>
  export type school_infoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school_email?: boolean | school_info$school_emailArgs<ExtArgs>
    school_num?: boolean | school_info$school_numArgs<ExtArgs>
    _count?: boolean | School_infoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $school_infoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "school_info"
    objects: {
      school_email: Prisma.$school_emailPayload<ExtArgs>[]
      school_num: Prisma.$school_numPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      school_reg: number
      school_name: string
      school_address: string
      school_lat: number
      school_long: number
      school_princ: string
    }, ExtArgs["result"]["school_info"]>
    composites: {}
  }

  type school_infoGetPayload<S extends boolean | null | undefined | school_infoDefaultArgs> = $Result.GetResult<Prisma.$school_infoPayload, S>

  type school_infoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<school_infoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: School_infoCountAggregateInputType | true
    }

  export interface school_infoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['school_info'], meta: { name: 'school_info' } }
    /**
     * Find zero or one School_info that matches the filter.
     * @param {school_infoFindUniqueArgs} args - Arguments to find a School_info
     * @example
     * // Get one School_info
     * const school_info = await prisma.school_info.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends school_infoFindUniqueArgs>(args: SelectSubset<T, school_infoFindUniqueArgs<ExtArgs>>): Prisma__school_infoClient<$Result.GetResult<Prisma.$school_infoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one School_info that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {school_infoFindUniqueOrThrowArgs} args - Arguments to find a School_info
     * @example
     * // Get one School_info
     * const school_info = await prisma.school_info.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends school_infoFindUniqueOrThrowArgs>(args: SelectSubset<T, school_infoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__school_infoClient<$Result.GetResult<Prisma.$school_infoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School_info that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_infoFindFirstArgs} args - Arguments to find a School_info
     * @example
     * // Get one School_info
     * const school_info = await prisma.school_info.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends school_infoFindFirstArgs>(args?: SelectSubset<T, school_infoFindFirstArgs<ExtArgs>>): Prisma__school_infoClient<$Result.GetResult<Prisma.$school_infoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School_info that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_infoFindFirstOrThrowArgs} args - Arguments to find a School_info
     * @example
     * // Get one School_info
     * const school_info = await prisma.school_info.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends school_infoFindFirstOrThrowArgs>(args?: SelectSubset<T, school_infoFindFirstOrThrowArgs<ExtArgs>>): Prisma__school_infoClient<$Result.GetResult<Prisma.$school_infoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more School_infos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_infoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all School_infos
     * const school_infos = await prisma.school_info.findMany()
     * 
     * // Get first 10 School_infos
     * const school_infos = await prisma.school_info.findMany({ take: 10 })
     * 
     * // Only select the `school_reg`
     * const school_infoWithSchool_regOnly = await prisma.school_info.findMany({ select: { school_reg: true } })
     * 
     */
    findMany<T extends school_infoFindManyArgs>(args?: SelectSubset<T, school_infoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$school_infoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a School_info.
     * @param {school_infoCreateArgs} args - Arguments to create a School_info.
     * @example
     * // Create one School_info
     * const School_info = await prisma.school_info.create({
     *   data: {
     *     // ... data to create a School_info
     *   }
     * })
     * 
     */
    create<T extends school_infoCreateArgs>(args: SelectSubset<T, school_infoCreateArgs<ExtArgs>>): Prisma__school_infoClient<$Result.GetResult<Prisma.$school_infoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many School_infos.
     * @param {school_infoCreateManyArgs} args - Arguments to create many School_infos.
     * @example
     * // Create many School_infos
     * const school_info = await prisma.school_info.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends school_infoCreateManyArgs>(args?: SelectSubset<T, school_infoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a School_info.
     * @param {school_infoDeleteArgs} args - Arguments to delete one School_info.
     * @example
     * // Delete one School_info
     * const School_info = await prisma.school_info.delete({
     *   where: {
     *     // ... filter to delete one School_info
     *   }
     * })
     * 
     */
    delete<T extends school_infoDeleteArgs>(args: SelectSubset<T, school_infoDeleteArgs<ExtArgs>>): Prisma__school_infoClient<$Result.GetResult<Prisma.$school_infoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one School_info.
     * @param {school_infoUpdateArgs} args - Arguments to update one School_info.
     * @example
     * // Update one School_info
     * const school_info = await prisma.school_info.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends school_infoUpdateArgs>(args: SelectSubset<T, school_infoUpdateArgs<ExtArgs>>): Prisma__school_infoClient<$Result.GetResult<Prisma.$school_infoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more School_infos.
     * @param {school_infoDeleteManyArgs} args - Arguments to filter School_infos to delete.
     * @example
     * // Delete a few School_infos
     * const { count } = await prisma.school_info.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends school_infoDeleteManyArgs>(args?: SelectSubset<T, school_infoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more School_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_infoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many School_infos
     * const school_info = await prisma.school_info.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends school_infoUpdateManyArgs>(args: SelectSubset<T, school_infoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one School_info.
     * @param {school_infoUpsertArgs} args - Arguments to update or create a School_info.
     * @example
     * // Update or create a School_info
     * const school_info = await prisma.school_info.upsert({
     *   create: {
     *     // ... data to create a School_info
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School_info we want to update
     *   }
     * })
     */
    upsert<T extends school_infoUpsertArgs>(args: SelectSubset<T, school_infoUpsertArgs<ExtArgs>>): Prisma__school_infoClient<$Result.GetResult<Prisma.$school_infoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of School_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_infoCountArgs} args - Arguments to filter School_infos to count.
     * @example
     * // Count the number of School_infos
     * const count = await prisma.school_info.count({
     *   where: {
     *     // ... the filter for the School_infos we want to count
     *   }
     * })
    **/
    count<T extends school_infoCountArgs>(
      args?: Subset<T, school_infoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], School_infoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {School_infoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends School_infoAggregateArgs>(args: Subset<T, School_infoAggregateArgs>): Prisma.PrismaPromise<GetSchool_infoAggregateType<T>>

    /**
     * Group by School_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_infoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends school_infoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: school_infoGroupByArgs['orderBy'] }
        : { orderBy?: school_infoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, school_infoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchool_infoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the school_info model
   */
  readonly fields: school_infoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for school_info.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__school_infoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school_email<T extends school_info$school_emailArgs<ExtArgs> = {}>(args?: Subset<T, school_info$school_emailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$school_emailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    school_num<T extends school_info$school_numArgs<ExtArgs> = {}>(args?: Subset<T, school_info$school_numArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$school_numPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the school_info model
   */
  interface school_infoFieldRefs {
    readonly school_reg: FieldRef<"school_info", 'Int'>
    readonly school_name: FieldRef<"school_info", 'String'>
    readonly school_address: FieldRef<"school_info", 'String'>
    readonly school_lat: FieldRef<"school_info", 'Float'>
    readonly school_long: FieldRef<"school_info", 'Float'>
    readonly school_princ: FieldRef<"school_info", 'String'>
  }
    

  // Custom InputTypes
  /**
   * school_info findUnique
   */
  export type school_infoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_info
     */
    select?: school_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_info
     */
    omit?: school_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_infoInclude<ExtArgs> | null
    /**
     * Filter, which school_info to fetch.
     */
    where: school_infoWhereUniqueInput
  }

  /**
   * school_info findUniqueOrThrow
   */
  export type school_infoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_info
     */
    select?: school_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_info
     */
    omit?: school_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_infoInclude<ExtArgs> | null
    /**
     * Filter, which school_info to fetch.
     */
    where: school_infoWhereUniqueInput
  }

  /**
   * school_info findFirst
   */
  export type school_infoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_info
     */
    select?: school_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_info
     */
    omit?: school_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_infoInclude<ExtArgs> | null
    /**
     * Filter, which school_info to fetch.
     */
    where?: school_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of school_infos to fetch.
     */
    orderBy?: school_infoOrderByWithRelationInput | school_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for school_infos.
     */
    cursor?: school_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` school_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` school_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of school_infos.
     */
    distinct?: School_infoScalarFieldEnum | School_infoScalarFieldEnum[]
  }

  /**
   * school_info findFirstOrThrow
   */
  export type school_infoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_info
     */
    select?: school_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_info
     */
    omit?: school_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_infoInclude<ExtArgs> | null
    /**
     * Filter, which school_info to fetch.
     */
    where?: school_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of school_infos to fetch.
     */
    orderBy?: school_infoOrderByWithRelationInput | school_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for school_infos.
     */
    cursor?: school_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` school_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` school_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of school_infos.
     */
    distinct?: School_infoScalarFieldEnum | School_infoScalarFieldEnum[]
  }

  /**
   * school_info findMany
   */
  export type school_infoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_info
     */
    select?: school_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_info
     */
    omit?: school_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_infoInclude<ExtArgs> | null
    /**
     * Filter, which school_infos to fetch.
     */
    where?: school_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of school_infos to fetch.
     */
    orderBy?: school_infoOrderByWithRelationInput | school_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing school_infos.
     */
    cursor?: school_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` school_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` school_infos.
     */
    skip?: number
    distinct?: School_infoScalarFieldEnum | School_infoScalarFieldEnum[]
  }

  /**
   * school_info create
   */
  export type school_infoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_info
     */
    select?: school_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_info
     */
    omit?: school_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_infoInclude<ExtArgs> | null
    /**
     * The data needed to create a school_info.
     */
    data: XOR<school_infoCreateInput, school_infoUncheckedCreateInput>
  }

  /**
   * school_info createMany
   */
  export type school_infoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many school_infos.
     */
    data: school_infoCreateManyInput | school_infoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * school_info update
   */
  export type school_infoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_info
     */
    select?: school_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_info
     */
    omit?: school_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_infoInclude<ExtArgs> | null
    /**
     * The data needed to update a school_info.
     */
    data: XOR<school_infoUpdateInput, school_infoUncheckedUpdateInput>
    /**
     * Choose, which school_info to update.
     */
    where: school_infoWhereUniqueInput
  }

  /**
   * school_info updateMany
   */
  export type school_infoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update school_infos.
     */
    data: XOR<school_infoUpdateManyMutationInput, school_infoUncheckedUpdateManyInput>
    /**
     * Filter which school_infos to update
     */
    where?: school_infoWhereInput
    /**
     * Limit how many school_infos to update.
     */
    limit?: number
  }

  /**
   * school_info upsert
   */
  export type school_infoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_info
     */
    select?: school_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_info
     */
    omit?: school_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_infoInclude<ExtArgs> | null
    /**
     * The filter to search for the school_info to update in case it exists.
     */
    where: school_infoWhereUniqueInput
    /**
     * In case the school_info found by the `where` argument doesn't exist, create a new school_info with this data.
     */
    create: XOR<school_infoCreateInput, school_infoUncheckedCreateInput>
    /**
     * In case the school_info was found with the provided `where` argument, update it with this data.
     */
    update: XOR<school_infoUpdateInput, school_infoUncheckedUpdateInput>
  }

  /**
   * school_info delete
   */
  export type school_infoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_info
     */
    select?: school_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_info
     */
    omit?: school_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_infoInclude<ExtArgs> | null
    /**
     * Filter which school_info to delete.
     */
    where: school_infoWhereUniqueInput
  }

  /**
   * school_info deleteMany
   */
  export type school_infoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which school_infos to delete
     */
    where?: school_infoWhereInput
    /**
     * Limit how many school_infos to delete.
     */
    limit?: number
  }

  /**
   * school_info.school_email
   */
  export type school_info$school_emailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_email
     */
    select?: school_emailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_email
     */
    omit?: school_emailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_emailInclude<ExtArgs> | null
    where?: school_emailWhereInput
    orderBy?: school_emailOrderByWithRelationInput | school_emailOrderByWithRelationInput[]
    cursor?: school_emailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: School_emailScalarFieldEnum | School_emailScalarFieldEnum[]
  }

  /**
   * school_info.school_num
   */
  export type school_info$school_numArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_num
     */
    select?: school_numSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_num
     */
    omit?: school_numOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_numInclude<ExtArgs> | null
    where?: school_numWhereInput
    orderBy?: school_numOrderByWithRelationInput | school_numOrderByWithRelationInput[]
    cursor?: school_numWhereUniqueInput
    take?: number
    skip?: number
    distinct?: School_numScalarFieldEnum | School_numScalarFieldEnum[]
  }

  /**
   * school_info without action
   */
  export type school_infoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_info
     */
    select?: school_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_info
     */
    omit?: school_infoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_infoInclude<ExtArgs> | null
  }


  /**
   * Model school_num
   */

  export type AggregateSchool_num = {
    _count: School_numCountAggregateOutputType | null
    _avg: School_numAvgAggregateOutputType | null
    _sum: School_numSumAggregateOutputType | null
    _min: School_numMinAggregateOutputType | null
    _max: School_numMaxAggregateOutputType | null
  }

  export type School_numAvgAggregateOutputType = {
    school_num_id: number | null
    school_reg: number | null
  }

  export type School_numSumAggregateOutputType = {
    school_num_id: number | null
    school_reg: number | null
  }

  export type School_numMinAggregateOutputType = {
    school_num_id: number | null
    school_reg: number | null
    school_phone: string | null
    school_phone_label: string | null
  }

  export type School_numMaxAggregateOutputType = {
    school_num_id: number | null
    school_reg: number | null
    school_phone: string | null
    school_phone_label: string | null
  }

  export type School_numCountAggregateOutputType = {
    school_num_id: number
    school_reg: number
    school_phone: number
    school_phone_label: number
    _all: number
  }


  export type School_numAvgAggregateInputType = {
    school_num_id?: true
    school_reg?: true
  }

  export type School_numSumAggregateInputType = {
    school_num_id?: true
    school_reg?: true
  }

  export type School_numMinAggregateInputType = {
    school_num_id?: true
    school_reg?: true
    school_phone?: true
    school_phone_label?: true
  }

  export type School_numMaxAggregateInputType = {
    school_num_id?: true
    school_reg?: true
    school_phone?: true
    school_phone_label?: true
  }

  export type School_numCountAggregateInputType = {
    school_num_id?: true
    school_reg?: true
    school_phone?: true
    school_phone_label?: true
    _all?: true
  }

  export type School_numAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which school_num to aggregate.
     */
    where?: school_numWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of school_nums to fetch.
     */
    orderBy?: school_numOrderByWithRelationInput | school_numOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: school_numWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` school_nums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` school_nums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned school_nums
    **/
    _count?: true | School_numCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: School_numAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: School_numSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: School_numMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: School_numMaxAggregateInputType
  }

  export type GetSchool_numAggregateType<T extends School_numAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool_num]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool_num[P]>
      : GetScalarType<T[P], AggregateSchool_num[P]>
  }




  export type school_numGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: school_numWhereInput
    orderBy?: school_numOrderByWithAggregationInput | school_numOrderByWithAggregationInput[]
    by: School_numScalarFieldEnum[] | School_numScalarFieldEnum
    having?: school_numScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: School_numCountAggregateInputType | true
    _avg?: School_numAvgAggregateInputType
    _sum?: School_numSumAggregateInputType
    _min?: School_numMinAggregateInputType
    _max?: School_numMaxAggregateInputType
  }

  export type School_numGroupByOutputType = {
    school_num_id: number
    school_reg: number
    school_phone: string
    school_phone_label: string
    _count: School_numCountAggregateOutputType | null
    _avg: School_numAvgAggregateOutputType | null
    _sum: School_numSumAggregateOutputType | null
    _min: School_numMinAggregateOutputType | null
    _max: School_numMaxAggregateOutputType | null
  }

  type GetSchool_numGroupByPayload<T extends school_numGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<School_numGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof School_numGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], School_numGroupByOutputType[P]>
            : GetScalarType<T[P], School_numGroupByOutputType[P]>
        }
      >
    >


  export type school_numSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    school_num_id?: boolean
    school_reg?: boolean
    school_phone?: boolean
    school_phone_label?: boolean
    school_info?: boolean | school_infoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school_num"]>



  export type school_numSelectScalar = {
    school_num_id?: boolean
    school_reg?: boolean
    school_phone?: boolean
    school_phone_label?: boolean
  }

  export type school_numOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"school_num_id" | "school_reg" | "school_phone" | "school_phone_label", ExtArgs["result"]["school_num"]>
  export type school_numInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school_info?: boolean | school_infoDefaultArgs<ExtArgs>
  }

  export type $school_numPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "school_num"
    objects: {
      school_info: Prisma.$school_infoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      school_num_id: number
      school_reg: number
      school_phone: string
      school_phone_label: string
    }, ExtArgs["result"]["school_num"]>
    composites: {}
  }

  type school_numGetPayload<S extends boolean | null | undefined | school_numDefaultArgs> = $Result.GetResult<Prisma.$school_numPayload, S>

  type school_numCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<school_numFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: School_numCountAggregateInputType | true
    }

  export interface school_numDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['school_num'], meta: { name: 'school_num' } }
    /**
     * Find zero or one School_num that matches the filter.
     * @param {school_numFindUniqueArgs} args - Arguments to find a School_num
     * @example
     * // Get one School_num
     * const school_num = await prisma.school_num.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends school_numFindUniqueArgs>(args: SelectSubset<T, school_numFindUniqueArgs<ExtArgs>>): Prisma__school_numClient<$Result.GetResult<Prisma.$school_numPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one School_num that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {school_numFindUniqueOrThrowArgs} args - Arguments to find a School_num
     * @example
     * // Get one School_num
     * const school_num = await prisma.school_num.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends school_numFindUniqueOrThrowArgs>(args: SelectSubset<T, school_numFindUniqueOrThrowArgs<ExtArgs>>): Prisma__school_numClient<$Result.GetResult<Prisma.$school_numPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School_num that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_numFindFirstArgs} args - Arguments to find a School_num
     * @example
     * // Get one School_num
     * const school_num = await prisma.school_num.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends school_numFindFirstArgs>(args?: SelectSubset<T, school_numFindFirstArgs<ExtArgs>>): Prisma__school_numClient<$Result.GetResult<Prisma.$school_numPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School_num that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_numFindFirstOrThrowArgs} args - Arguments to find a School_num
     * @example
     * // Get one School_num
     * const school_num = await prisma.school_num.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends school_numFindFirstOrThrowArgs>(args?: SelectSubset<T, school_numFindFirstOrThrowArgs<ExtArgs>>): Prisma__school_numClient<$Result.GetResult<Prisma.$school_numPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more School_nums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_numFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all School_nums
     * const school_nums = await prisma.school_num.findMany()
     * 
     * // Get first 10 School_nums
     * const school_nums = await prisma.school_num.findMany({ take: 10 })
     * 
     * // Only select the `school_num_id`
     * const school_numWithSchool_num_idOnly = await prisma.school_num.findMany({ select: { school_num_id: true } })
     * 
     */
    findMany<T extends school_numFindManyArgs>(args?: SelectSubset<T, school_numFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$school_numPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a School_num.
     * @param {school_numCreateArgs} args - Arguments to create a School_num.
     * @example
     * // Create one School_num
     * const School_num = await prisma.school_num.create({
     *   data: {
     *     // ... data to create a School_num
     *   }
     * })
     * 
     */
    create<T extends school_numCreateArgs>(args: SelectSubset<T, school_numCreateArgs<ExtArgs>>): Prisma__school_numClient<$Result.GetResult<Prisma.$school_numPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many School_nums.
     * @param {school_numCreateManyArgs} args - Arguments to create many School_nums.
     * @example
     * // Create many School_nums
     * const school_num = await prisma.school_num.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends school_numCreateManyArgs>(args?: SelectSubset<T, school_numCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a School_num.
     * @param {school_numDeleteArgs} args - Arguments to delete one School_num.
     * @example
     * // Delete one School_num
     * const School_num = await prisma.school_num.delete({
     *   where: {
     *     // ... filter to delete one School_num
     *   }
     * })
     * 
     */
    delete<T extends school_numDeleteArgs>(args: SelectSubset<T, school_numDeleteArgs<ExtArgs>>): Prisma__school_numClient<$Result.GetResult<Prisma.$school_numPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one School_num.
     * @param {school_numUpdateArgs} args - Arguments to update one School_num.
     * @example
     * // Update one School_num
     * const school_num = await prisma.school_num.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends school_numUpdateArgs>(args: SelectSubset<T, school_numUpdateArgs<ExtArgs>>): Prisma__school_numClient<$Result.GetResult<Prisma.$school_numPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more School_nums.
     * @param {school_numDeleteManyArgs} args - Arguments to filter School_nums to delete.
     * @example
     * // Delete a few School_nums
     * const { count } = await prisma.school_num.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends school_numDeleteManyArgs>(args?: SelectSubset<T, school_numDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more School_nums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_numUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many School_nums
     * const school_num = await prisma.school_num.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends school_numUpdateManyArgs>(args: SelectSubset<T, school_numUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one School_num.
     * @param {school_numUpsertArgs} args - Arguments to update or create a School_num.
     * @example
     * // Update or create a School_num
     * const school_num = await prisma.school_num.upsert({
     *   create: {
     *     // ... data to create a School_num
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School_num we want to update
     *   }
     * })
     */
    upsert<T extends school_numUpsertArgs>(args: SelectSubset<T, school_numUpsertArgs<ExtArgs>>): Prisma__school_numClient<$Result.GetResult<Prisma.$school_numPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of School_nums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_numCountArgs} args - Arguments to filter School_nums to count.
     * @example
     * // Count the number of School_nums
     * const count = await prisma.school_num.count({
     *   where: {
     *     // ... the filter for the School_nums we want to count
     *   }
     * })
    **/
    count<T extends school_numCountArgs>(
      args?: Subset<T, school_numCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], School_numCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School_num.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {School_numAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends School_numAggregateArgs>(args: Subset<T, School_numAggregateArgs>): Prisma.PrismaPromise<GetSchool_numAggregateType<T>>

    /**
     * Group by School_num.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {school_numGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends school_numGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: school_numGroupByArgs['orderBy'] }
        : { orderBy?: school_numGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, school_numGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchool_numGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the school_num model
   */
  readonly fields: school_numFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for school_num.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__school_numClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school_info<T extends school_infoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, school_infoDefaultArgs<ExtArgs>>): Prisma__school_infoClient<$Result.GetResult<Prisma.$school_infoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the school_num model
   */
  interface school_numFieldRefs {
    readonly school_num_id: FieldRef<"school_num", 'Int'>
    readonly school_reg: FieldRef<"school_num", 'Int'>
    readonly school_phone: FieldRef<"school_num", 'String'>
    readonly school_phone_label: FieldRef<"school_num", 'String'>
  }
    

  // Custom InputTypes
  /**
   * school_num findUnique
   */
  export type school_numFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_num
     */
    select?: school_numSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_num
     */
    omit?: school_numOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_numInclude<ExtArgs> | null
    /**
     * Filter, which school_num to fetch.
     */
    where: school_numWhereUniqueInput
  }

  /**
   * school_num findUniqueOrThrow
   */
  export type school_numFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_num
     */
    select?: school_numSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_num
     */
    omit?: school_numOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_numInclude<ExtArgs> | null
    /**
     * Filter, which school_num to fetch.
     */
    where: school_numWhereUniqueInput
  }

  /**
   * school_num findFirst
   */
  export type school_numFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_num
     */
    select?: school_numSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_num
     */
    omit?: school_numOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_numInclude<ExtArgs> | null
    /**
     * Filter, which school_num to fetch.
     */
    where?: school_numWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of school_nums to fetch.
     */
    orderBy?: school_numOrderByWithRelationInput | school_numOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for school_nums.
     */
    cursor?: school_numWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` school_nums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` school_nums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of school_nums.
     */
    distinct?: School_numScalarFieldEnum | School_numScalarFieldEnum[]
  }

  /**
   * school_num findFirstOrThrow
   */
  export type school_numFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_num
     */
    select?: school_numSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_num
     */
    omit?: school_numOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_numInclude<ExtArgs> | null
    /**
     * Filter, which school_num to fetch.
     */
    where?: school_numWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of school_nums to fetch.
     */
    orderBy?: school_numOrderByWithRelationInput | school_numOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for school_nums.
     */
    cursor?: school_numWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` school_nums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` school_nums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of school_nums.
     */
    distinct?: School_numScalarFieldEnum | School_numScalarFieldEnum[]
  }

  /**
   * school_num findMany
   */
  export type school_numFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_num
     */
    select?: school_numSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_num
     */
    omit?: school_numOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_numInclude<ExtArgs> | null
    /**
     * Filter, which school_nums to fetch.
     */
    where?: school_numWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of school_nums to fetch.
     */
    orderBy?: school_numOrderByWithRelationInput | school_numOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing school_nums.
     */
    cursor?: school_numWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` school_nums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` school_nums.
     */
    skip?: number
    distinct?: School_numScalarFieldEnum | School_numScalarFieldEnum[]
  }

  /**
   * school_num create
   */
  export type school_numCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_num
     */
    select?: school_numSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_num
     */
    omit?: school_numOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_numInclude<ExtArgs> | null
    /**
     * The data needed to create a school_num.
     */
    data: XOR<school_numCreateInput, school_numUncheckedCreateInput>
  }

  /**
   * school_num createMany
   */
  export type school_numCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many school_nums.
     */
    data: school_numCreateManyInput | school_numCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * school_num update
   */
  export type school_numUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_num
     */
    select?: school_numSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_num
     */
    omit?: school_numOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_numInclude<ExtArgs> | null
    /**
     * The data needed to update a school_num.
     */
    data: XOR<school_numUpdateInput, school_numUncheckedUpdateInput>
    /**
     * Choose, which school_num to update.
     */
    where: school_numWhereUniqueInput
  }

  /**
   * school_num updateMany
   */
  export type school_numUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update school_nums.
     */
    data: XOR<school_numUpdateManyMutationInput, school_numUncheckedUpdateManyInput>
    /**
     * Filter which school_nums to update
     */
    where?: school_numWhereInput
    /**
     * Limit how many school_nums to update.
     */
    limit?: number
  }

  /**
   * school_num upsert
   */
  export type school_numUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_num
     */
    select?: school_numSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_num
     */
    omit?: school_numOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_numInclude<ExtArgs> | null
    /**
     * The filter to search for the school_num to update in case it exists.
     */
    where: school_numWhereUniqueInput
    /**
     * In case the school_num found by the `where` argument doesn't exist, create a new school_num with this data.
     */
    create: XOR<school_numCreateInput, school_numUncheckedCreateInput>
    /**
     * In case the school_num was found with the provided `where` argument, update it with this data.
     */
    update: XOR<school_numUpdateInput, school_numUncheckedUpdateInput>
  }

  /**
   * school_num delete
   */
  export type school_numDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_num
     */
    select?: school_numSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_num
     */
    omit?: school_numOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_numInclude<ExtArgs> | null
    /**
     * Filter which school_num to delete.
     */
    where: school_numWhereUniqueInput
  }

  /**
   * school_num deleteMany
   */
  export type school_numDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which school_nums to delete
     */
    where?: school_numWhereInput
    /**
     * Limit how many school_nums to delete.
     */
    limit?: number
  }

  /**
   * school_num without action
   */
  export type school_numDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school_num
     */
    select?: school_numSelect<ExtArgs> | null
    /**
     * Omit specific fields from the school_num
     */
    omit?: school_numOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: school_numInclude<ExtArgs> | null
  }


  /**
   * Model student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    mother_id: number | null
    father_id: number | null
  }

  export type StudentSumAggregateOutputType = {
    mother_id: number | null
    father_id: number | null
  }

  export type StudentMinAggregateOutputType = {
    student_id: string | null
    mother_id: number | null
    father_id: number | null
    student_fname: string | null
    student_lname: string | null
    student_dob: Date | null
    student_account: string | null
    student_pass: string | null
    note: string | null
  }

  export type StudentMaxAggregateOutputType = {
    student_id: string | null
    mother_id: number | null
    father_id: number | null
    student_fname: string | null
    student_lname: string | null
    student_dob: Date | null
    student_account: string | null
    student_pass: string | null
    note: string | null
  }

  export type StudentCountAggregateOutputType = {
    student_id: number
    mother_id: number
    father_id: number
    student_fname: number
    student_lname: number
    student_dob: number
    student_account: number
    student_pass: number
    note: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    mother_id?: true
    father_id?: true
  }

  export type StudentSumAggregateInputType = {
    mother_id?: true
    father_id?: true
  }

  export type StudentMinAggregateInputType = {
    student_id?: true
    mother_id?: true
    father_id?: true
    student_fname?: true
    student_lname?: true
    student_dob?: true
    student_account?: true
    student_pass?: true
    note?: true
  }

  export type StudentMaxAggregateInputType = {
    student_id?: true
    mother_id?: true
    father_id?: true
    student_fname?: true
    student_lname?: true
    student_dob?: true
    student_account?: true
    student_pass?: true
    note?: true
  }

  export type StudentCountAggregateInputType = {
    student_id?: true
    mother_id?: true
    father_id?: true
    student_fname?: true
    student_lname?: true
    student_dob?: true
    student_account?: true
    student_pass?: true
    note?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student to aggregate.
     */
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type studentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentWhereInput
    orderBy?: studentOrderByWithAggregationInput | studentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: studentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    student_id: string
    mother_id: number
    father_id: number
    student_fname: string
    student_lname: string
    student_dob: Date
    student_account: string
    student_pass: string
    note: string | null
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends studentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type studentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_id?: boolean
    mother_id?: boolean
    father_id?: boolean
    student_fname?: boolean
    student_lname?: boolean
    student_dob?: boolean
    student_account?: boolean
    student_pass?: boolean
    note?: boolean
    final_grade?: boolean | student$final_gradeArgs<ExtArgs>
    parent_student_father_idToparent?: boolean | parentDefaultArgs<ExtArgs>
    parent_student_mother_idToparent?: boolean | parentDefaultArgs<ExtArgs>
    test_result?: boolean | student$test_resultArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>



  export type studentSelectScalar = {
    student_id?: boolean
    mother_id?: boolean
    father_id?: boolean
    student_fname?: boolean
    student_lname?: boolean
    student_dob?: boolean
    student_account?: boolean
    student_pass?: boolean
    note?: boolean
  }

  export type studentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"student_id" | "mother_id" | "father_id" | "student_fname" | "student_lname" | "student_dob" | "student_account" | "student_pass" | "note", ExtArgs["result"]["student"]>
  export type studentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    final_grade?: boolean | student$final_gradeArgs<ExtArgs>
    parent_student_father_idToparent?: boolean | parentDefaultArgs<ExtArgs>
    parent_student_mother_idToparent?: boolean | parentDefaultArgs<ExtArgs>
    test_result?: boolean | student$test_resultArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $studentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "student"
    objects: {
      final_grade: Prisma.$final_gradePayload<ExtArgs>[]
      parent_student_father_idToparent: Prisma.$parentPayload<ExtArgs>
      parent_student_mother_idToparent: Prisma.$parentPayload<ExtArgs>
      test_result: Prisma.$test_resultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      student_id: string
      mother_id: number
      father_id: number
      student_fname: string
      student_lname: string
      student_dob: Date
      student_account: string
      student_pass: string
      note: string | null
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type studentGetPayload<S extends boolean | null | undefined | studentDefaultArgs> = $Result.GetResult<Prisma.$studentPayload, S>

  type studentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<studentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface studentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['student'], meta: { name: 'student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {studentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends studentFindUniqueArgs>(args: SelectSubset<T, studentFindUniqueArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {studentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends studentFindUniqueOrThrowArgs>(args: SelectSubset<T, studentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends studentFindFirstArgs>(args?: SelectSubset<T, studentFindFirstArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends studentFindFirstOrThrowArgs>(args?: SelectSubset<T, studentFindFirstOrThrowArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `student_id`
     * const studentWithStudent_idOnly = await prisma.student.findMany({ select: { student_id: true } })
     * 
     */
    findMany<T extends studentFindManyArgs>(args?: SelectSubset<T, studentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {studentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends studentCreateArgs>(args: SelectSubset<T, studentCreateArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {studentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends studentCreateManyArgs>(args?: SelectSubset<T, studentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Student.
     * @param {studentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends studentDeleteArgs>(args: SelectSubset<T, studentDeleteArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {studentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends studentUpdateArgs>(args: SelectSubset<T, studentUpdateArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {studentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends studentDeleteManyArgs>(args?: SelectSubset<T, studentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends studentUpdateManyArgs>(args: SelectSubset<T, studentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {studentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends studentUpsertArgs>(args: SelectSubset<T, studentUpsertArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends studentCountArgs>(
      args?: Subset<T, studentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends studentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: studentGroupByArgs['orderBy'] }
        : { orderBy?: studentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, studentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the student model
   */
  readonly fields: studentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__studentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    final_grade<T extends student$final_gradeArgs<ExtArgs> = {}>(args?: Subset<T, student$final_gradeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$final_gradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parent_student_father_idToparent<T extends parentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, parentDefaultArgs<ExtArgs>>): Prisma__parentClient<$Result.GetResult<Prisma.$parentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent_student_mother_idToparent<T extends parentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, parentDefaultArgs<ExtArgs>>): Prisma__parentClient<$Result.GetResult<Prisma.$parentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    test_result<T extends student$test_resultArgs<ExtArgs> = {}>(args?: Subset<T, student$test_resultArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_resultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the student model
   */
  interface studentFieldRefs {
    readonly student_id: FieldRef<"student", 'String'>
    readonly mother_id: FieldRef<"student", 'Int'>
    readonly father_id: FieldRef<"student", 'Int'>
    readonly student_fname: FieldRef<"student", 'String'>
    readonly student_lname: FieldRef<"student", 'String'>
    readonly student_dob: FieldRef<"student", 'DateTime'>
    readonly student_account: FieldRef<"student", 'String'>
    readonly student_pass: FieldRef<"student", 'String'>
    readonly note: FieldRef<"student", 'String'>
  }
    

  // Custom InputTypes
  /**
   * student findUnique
   */
  export type studentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which student to fetch.
     */
    where: studentWhereUniqueInput
  }

  /**
   * student findUniqueOrThrow
   */
  export type studentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which student to fetch.
     */
    where: studentWhereUniqueInput
  }

  /**
   * student findFirst
   */
  export type studentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which student to fetch.
     */
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * student findFirstOrThrow
   */
  export type studentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which student to fetch.
     */
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * student findMany
   */
  export type studentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing students.
     */
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * student create
   */
  export type studentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * The data needed to create a student.
     */
    data: XOR<studentCreateInput, studentUncheckedCreateInput>
  }

  /**
   * student createMany
   */
  export type studentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many students.
     */
    data: studentCreateManyInput | studentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * student update
   */
  export type studentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * The data needed to update a student.
     */
    data: XOR<studentUpdateInput, studentUncheckedUpdateInput>
    /**
     * Choose, which student to update.
     */
    where: studentWhereUniqueInput
  }

  /**
   * student updateMany
   */
  export type studentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update students.
     */
    data: XOR<studentUpdateManyMutationInput, studentUncheckedUpdateManyInput>
    /**
     * Filter which students to update
     */
    where?: studentWhereInput
    /**
     * Limit how many students to update.
     */
    limit?: number
  }

  /**
   * student upsert
   */
  export type studentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * The filter to search for the student to update in case it exists.
     */
    where: studentWhereUniqueInput
    /**
     * In case the student found by the `where` argument doesn't exist, create a new student with this data.
     */
    create: XOR<studentCreateInput, studentUncheckedCreateInput>
    /**
     * In case the student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<studentUpdateInput, studentUncheckedUpdateInput>
  }

  /**
   * student delete
   */
  export type studentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter which student to delete.
     */
    where: studentWhereUniqueInput
  }

  /**
   * student deleteMany
   */
  export type studentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which students to delete
     */
    where?: studentWhereInput
    /**
     * Limit how many students to delete.
     */
    limit?: number
  }

  /**
   * student.final_grade
   */
  export type student$final_gradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grade
     */
    select?: final_gradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the final_grade
     */
    omit?: final_gradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradeInclude<ExtArgs> | null
    where?: final_gradeWhereInput
    orderBy?: final_gradeOrderByWithRelationInput | final_gradeOrderByWithRelationInput[]
    cursor?: final_gradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Final_gradeScalarFieldEnum | Final_gradeScalarFieldEnum[]
  }

  /**
   * student.test_result
   */
  export type student$test_resultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_result
     */
    select?: test_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_result
     */
    omit?: test_resultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_resultInclude<ExtArgs> | null
    where?: test_resultWhereInput
    orderBy?: test_resultOrderByWithRelationInput | test_resultOrderByWithRelationInput[]
    cursor?: test_resultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_resultScalarFieldEnum | Test_resultScalarFieldEnum[]
  }

  /**
   * student without action
   */
  export type studentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
  }


  /**
   * Model subject_class
   */

  export type AggregateSubject_class = {
    _count: Subject_classCountAggregateOutputType | null
    _avg: Subject_classAvgAggregateOutputType | null
    _sum: Subject_classSumAggregateOutputType | null
    _min: Subject_classMinAggregateOutputType | null
    _max: Subject_classMaxAggregateOutputType | null
  }

  export type Subject_classAvgAggregateOutputType = {
    subject_class_id: number | null
    instructor: number | null
  }

  export type Subject_classSumAggregateOutputType = {
    subject_class_id: number | null
    instructor: number | null
  }

  export type Subject_classMinAggregateOutputType = {
    subject_class_id: number | null
    subject_code: string | null
    instructor: number | null
  }

  export type Subject_classMaxAggregateOutputType = {
    subject_class_id: number | null
    subject_code: string | null
    instructor: number | null
  }

  export type Subject_classCountAggregateOutputType = {
    subject_class_id: number
    subject_code: number
    instructor: number
    _all: number
  }


  export type Subject_classAvgAggregateInputType = {
    subject_class_id?: true
    instructor?: true
  }

  export type Subject_classSumAggregateInputType = {
    subject_class_id?: true
    instructor?: true
  }

  export type Subject_classMinAggregateInputType = {
    subject_class_id?: true
    subject_code?: true
    instructor?: true
  }

  export type Subject_classMaxAggregateInputType = {
    subject_class_id?: true
    subject_code?: true
    instructor?: true
  }

  export type Subject_classCountAggregateInputType = {
    subject_class_id?: true
    subject_code?: true
    instructor?: true
    _all?: true
  }

  export type Subject_classAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subject_class to aggregate.
     */
    where?: subject_classWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subject_classes to fetch.
     */
    orderBy?: subject_classOrderByWithRelationInput | subject_classOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subject_classWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subject_classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subject_classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subject_classes
    **/
    _count?: true | Subject_classCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Subject_classAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Subject_classSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Subject_classMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Subject_classMaxAggregateInputType
  }

  export type GetSubject_classAggregateType<T extends Subject_classAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject_class]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject_class[P]>
      : GetScalarType<T[P], AggregateSubject_class[P]>
  }




  export type subject_classGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subject_classWhereInput
    orderBy?: subject_classOrderByWithAggregationInput | subject_classOrderByWithAggregationInput[]
    by: Subject_classScalarFieldEnum[] | Subject_classScalarFieldEnum
    having?: subject_classScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Subject_classCountAggregateInputType | true
    _avg?: Subject_classAvgAggregateInputType
    _sum?: Subject_classSumAggregateInputType
    _min?: Subject_classMinAggregateInputType
    _max?: Subject_classMaxAggregateInputType
  }

  export type Subject_classGroupByOutputType = {
    subject_class_id: number
    subject_code: string
    instructor: number | null
    _count: Subject_classCountAggregateOutputType | null
    _avg: Subject_classAvgAggregateOutputType | null
    _sum: Subject_classSumAggregateOutputType | null
    _min: Subject_classMinAggregateOutputType | null
    _max: Subject_classMaxAggregateOutputType | null
  }

  type GetSubject_classGroupByPayload<T extends subject_classGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Subject_classGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Subject_classGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Subject_classGroupByOutputType[P]>
            : GetScalarType<T[P], Subject_classGroupByOutputType[P]>
        }
      >
    >


  export type subject_classSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subject_class_id?: boolean
    subject_code?: boolean
    instructor?: boolean
    agenda?: boolean | subject_class$agendaArgs<ExtArgs>
    employee?: boolean | subject_class$employeeArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
    test?: boolean | subject_class$testArgs<ExtArgs>
    _count?: boolean | Subject_classCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject_class"]>



  export type subject_classSelectScalar = {
    subject_class_id?: boolean
    subject_code?: boolean
    instructor?: boolean
  }

  export type subject_classOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"subject_class_id" | "subject_code" | "instructor", ExtArgs["result"]["subject_class"]>
  export type subject_classInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agenda?: boolean | subject_class$agendaArgs<ExtArgs>
    employee?: boolean | subject_class$employeeArgs<ExtArgs>
    subjects?: boolean | subjectsDefaultArgs<ExtArgs>
    test?: boolean | subject_class$testArgs<ExtArgs>
    _count?: boolean | Subject_classCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $subject_classPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subject_class"
    objects: {
      agenda: Prisma.$agendaPayload<ExtArgs>[]
      employee: Prisma.$employeePayload<ExtArgs> | null
      subjects: Prisma.$subjectsPayload<ExtArgs>
      test: Prisma.$testPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      subject_class_id: number
      subject_code: string
      instructor: number | null
    }, ExtArgs["result"]["subject_class"]>
    composites: {}
  }

  type subject_classGetPayload<S extends boolean | null | undefined | subject_classDefaultArgs> = $Result.GetResult<Prisma.$subject_classPayload, S>

  type subject_classCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<subject_classFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Subject_classCountAggregateInputType | true
    }

  export interface subject_classDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subject_class'], meta: { name: 'subject_class' } }
    /**
     * Find zero or one Subject_class that matches the filter.
     * @param {subject_classFindUniqueArgs} args - Arguments to find a Subject_class
     * @example
     * // Get one Subject_class
     * const subject_class = await prisma.subject_class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subject_classFindUniqueArgs>(args: SelectSubset<T, subject_classFindUniqueArgs<ExtArgs>>): Prisma__subject_classClient<$Result.GetResult<Prisma.$subject_classPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subject_class that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {subject_classFindUniqueOrThrowArgs} args - Arguments to find a Subject_class
     * @example
     * // Get one Subject_class
     * const subject_class = await prisma.subject_class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subject_classFindUniqueOrThrowArgs>(args: SelectSubset<T, subject_classFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subject_classClient<$Result.GetResult<Prisma.$subject_classPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject_class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_classFindFirstArgs} args - Arguments to find a Subject_class
     * @example
     * // Get one Subject_class
     * const subject_class = await prisma.subject_class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subject_classFindFirstArgs>(args?: SelectSubset<T, subject_classFindFirstArgs<ExtArgs>>): Prisma__subject_classClient<$Result.GetResult<Prisma.$subject_classPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject_class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_classFindFirstOrThrowArgs} args - Arguments to find a Subject_class
     * @example
     * // Get one Subject_class
     * const subject_class = await prisma.subject_class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subject_classFindFirstOrThrowArgs>(args?: SelectSubset<T, subject_classFindFirstOrThrowArgs<ExtArgs>>): Prisma__subject_classClient<$Result.GetResult<Prisma.$subject_classPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subject_classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_classFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subject_classes
     * const subject_classes = await prisma.subject_class.findMany()
     * 
     * // Get first 10 Subject_classes
     * const subject_classes = await prisma.subject_class.findMany({ take: 10 })
     * 
     * // Only select the `subject_class_id`
     * const subject_classWithSubject_class_idOnly = await prisma.subject_class.findMany({ select: { subject_class_id: true } })
     * 
     */
    findMany<T extends subject_classFindManyArgs>(args?: SelectSubset<T, subject_classFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subject_classPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subject_class.
     * @param {subject_classCreateArgs} args - Arguments to create a Subject_class.
     * @example
     * // Create one Subject_class
     * const Subject_class = await prisma.subject_class.create({
     *   data: {
     *     // ... data to create a Subject_class
     *   }
     * })
     * 
     */
    create<T extends subject_classCreateArgs>(args: SelectSubset<T, subject_classCreateArgs<ExtArgs>>): Prisma__subject_classClient<$Result.GetResult<Prisma.$subject_classPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subject_classes.
     * @param {subject_classCreateManyArgs} args - Arguments to create many Subject_classes.
     * @example
     * // Create many Subject_classes
     * const subject_class = await prisma.subject_class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subject_classCreateManyArgs>(args?: SelectSubset<T, subject_classCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subject_class.
     * @param {subject_classDeleteArgs} args - Arguments to delete one Subject_class.
     * @example
     * // Delete one Subject_class
     * const Subject_class = await prisma.subject_class.delete({
     *   where: {
     *     // ... filter to delete one Subject_class
     *   }
     * })
     * 
     */
    delete<T extends subject_classDeleteArgs>(args: SelectSubset<T, subject_classDeleteArgs<ExtArgs>>): Prisma__subject_classClient<$Result.GetResult<Prisma.$subject_classPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subject_class.
     * @param {subject_classUpdateArgs} args - Arguments to update one Subject_class.
     * @example
     * // Update one Subject_class
     * const subject_class = await prisma.subject_class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subject_classUpdateArgs>(args: SelectSubset<T, subject_classUpdateArgs<ExtArgs>>): Prisma__subject_classClient<$Result.GetResult<Prisma.$subject_classPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subject_classes.
     * @param {subject_classDeleteManyArgs} args - Arguments to filter Subject_classes to delete.
     * @example
     * // Delete a few Subject_classes
     * const { count } = await prisma.subject_class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subject_classDeleteManyArgs>(args?: SelectSubset<T, subject_classDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subject_classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_classUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subject_classes
     * const subject_class = await prisma.subject_class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subject_classUpdateManyArgs>(args: SelectSubset<T, subject_classUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subject_class.
     * @param {subject_classUpsertArgs} args - Arguments to update or create a Subject_class.
     * @example
     * // Update or create a Subject_class
     * const subject_class = await prisma.subject_class.upsert({
     *   create: {
     *     // ... data to create a Subject_class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject_class we want to update
     *   }
     * })
     */
    upsert<T extends subject_classUpsertArgs>(args: SelectSubset<T, subject_classUpsertArgs<ExtArgs>>): Prisma__subject_classClient<$Result.GetResult<Prisma.$subject_classPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subject_classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_classCountArgs} args - Arguments to filter Subject_classes to count.
     * @example
     * // Count the number of Subject_classes
     * const count = await prisma.subject_class.count({
     *   where: {
     *     // ... the filter for the Subject_classes we want to count
     *   }
     * })
    **/
    count<T extends subject_classCountArgs>(
      args?: Subset<T, subject_classCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Subject_classCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject_class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Subject_classAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Subject_classAggregateArgs>(args: Subset<T, Subject_classAggregateArgs>): Prisma.PrismaPromise<GetSubject_classAggregateType<T>>

    /**
     * Group by Subject_class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_classGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subject_classGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subject_classGroupByArgs['orderBy'] }
        : { orderBy?: subject_classGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subject_classGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubject_classGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subject_class model
   */
  readonly fields: subject_classFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subject_class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subject_classClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agenda<T extends subject_class$agendaArgs<ExtArgs> = {}>(args?: Subset<T, subject_class$agendaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agendaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employee<T extends subject_class$employeeArgs<ExtArgs> = {}>(args?: Subset<T, subject_class$employeeArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subjects<T extends subjectsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, subjectsDefaultArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    test<T extends subject_class$testArgs<ExtArgs> = {}>(args?: Subset<T, subject_class$testArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$testPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subject_class model
   */
  interface subject_classFieldRefs {
    readonly subject_class_id: FieldRef<"subject_class", 'Int'>
    readonly subject_code: FieldRef<"subject_class", 'String'>
    readonly instructor: FieldRef<"subject_class", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * subject_class findUnique
   */
  export type subject_classFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_class
     */
    select?: subject_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_class
     */
    omit?: subject_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_classInclude<ExtArgs> | null
    /**
     * Filter, which subject_class to fetch.
     */
    where: subject_classWhereUniqueInput
  }

  /**
   * subject_class findUniqueOrThrow
   */
  export type subject_classFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_class
     */
    select?: subject_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_class
     */
    omit?: subject_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_classInclude<ExtArgs> | null
    /**
     * Filter, which subject_class to fetch.
     */
    where: subject_classWhereUniqueInput
  }

  /**
   * subject_class findFirst
   */
  export type subject_classFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_class
     */
    select?: subject_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_class
     */
    omit?: subject_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_classInclude<ExtArgs> | null
    /**
     * Filter, which subject_class to fetch.
     */
    where?: subject_classWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subject_classes to fetch.
     */
    orderBy?: subject_classOrderByWithRelationInput | subject_classOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subject_classes.
     */
    cursor?: subject_classWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subject_classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subject_classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subject_classes.
     */
    distinct?: Subject_classScalarFieldEnum | Subject_classScalarFieldEnum[]
  }

  /**
   * subject_class findFirstOrThrow
   */
  export type subject_classFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_class
     */
    select?: subject_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_class
     */
    omit?: subject_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_classInclude<ExtArgs> | null
    /**
     * Filter, which subject_class to fetch.
     */
    where?: subject_classWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subject_classes to fetch.
     */
    orderBy?: subject_classOrderByWithRelationInput | subject_classOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subject_classes.
     */
    cursor?: subject_classWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subject_classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subject_classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subject_classes.
     */
    distinct?: Subject_classScalarFieldEnum | Subject_classScalarFieldEnum[]
  }

  /**
   * subject_class findMany
   */
  export type subject_classFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_class
     */
    select?: subject_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_class
     */
    omit?: subject_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_classInclude<ExtArgs> | null
    /**
     * Filter, which subject_classes to fetch.
     */
    where?: subject_classWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subject_classes to fetch.
     */
    orderBy?: subject_classOrderByWithRelationInput | subject_classOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subject_classes.
     */
    cursor?: subject_classWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subject_classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subject_classes.
     */
    skip?: number
    distinct?: Subject_classScalarFieldEnum | Subject_classScalarFieldEnum[]
  }

  /**
   * subject_class create
   */
  export type subject_classCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_class
     */
    select?: subject_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_class
     */
    omit?: subject_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_classInclude<ExtArgs> | null
    /**
     * The data needed to create a subject_class.
     */
    data: XOR<subject_classCreateInput, subject_classUncheckedCreateInput>
  }

  /**
   * subject_class createMany
   */
  export type subject_classCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subject_classes.
     */
    data: subject_classCreateManyInput | subject_classCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subject_class update
   */
  export type subject_classUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_class
     */
    select?: subject_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_class
     */
    omit?: subject_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_classInclude<ExtArgs> | null
    /**
     * The data needed to update a subject_class.
     */
    data: XOR<subject_classUpdateInput, subject_classUncheckedUpdateInput>
    /**
     * Choose, which subject_class to update.
     */
    where: subject_classWhereUniqueInput
  }

  /**
   * subject_class updateMany
   */
  export type subject_classUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subject_classes.
     */
    data: XOR<subject_classUpdateManyMutationInput, subject_classUncheckedUpdateManyInput>
    /**
     * Filter which subject_classes to update
     */
    where?: subject_classWhereInput
    /**
     * Limit how many subject_classes to update.
     */
    limit?: number
  }

  /**
   * subject_class upsert
   */
  export type subject_classUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_class
     */
    select?: subject_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_class
     */
    omit?: subject_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_classInclude<ExtArgs> | null
    /**
     * The filter to search for the subject_class to update in case it exists.
     */
    where: subject_classWhereUniqueInput
    /**
     * In case the subject_class found by the `where` argument doesn't exist, create a new subject_class with this data.
     */
    create: XOR<subject_classCreateInput, subject_classUncheckedCreateInput>
    /**
     * In case the subject_class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subject_classUpdateInput, subject_classUncheckedUpdateInput>
  }

  /**
   * subject_class delete
   */
  export type subject_classDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_class
     */
    select?: subject_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_class
     */
    omit?: subject_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_classInclude<ExtArgs> | null
    /**
     * Filter which subject_class to delete.
     */
    where: subject_classWhereUniqueInput
  }

  /**
   * subject_class deleteMany
   */
  export type subject_classDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subject_classes to delete
     */
    where?: subject_classWhereInput
    /**
     * Limit how many subject_classes to delete.
     */
    limit?: number
  }

  /**
   * subject_class.agenda
   */
  export type subject_class$agendaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agenda
     */
    select?: agendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agenda
     */
    omit?: agendaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agendaInclude<ExtArgs> | null
    where?: agendaWhereInput
    orderBy?: agendaOrderByWithRelationInput | agendaOrderByWithRelationInput[]
    cursor?: agendaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgendaScalarFieldEnum | AgendaScalarFieldEnum[]
  }

  /**
   * subject_class.employee
   */
  export type subject_class$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    where?: employeeWhereInput
  }

  /**
   * subject_class.test
   */
  export type subject_class$testArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test
     */
    select?: testSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test
     */
    omit?: testOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testInclude<ExtArgs> | null
    where?: testWhereInput
    orderBy?: testOrderByWithRelationInput | testOrderByWithRelationInput[]
    cursor?: testWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * subject_class without action
   */
  export type subject_classDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_class
     */
    select?: subject_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_class
     */
    omit?: subject_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_classInclude<ExtArgs> | null
  }


  /**
   * Model subjects
   */

  export type AggregateSubjects = {
    _count: SubjectsCountAggregateOutputType | null
    _min: SubjectsMinAggregateOutputType | null
    _max: SubjectsMaxAggregateOutputType | null
  }

  export type SubjectsMinAggregateOutputType = {
    subject_code: string | null
    subject_name: string | null
    subject_cat: $Enums.subjects_subject_cat | null
  }

  export type SubjectsMaxAggregateOutputType = {
    subject_code: string | null
    subject_name: string | null
    subject_cat: $Enums.subjects_subject_cat | null
  }

  export type SubjectsCountAggregateOutputType = {
    subject_code: number
    subject_name: number
    subject_cat: number
    _all: number
  }


  export type SubjectsMinAggregateInputType = {
    subject_code?: true
    subject_name?: true
    subject_cat?: true
  }

  export type SubjectsMaxAggregateInputType = {
    subject_code?: true
    subject_name?: true
    subject_cat?: true
  }

  export type SubjectsCountAggregateInputType = {
    subject_code?: true
    subject_name?: true
    subject_cat?: true
    _all?: true
  }

  export type SubjectsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subjects to aggregate.
     */
    where?: subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectsOrderByWithRelationInput | subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subjects
    **/
    _count?: true | SubjectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectsMaxAggregateInputType
  }

  export type GetSubjectsAggregateType<T extends SubjectsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubjects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubjects[P]>
      : GetScalarType<T[P], AggregateSubjects[P]>
  }




  export type subjectsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subjectsWhereInput
    orderBy?: subjectsOrderByWithAggregationInput | subjectsOrderByWithAggregationInput[]
    by: SubjectsScalarFieldEnum[] | SubjectsScalarFieldEnum
    having?: subjectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectsCountAggregateInputType | true
    _min?: SubjectsMinAggregateInputType
    _max?: SubjectsMaxAggregateInputType
  }

  export type SubjectsGroupByOutputType = {
    subject_code: string
    subject_name: string
    subject_cat: $Enums.subjects_subject_cat | null
    _count: SubjectsCountAggregateOutputType | null
    _min: SubjectsMinAggregateOutputType | null
    _max: SubjectsMaxAggregateOutputType | null
  }

  type GetSubjectsGroupByPayload<T extends subjectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectsGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectsGroupByOutputType[P]>
        }
      >
    >


  export type subjectsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subject_code?: boolean
    subject_name?: boolean
    subject_cat?: boolean
    final_grade?: boolean | subjects$final_gradeArgs<ExtArgs>
    subject_class?: boolean | subjects$subject_classArgs<ExtArgs>
    _count?: boolean | SubjectsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subjects"]>



  export type subjectsSelectScalar = {
    subject_code?: boolean
    subject_name?: boolean
    subject_cat?: boolean
  }

  export type subjectsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"subject_code" | "subject_name" | "subject_cat", ExtArgs["result"]["subjects"]>
  export type subjectsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    final_grade?: boolean | subjects$final_gradeArgs<ExtArgs>
    subject_class?: boolean | subjects$subject_classArgs<ExtArgs>
    _count?: boolean | SubjectsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $subjectsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subjects"
    objects: {
      final_grade: Prisma.$final_gradePayload<ExtArgs>[]
      subject_class: Prisma.$subject_classPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      subject_code: string
      subject_name: string
      subject_cat: $Enums.subjects_subject_cat | null
    }, ExtArgs["result"]["subjects"]>
    composites: {}
  }

  type subjectsGetPayload<S extends boolean | null | undefined | subjectsDefaultArgs> = $Result.GetResult<Prisma.$subjectsPayload, S>

  type subjectsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<subjectsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectsCountAggregateInputType | true
    }

  export interface subjectsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subjects'], meta: { name: 'subjects' } }
    /**
     * Find zero or one Subjects that matches the filter.
     * @param {subjectsFindUniqueArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subjectsFindUniqueArgs>(args: SelectSubset<T, subjectsFindUniqueArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subjects that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {subjectsFindUniqueOrThrowArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subjectsFindUniqueOrThrowArgs>(args: SelectSubset<T, subjectsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsFindFirstArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subjectsFindFirstArgs>(args?: SelectSubset<T, subjectsFindFirstArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subjects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsFindFirstOrThrowArgs} args - Arguments to find a Subjects
     * @example
     * // Get one Subjects
     * const subjects = await prisma.subjects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subjectsFindFirstOrThrowArgs>(args?: SelectSubset<T, subjectsFindFirstOrThrowArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subjects.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subjects.findMany({ take: 10 })
     * 
     * // Only select the `subject_code`
     * const subjectsWithSubject_codeOnly = await prisma.subjects.findMany({ select: { subject_code: true } })
     * 
     */
    findMany<T extends subjectsFindManyArgs>(args?: SelectSubset<T, subjectsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subjects.
     * @param {subjectsCreateArgs} args - Arguments to create a Subjects.
     * @example
     * // Create one Subjects
     * const Subjects = await prisma.subjects.create({
     *   data: {
     *     // ... data to create a Subjects
     *   }
     * })
     * 
     */
    create<T extends subjectsCreateArgs>(args: SelectSubset<T, subjectsCreateArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subjects.
     * @param {subjectsCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subjects = await prisma.subjects.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subjectsCreateManyArgs>(args?: SelectSubset<T, subjectsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subjects.
     * @param {subjectsDeleteArgs} args - Arguments to delete one Subjects.
     * @example
     * // Delete one Subjects
     * const Subjects = await prisma.subjects.delete({
     *   where: {
     *     // ... filter to delete one Subjects
     *   }
     * })
     * 
     */
    delete<T extends subjectsDeleteArgs>(args: SelectSubset<T, subjectsDeleteArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subjects.
     * @param {subjectsUpdateArgs} args - Arguments to update one Subjects.
     * @example
     * // Update one Subjects
     * const subjects = await prisma.subjects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subjectsUpdateArgs>(args: SelectSubset<T, subjectsUpdateArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subjects.
     * @param {subjectsDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subjects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subjectsDeleteManyArgs>(args?: SelectSubset<T, subjectsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subjects = await prisma.subjects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subjectsUpdateManyArgs>(args: SelectSubset<T, subjectsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subjects.
     * @param {subjectsUpsertArgs} args - Arguments to update or create a Subjects.
     * @example
     * // Update or create a Subjects
     * const subjects = await prisma.subjects.upsert({
     *   create: {
     *     // ... data to create a Subjects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subjects we want to update
     *   }
     * })
     */
    upsert<T extends subjectsUpsertArgs>(args: SelectSubset<T, subjectsUpsertArgs<ExtArgs>>): Prisma__subjectsClient<$Result.GetResult<Prisma.$subjectsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subjects.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends subjectsCountArgs>(
      args?: Subset<T, subjectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectsAggregateArgs>(args: Subset<T, SubjectsAggregateArgs>): Prisma.PrismaPromise<GetSubjectsAggregateType<T>>

    /**
     * Group by Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subjectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subjectsGroupByArgs['orderBy'] }
        : { orderBy?: subjectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subjectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subjects model
   */
  readonly fields: subjectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subjects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subjectsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    final_grade<T extends subjects$final_gradeArgs<ExtArgs> = {}>(args?: Subset<T, subjects$final_gradeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$final_gradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subject_class<T extends subjects$subject_classArgs<ExtArgs> = {}>(args?: Subset<T, subjects$subject_classArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subject_classPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subjects model
   */
  interface subjectsFieldRefs {
    readonly subject_code: FieldRef<"subjects", 'String'>
    readonly subject_name: FieldRef<"subjects", 'String'>
    readonly subject_cat: FieldRef<"subjects", 'subjects_subject_cat'>
  }
    

  // Custom InputTypes
  /**
   * subjects findUnique
   */
  export type subjectsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where: subjectsWhereUniqueInput
  }

  /**
   * subjects findUniqueOrThrow
   */
  export type subjectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where: subjectsWhereUniqueInput
  }

  /**
   * subjects findFirst
   */
  export type subjectsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where?: subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectsOrderByWithRelationInput | subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subjects.
     */
    cursor?: subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subjects.
     */
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * subjects findFirstOrThrow
   */
  export type subjectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where?: subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectsOrderByWithRelationInput | subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subjects.
     */
    cursor?: subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subjects.
     */
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * subjects findMany
   */
  export type subjectsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter, which subjects to fetch.
     */
    where?: subjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     */
    orderBy?: subjectsOrderByWithRelationInput | subjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subjects.
     */
    cursor?: subjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     */
    skip?: number
    distinct?: SubjectsScalarFieldEnum | SubjectsScalarFieldEnum[]
  }

  /**
   * subjects create
   */
  export type subjectsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * The data needed to create a subjects.
     */
    data: XOR<subjectsCreateInput, subjectsUncheckedCreateInput>
  }

  /**
   * subjects createMany
   */
  export type subjectsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subjects.
     */
    data: subjectsCreateManyInput | subjectsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subjects update
   */
  export type subjectsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * The data needed to update a subjects.
     */
    data: XOR<subjectsUpdateInput, subjectsUncheckedUpdateInput>
    /**
     * Choose, which subjects to update.
     */
    where: subjectsWhereUniqueInput
  }

  /**
   * subjects updateMany
   */
  export type subjectsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subjects.
     */
    data: XOR<subjectsUpdateManyMutationInput, subjectsUncheckedUpdateManyInput>
    /**
     * Filter which subjects to update
     */
    where?: subjectsWhereInput
    /**
     * Limit how many subjects to update.
     */
    limit?: number
  }

  /**
   * subjects upsert
   */
  export type subjectsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * The filter to search for the subjects to update in case it exists.
     */
    where: subjectsWhereUniqueInput
    /**
     * In case the subjects found by the `where` argument doesn't exist, create a new subjects with this data.
     */
    create: XOR<subjectsCreateInput, subjectsUncheckedCreateInput>
    /**
     * In case the subjects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subjectsUpdateInput, subjectsUncheckedUpdateInput>
  }

  /**
   * subjects delete
   */
  export type subjectsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
    /**
     * Filter which subjects to delete.
     */
    where: subjectsWhereUniqueInput
  }

  /**
   * subjects deleteMany
   */
  export type subjectsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subjects to delete
     */
    where?: subjectsWhereInput
    /**
     * Limit how many subjects to delete.
     */
    limit?: number
  }

  /**
   * subjects.final_grade
   */
  export type subjects$final_gradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the final_grade
     */
    select?: final_gradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the final_grade
     */
    omit?: final_gradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: final_gradeInclude<ExtArgs> | null
    where?: final_gradeWhereInput
    orderBy?: final_gradeOrderByWithRelationInput | final_gradeOrderByWithRelationInput[]
    cursor?: final_gradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Final_gradeScalarFieldEnum | Final_gradeScalarFieldEnum[]
  }

  /**
   * subjects.subject_class
   */
  export type subjects$subject_classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_class
     */
    select?: subject_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_class
     */
    omit?: subject_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_classInclude<ExtArgs> | null
    where?: subject_classWhereInput
    orderBy?: subject_classOrderByWithRelationInput | subject_classOrderByWithRelationInput[]
    cursor?: subject_classWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Subject_classScalarFieldEnum | Subject_classScalarFieldEnum[]
  }

  /**
   * subjects without action
   */
  export type subjectsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subjects
     */
    select?: subjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subjects
     */
    omit?: subjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subjectsInclude<ExtArgs> | null
  }


  /**
   * Model test
   */

  export type AggregateTest = {
    _count: TestCountAggregateOutputType | null
    _avg: TestAvgAggregateOutputType | null
    _sum: TestSumAggregateOutputType | null
    _min: TestMinAggregateOutputType | null
    _max: TestMaxAggregateOutputType | null
  }

  export type TestAvgAggregateOutputType = {
    test_id: number | null
    subject_class_id: number | null
    test_total: number | null
  }

  export type TestSumAggregateOutputType = {
    test_id: number | null
    subject_class_id: number | null
    test_total: number | null
  }

  export type TestMinAggregateOutputType = {
    test_id: number | null
    test_title: string | null
    test_description: string | null
    subject_class_id: number | null
    test_total: number | null
    test_visibility: string | null
    test_annouced: Date | null
    test_due: Date | null
    test_period: $Enums.test_test_period | null
  }

  export type TestMaxAggregateOutputType = {
    test_id: number | null
    test_title: string | null
    test_description: string | null
    subject_class_id: number | null
    test_total: number | null
    test_visibility: string | null
    test_annouced: Date | null
    test_due: Date | null
    test_period: $Enums.test_test_period | null
  }

  export type TestCountAggregateOutputType = {
    test_id: number
    test_title: number
    test_description: number
    subject_class_id: number
    test_total: number
    test_visibility: number
    test_annouced: number
    test_due: number
    test_period: number
    _all: number
  }


  export type TestAvgAggregateInputType = {
    test_id?: true
    subject_class_id?: true
    test_total?: true
  }

  export type TestSumAggregateInputType = {
    test_id?: true
    subject_class_id?: true
    test_total?: true
  }

  export type TestMinAggregateInputType = {
    test_id?: true
    test_title?: true
    test_description?: true
    subject_class_id?: true
    test_total?: true
    test_visibility?: true
    test_annouced?: true
    test_due?: true
    test_period?: true
  }

  export type TestMaxAggregateInputType = {
    test_id?: true
    test_title?: true
    test_description?: true
    subject_class_id?: true
    test_total?: true
    test_visibility?: true
    test_annouced?: true
    test_due?: true
    test_period?: true
  }

  export type TestCountAggregateInputType = {
    test_id?: true
    test_title?: true
    test_description?: true
    subject_class_id?: true
    test_total?: true
    test_visibility?: true
    test_annouced?: true
    test_due?: true
    test_period?: true
    _all?: true
  }

  export type TestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test to aggregate.
     */
    where?: testWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tests to fetch.
     */
    orderBy?: testOrderByWithRelationInput | testOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: testWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tests
    **/
    _count?: true | TestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestMaxAggregateInputType
  }

  export type GetTestAggregateType<T extends TestAggregateArgs> = {
        [P in keyof T & keyof AggregateTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest[P]>
      : GetScalarType<T[P], AggregateTest[P]>
  }




  export type testGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: testWhereInput
    orderBy?: testOrderByWithAggregationInput | testOrderByWithAggregationInput[]
    by: TestScalarFieldEnum[] | TestScalarFieldEnum
    having?: testScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestCountAggregateInputType | true
    _avg?: TestAvgAggregateInputType
    _sum?: TestSumAggregateInputType
    _min?: TestMinAggregateInputType
    _max?: TestMaxAggregateInputType
  }

  export type TestGroupByOutputType = {
    test_id: number
    test_title: string | null
    test_description: string | null
    subject_class_id: number | null
    test_total: number | null
    test_visibility: string | null
    test_annouced: Date | null
    test_due: Date | null
    test_period: $Enums.test_test_period | null
    _count: TestCountAggregateOutputType | null
    _avg: TestAvgAggregateOutputType | null
    _sum: TestSumAggregateOutputType | null
    _min: TestMinAggregateOutputType | null
    _max: TestMaxAggregateOutputType | null
  }

  type GetTestGroupByPayload<T extends testGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestGroupByOutputType[P]>
            : GetScalarType<T[P], TestGroupByOutputType[P]>
        }
      >
    >


  export type testSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    test_id?: boolean
    test_title?: boolean
    test_description?: boolean
    subject_class_id?: boolean
    test_total?: boolean
    test_visibility?: boolean
    test_annouced?: boolean
    test_due?: boolean
    test_period?: boolean
    subject_class?: boolean | test$subject_classArgs<ExtArgs>
    test_result?: boolean | test$test_resultArgs<ExtArgs>
    _count?: boolean | TestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["test"]>



  export type testSelectScalar = {
    test_id?: boolean
    test_title?: boolean
    test_description?: boolean
    subject_class_id?: boolean
    test_total?: boolean
    test_visibility?: boolean
    test_annouced?: boolean
    test_due?: boolean
    test_period?: boolean
  }

  export type testOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"test_id" | "test_title" | "test_description" | "subject_class_id" | "test_total" | "test_visibility" | "test_annouced" | "test_due" | "test_period", ExtArgs["result"]["test"]>
  export type testInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject_class?: boolean | test$subject_classArgs<ExtArgs>
    test_result?: boolean | test$test_resultArgs<ExtArgs>
    _count?: boolean | TestCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $testPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "test"
    objects: {
      subject_class: Prisma.$subject_classPayload<ExtArgs> | null
      test_result: Prisma.$test_resultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      test_id: number
      test_title: string | null
      test_description: string | null
      subject_class_id: number | null
      test_total: number | null
      test_visibility: string | null
      test_annouced: Date | null
      test_due: Date | null
      test_period: $Enums.test_test_period | null
    }, ExtArgs["result"]["test"]>
    composites: {}
  }

  type testGetPayload<S extends boolean | null | undefined | testDefaultArgs> = $Result.GetResult<Prisma.$testPayload, S>

  type testCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<testFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestCountAggregateInputType | true
    }

  export interface testDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['test'], meta: { name: 'test' } }
    /**
     * Find zero or one Test that matches the filter.
     * @param {testFindUniqueArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends testFindUniqueArgs>(args: SelectSubset<T, testFindUniqueArgs<ExtArgs>>): Prisma__testClient<$Result.GetResult<Prisma.$testPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Test that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {testFindUniqueOrThrowArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends testFindUniqueOrThrowArgs>(args: SelectSubset<T, testFindUniqueOrThrowArgs<ExtArgs>>): Prisma__testClient<$Result.GetResult<Prisma.$testPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testFindFirstArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends testFindFirstArgs>(args?: SelectSubset<T, testFindFirstArgs<ExtArgs>>): Prisma__testClient<$Result.GetResult<Prisma.$testPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testFindFirstOrThrowArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends testFindFirstOrThrowArgs>(args?: SelectSubset<T, testFindFirstOrThrowArgs<ExtArgs>>): Prisma__testClient<$Result.GetResult<Prisma.$testPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tests
     * const tests = await prisma.test.findMany()
     * 
     * // Get first 10 Tests
     * const tests = await prisma.test.findMany({ take: 10 })
     * 
     * // Only select the `test_id`
     * const testWithTest_idOnly = await prisma.test.findMany({ select: { test_id: true } })
     * 
     */
    findMany<T extends testFindManyArgs>(args?: SelectSubset<T, testFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$testPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Test.
     * @param {testCreateArgs} args - Arguments to create a Test.
     * @example
     * // Create one Test
     * const Test = await prisma.test.create({
     *   data: {
     *     // ... data to create a Test
     *   }
     * })
     * 
     */
    create<T extends testCreateArgs>(args: SelectSubset<T, testCreateArgs<ExtArgs>>): Prisma__testClient<$Result.GetResult<Prisma.$testPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tests.
     * @param {testCreateManyArgs} args - Arguments to create many Tests.
     * @example
     * // Create many Tests
     * const test = await prisma.test.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends testCreateManyArgs>(args?: SelectSubset<T, testCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Test.
     * @param {testDeleteArgs} args - Arguments to delete one Test.
     * @example
     * // Delete one Test
     * const Test = await prisma.test.delete({
     *   where: {
     *     // ... filter to delete one Test
     *   }
     * })
     * 
     */
    delete<T extends testDeleteArgs>(args: SelectSubset<T, testDeleteArgs<ExtArgs>>): Prisma__testClient<$Result.GetResult<Prisma.$testPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Test.
     * @param {testUpdateArgs} args - Arguments to update one Test.
     * @example
     * // Update one Test
     * const test = await prisma.test.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends testUpdateArgs>(args: SelectSubset<T, testUpdateArgs<ExtArgs>>): Prisma__testClient<$Result.GetResult<Prisma.$testPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tests.
     * @param {testDeleteManyArgs} args - Arguments to filter Tests to delete.
     * @example
     * // Delete a few Tests
     * const { count } = await prisma.test.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends testDeleteManyArgs>(args?: SelectSubset<T, testDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tests
     * const test = await prisma.test.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends testUpdateManyArgs>(args: SelectSubset<T, testUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Test.
     * @param {testUpsertArgs} args - Arguments to update or create a Test.
     * @example
     * // Update or create a Test
     * const test = await prisma.test.upsert({
     *   create: {
     *     // ... data to create a Test
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test we want to update
     *   }
     * })
     */
    upsert<T extends testUpsertArgs>(args: SelectSubset<T, testUpsertArgs<ExtArgs>>): Prisma__testClient<$Result.GetResult<Prisma.$testPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testCountArgs} args - Arguments to filter Tests to count.
     * @example
     * // Count the number of Tests
     * const count = await prisma.test.count({
     *   where: {
     *     // ... the filter for the Tests we want to count
     *   }
     * })
    **/
    count<T extends testCountArgs>(
      args?: Subset<T, testCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestAggregateArgs>(args: Subset<T, TestAggregateArgs>): Prisma.PrismaPromise<GetTestAggregateType<T>>

    /**
     * Group by Test.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends testGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: testGroupByArgs['orderBy'] }
        : { orderBy?: testGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, testGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the test model
   */
  readonly fields: testFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for test.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__testClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject_class<T extends test$subject_classArgs<ExtArgs> = {}>(args?: Subset<T, test$subject_classArgs<ExtArgs>>): Prisma__subject_classClient<$Result.GetResult<Prisma.$subject_classPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    test_result<T extends test$test_resultArgs<ExtArgs> = {}>(args?: Subset<T, test$test_resultArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_resultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the test model
   */
  interface testFieldRefs {
    readonly test_id: FieldRef<"test", 'Int'>
    readonly test_title: FieldRef<"test", 'String'>
    readonly test_description: FieldRef<"test", 'String'>
    readonly subject_class_id: FieldRef<"test", 'Int'>
    readonly test_total: FieldRef<"test", 'Int'>
    readonly test_visibility: FieldRef<"test", 'String'>
    readonly test_annouced: FieldRef<"test", 'DateTime'>
    readonly test_due: FieldRef<"test", 'DateTime'>
    readonly test_period: FieldRef<"test", 'test_test_period'>
  }
    

  // Custom InputTypes
  /**
   * test findUnique
   */
  export type testFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test
     */
    select?: testSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test
     */
    omit?: testOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testInclude<ExtArgs> | null
    /**
     * Filter, which test to fetch.
     */
    where: testWhereUniqueInput
  }

  /**
   * test findUniqueOrThrow
   */
  export type testFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test
     */
    select?: testSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test
     */
    omit?: testOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testInclude<ExtArgs> | null
    /**
     * Filter, which test to fetch.
     */
    where: testWhereUniqueInput
  }

  /**
   * test findFirst
   */
  export type testFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test
     */
    select?: testSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test
     */
    omit?: testOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testInclude<ExtArgs> | null
    /**
     * Filter, which test to fetch.
     */
    where?: testWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tests to fetch.
     */
    orderBy?: testOrderByWithRelationInput | testOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tests.
     */
    cursor?: testWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tests.
     */
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * test findFirstOrThrow
   */
  export type testFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test
     */
    select?: testSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test
     */
    omit?: testOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testInclude<ExtArgs> | null
    /**
     * Filter, which test to fetch.
     */
    where?: testWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tests to fetch.
     */
    orderBy?: testOrderByWithRelationInput | testOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tests.
     */
    cursor?: testWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tests.
     */
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * test findMany
   */
  export type testFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test
     */
    select?: testSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test
     */
    omit?: testOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testInclude<ExtArgs> | null
    /**
     * Filter, which tests to fetch.
     */
    where?: testWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tests to fetch.
     */
    orderBy?: testOrderByWithRelationInput | testOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tests.
     */
    cursor?: testWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tests.
     */
    skip?: number
    distinct?: TestScalarFieldEnum | TestScalarFieldEnum[]
  }

  /**
   * test create
   */
  export type testCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test
     */
    select?: testSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test
     */
    omit?: testOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testInclude<ExtArgs> | null
    /**
     * The data needed to create a test.
     */
    data?: XOR<testCreateInput, testUncheckedCreateInput>
  }

  /**
   * test createMany
   */
  export type testCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tests.
     */
    data: testCreateManyInput | testCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * test update
   */
  export type testUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test
     */
    select?: testSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test
     */
    omit?: testOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testInclude<ExtArgs> | null
    /**
     * The data needed to update a test.
     */
    data: XOR<testUpdateInput, testUncheckedUpdateInput>
    /**
     * Choose, which test to update.
     */
    where: testWhereUniqueInput
  }

  /**
   * test updateMany
   */
  export type testUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tests.
     */
    data: XOR<testUpdateManyMutationInput, testUncheckedUpdateManyInput>
    /**
     * Filter which tests to update
     */
    where?: testWhereInput
    /**
     * Limit how many tests to update.
     */
    limit?: number
  }

  /**
   * test upsert
   */
  export type testUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test
     */
    select?: testSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test
     */
    omit?: testOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testInclude<ExtArgs> | null
    /**
     * The filter to search for the test to update in case it exists.
     */
    where: testWhereUniqueInput
    /**
     * In case the test found by the `where` argument doesn't exist, create a new test with this data.
     */
    create: XOR<testCreateInput, testUncheckedCreateInput>
    /**
     * In case the test was found with the provided `where` argument, update it with this data.
     */
    update: XOR<testUpdateInput, testUncheckedUpdateInput>
  }

  /**
   * test delete
   */
  export type testDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test
     */
    select?: testSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test
     */
    omit?: testOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testInclude<ExtArgs> | null
    /**
     * Filter which test to delete.
     */
    where: testWhereUniqueInput
  }

  /**
   * test deleteMany
   */
  export type testDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tests to delete
     */
    where?: testWhereInput
    /**
     * Limit how many tests to delete.
     */
    limit?: number
  }

  /**
   * test.subject_class
   */
  export type test$subject_classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subject_class
     */
    select?: subject_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subject_class
     */
    omit?: subject_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subject_classInclude<ExtArgs> | null
    where?: subject_classWhereInput
  }

  /**
   * test.test_result
   */
  export type test$test_resultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_result
     */
    select?: test_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_result
     */
    omit?: test_resultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_resultInclude<ExtArgs> | null
    where?: test_resultWhereInput
    orderBy?: test_resultOrderByWithRelationInput | test_resultOrderByWithRelationInput[]
    cursor?: test_resultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Test_resultScalarFieldEnum | Test_resultScalarFieldEnum[]
  }

  /**
   * test without action
   */
  export type testDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test
     */
    select?: testSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test
     */
    omit?: testOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testInclude<ExtArgs> | null
  }


  /**
   * Model test_result
   */

  export type AggregateTest_result = {
    _count: Test_resultCountAggregateOutputType | null
    _avg: Test_resultAvgAggregateOutputType | null
    _sum: Test_resultSumAggregateOutputType | null
    _min: Test_resultMinAggregateOutputType | null
    _max: Test_resultMaxAggregateOutputType | null
  }

  export type Test_resultAvgAggregateOutputType = {
    test_result_id: number | null
    test_id: number | null
    test_result: number | null
  }

  export type Test_resultSumAggregateOutputType = {
    test_result_id: number | null
    test_id: number | null
    test_result: number | null
  }

  export type Test_resultMinAggregateOutputType = {
    test_result_id: number | null
    test_id: number | null
    student_id: string | null
    test_result: number | null
    test_note: string | null
  }

  export type Test_resultMaxAggregateOutputType = {
    test_result_id: number | null
    test_id: number | null
    student_id: string | null
    test_result: number | null
    test_note: string | null
  }

  export type Test_resultCountAggregateOutputType = {
    test_result_id: number
    test_id: number
    student_id: number
    test_result: number
    test_note: number
    _all: number
  }


  export type Test_resultAvgAggregateInputType = {
    test_result_id?: true
    test_id?: true
    test_result?: true
  }

  export type Test_resultSumAggregateInputType = {
    test_result_id?: true
    test_id?: true
    test_result?: true
  }

  export type Test_resultMinAggregateInputType = {
    test_result_id?: true
    test_id?: true
    student_id?: true
    test_result?: true
    test_note?: true
  }

  export type Test_resultMaxAggregateInputType = {
    test_result_id?: true
    test_id?: true
    student_id?: true
    test_result?: true
    test_note?: true
  }

  export type Test_resultCountAggregateInputType = {
    test_result_id?: true
    test_id?: true
    student_id?: true
    test_result?: true
    test_note?: true
    _all?: true
  }

  export type Test_resultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_result to aggregate.
     */
    where?: test_resultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_results to fetch.
     */
    orderBy?: test_resultOrderByWithRelationInput | test_resultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: test_resultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned test_results
    **/
    _count?: true | Test_resultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Test_resultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Test_resultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Test_resultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Test_resultMaxAggregateInputType
  }

  export type GetTest_resultAggregateType<T extends Test_resultAggregateArgs> = {
        [P in keyof T & keyof AggregateTest_result]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest_result[P]>
      : GetScalarType<T[P], AggregateTest_result[P]>
  }




  export type test_resultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: test_resultWhereInput
    orderBy?: test_resultOrderByWithAggregationInput | test_resultOrderByWithAggregationInput[]
    by: Test_resultScalarFieldEnum[] | Test_resultScalarFieldEnum
    having?: test_resultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Test_resultCountAggregateInputType | true
    _avg?: Test_resultAvgAggregateInputType
    _sum?: Test_resultSumAggregateInputType
    _min?: Test_resultMinAggregateInputType
    _max?: Test_resultMaxAggregateInputType
  }

  export type Test_resultGroupByOutputType = {
    test_result_id: number
    test_id: number
    student_id: string | null
    test_result: number
    test_note: string | null
    _count: Test_resultCountAggregateOutputType | null
    _avg: Test_resultAvgAggregateOutputType | null
    _sum: Test_resultSumAggregateOutputType | null
    _min: Test_resultMinAggregateOutputType | null
    _max: Test_resultMaxAggregateOutputType | null
  }

  type GetTest_resultGroupByPayload<T extends test_resultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Test_resultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Test_resultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Test_resultGroupByOutputType[P]>
            : GetScalarType<T[P], Test_resultGroupByOutputType[P]>
        }
      >
    >


  export type test_resultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    test_result_id?: boolean
    test_id?: boolean
    student_id?: boolean
    test_result?: boolean
    test_note?: boolean
    test?: boolean | testDefaultArgs<ExtArgs>
    student?: boolean | test_result$studentArgs<ExtArgs>
  }, ExtArgs["result"]["test_result"]>



  export type test_resultSelectScalar = {
    test_result_id?: boolean
    test_id?: boolean
    student_id?: boolean
    test_result?: boolean
    test_note?: boolean
  }

  export type test_resultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"test_result_id" | "test_id" | "student_id" | "test_result" | "test_note", ExtArgs["result"]["test_result"]>
  export type test_resultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | testDefaultArgs<ExtArgs>
    student?: boolean | test_result$studentArgs<ExtArgs>
  }

  export type $test_resultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "test_result"
    objects: {
      test: Prisma.$testPayload<ExtArgs>
      student: Prisma.$studentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      test_result_id: number
      test_id: number
      student_id: string | null
      test_result: number
      test_note: string | null
    }, ExtArgs["result"]["test_result"]>
    composites: {}
  }

  type test_resultGetPayload<S extends boolean | null | undefined | test_resultDefaultArgs> = $Result.GetResult<Prisma.$test_resultPayload, S>

  type test_resultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<test_resultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Test_resultCountAggregateInputType | true
    }

  export interface test_resultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['test_result'], meta: { name: 'test_result' } }
    /**
     * Find zero or one Test_result that matches the filter.
     * @param {test_resultFindUniqueArgs} args - Arguments to find a Test_result
     * @example
     * // Get one Test_result
     * const test_result = await prisma.test_result.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends test_resultFindUniqueArgs>(args: SelectSubset<T, test_resultFindUniqueArgs<ExtArgs>>): Prisma__test_resultClient<$Result.GetResult<Prisma.$test_resultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Test_result that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {test_resultFindUniqueOrThrowArgs} args - Arguments to find a Test_result
     * @example
     * // Get one Test_result
     * const test_result = await prisma.test_result.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends test_resultFindUniqueOrThrowArgs>(args: SelectSubset<T, test_resultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__test_resultClient<$Result.GetResult<Prisma.$test_resultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test_result that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_resultFindFirstArgs} args - Arguments to find a Test_result
     * @example
     * // Get one Test_result
     * const test_result = await prisma.test_result.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends test_resultFindFirstArgs>(args?: SelectSubset<T, test_resultFindFirstArgs<ExtArgs>>): Prisma__test_resultClient<$Result.GetResult<Prisma.$test_resultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Test_result that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_resultFindFirstOrThrowArgs} args - Arguments to find a Test_result
     * @example
     * // Get one Test_result
     * const test_result = await prisma.test_result.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends test_resultFindFirstOrThrowArgs>(args?: SelectSubset<T, test_resultFindFirstOrThrowArgs<ExtArgs>>): Prisma__test_resultClient<$Result.GetResult<Prisma.$test_resultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Test_results that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_resultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Test_results
     * const test_results = await prisma.test_result.findMany()
     * 
     * // Get first 10 Test_results
     * const test_results = await prisma.test_result.findMany({ take: 10 })
     * 
     * // Only select the `test_result_id`
     * const test_resultWithTest_result_idOnly = await prisma.test_result.findMany({ select: { test_result_id: true } })
     * 
     */
    findMany<T extends test_resultFindManyArgs>(args?: SelectSubset<T, test_resultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$test_resultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Test_result.
     * @param {test_resultCreateArgs} args - Arguments to create a Test_result.
     * @example
     * // Create one Test_result
     * const Test_result = await prisma.test_result.create({
     *   data: {
     *     // ... data to create a Test_result
     *   }
     * })
     * 
     */
    create<T extends test_resultCreateArgs>(args: SelectSubset<T, test_resultCreateArgs<ExtArgs>>): Prisma__test_resultClient<$Result.GetResult<Prisma.$test_resultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Test_results.
     * @param {test_resultCreateManyArgs} args - Arguments to create many Test_results.
     * @example
     * // Create many Test_results
     * const test_result = await prisma.test_result.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends test_resultCreateManyArgs>(args?: SelectSubset<T, test_resultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Test_result.
     * @param {test_resultDeleteArgs} args - Arguments to delete one Test_result.
     * @example
     * // Delete one Test_result
     * const Test_result = await prisma.test_result.delete({
     *   where: {
     *     // ... filter to delete one Test_result
     *   }
     * })
     * 
     */
    delete<T extends test_resultDeleteArgs>(args: SelectSubset<T, test_resultDeleteArgs<ExtArgs>>): Prisma__test_resultClient<$Result.GetResult<Prisma.$test_resultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Test_result.
     * @param {test_resultUpdateArgs} args - Arguments to update one Test_result.
     * @example
     * // Update one Test_result
     * const test_result = await prisma.test_result.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends test_resultUpdateArgs>(args: SelectSubset<T, test_resultUpdateArgs<ExtArgs>>): Prisma__test_resultClient<$Result.GetResult<Prisma.$test_resultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Test_results.
     * @param {test_resultDeleteManyArgs} args - Arguments to filter Test_results to delete.
     * @example
     * // Delete a few Test_results
     * const { count } = await prisma.test_result.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends test_resultDeleteManyArgs>(args?: SelectSubset<T, test_resultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Test_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_resultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Test_results
     * const test_result = await prisma.test_result.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends test_resultUpdateManyArgs>(args: SelectSubset<T, test_resultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Test_result.
     * @param {test_resultUpsertArgs} args - Arguments to update or create a Test_result.
     * @example
     * // Update or create a Test_result
     * const test_result = await prisma.test_result.upsert({
     *   create: {
     *     // ... data to create a Test_result
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test_result we want to update
     *   }
     * })
     */
    upsert<T extends test_resultUpsertArgs>(args: SelectSubset<T, test_resultUpsertArgs<ExtArgs>>): Prisma__test_resultClient<$Result.GetResult<Prisma.$test_resultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Test_results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_resultCountArgs} args - Arguments to filter Test_results to count.
     * @example
     * // Count the number of Test_results
     * const count = await prisma.test_result.count({
     *   where: {
     *     // ... the filter for the Test_results we want to count
     *   }
     * })
    **/
    count<T extends test_resultCountArgs>(
      args?: Subset<T, test_resultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Test_resultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test_result.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Test_resultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Test_resultAggregateArgs>(args: Subset<T, Test_resultAggregateArgs>): Prisma.PrismaPromise<GetTest_resultAggregateType<T>>

    /**
     * Group by Test_result.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {test_resultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends test_resultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: test_resultGroupByArgs['orderBy'] }
        : { orderBy?: test_resultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, test_resultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTest_resultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the test_result model
   */
  readonly fields: test_resultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for test_result.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__test_resultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test<T extends testDefaultArgs<ExtArgs> = {}>(args?: Subset<T, testDefaultArgs<ExtArgs>>): Prisma__testClient<$Result.GetResult<Prisma.$testPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends test_result$studentArgs<ExtArgs> = {}>(args?: Subset<T, test_result$studentArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the test_result model
   */
  interface test_resultFieldRefs {
    readonly test_result_id: FieldRef<"test_result", 'Int'>
    readonly test_id: FieldRef<"test_result", 'Int'>
    readonly student_id: FieldRef<"test_result", 'String'>
    readonly test_result: FieldRef<"test_result", 'Float'>
    readonly test_note: FieldRef<"test_result", 'String'>
  }
    

  // Custom InputTypes
  /**
   * test_result findUnique
   */
  export type test_resultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_result
     */
    select?: test_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_result
     */
    omit?: test_resultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_resultInclude<ExtArgs> | null
    /**
     * Filter, which test_result to fetch.
     */
    where: test_resultWhereUniqueInput
  }

  /**
   * test_result findUniqueOrThrow
   */
  export type test_resultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_result
     */
    select?: test_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_result
     */
    omit?: test_resultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_resultInclude<ExtArgs> | null
    /**
     * Filter, which test_result to fetch.
     */
    where: test_resultWhereUniqueInput
  }

  /**
   * test_result findFirst
   */
  export type test_resultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_result
     */
    select?: test_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_result
     */
    omit?: test_resultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_resultInclude<ExtArgs> | null
    /**
     * Filter, which test_result to fetch.
     */
    where?: test_resultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_results to fetch.
     */
    orderBy?: test_resultOrderByWithRelationInput | test_resultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_results.
     */
    cursor?: test_resultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_results.
     */
    distinct?: Test_resultScalarFieldEnum | Test_resultScalarFieldEnum[]
  }

  /**
   * test_result findFirstOrThrow
   */
  export type test_resultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_result
     */
    select?: test_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_result
     */
    omit?: test_resultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_resultInclude<ExtArgs> | null
    /**
     * Filter, which test_result to fetch.
     */
    where?: test_resultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_results to fetch.
     */
    orderBy?: test_resultOrderByWithRelationInput | test_resultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for test_results.
     */
    cursor?: test_resultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of test_results.
     */
    distinct?: Test_resultScalarFieldEnum | Test_resultScalarFieldEnum[]
  }

  /**
   * test_result findMany
   */
  export type test_resultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_result
     */
    select?: test_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_result
     */
    omit?: test_resultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_resultInclude<ExtArgs> | null
    /**
     * Filter, which test_results to fetch.
     */
    where?: test_resultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of test_results to fetch.
     */
    orderBy?: test_resultOrderByWithRelationInput | test_resultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing test_results.
     */
    cursor?: test_resultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` test_results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` test_results.
     */
    skip?: number
    distinct?: Test_resultScalarFieldEnum | Test_resultScalarFieldEnum[]
  }

  /**
   * test_result create
   */
  export type test_resultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_result
     */
    select?: test_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_result
     */
    omit?: test_resultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_resultInclude<ExtArgs> | null
    /**
     * The data needed to create a test_result.
     */
    data: XOR<test_resultCreateInput, test_resultUncheckedCreateInput>
  }

  /**
   * test_result createMany
   */
  export type test_resultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many test_results.
     */
    data: test_resultCreateManyInput | test_resultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * test_result update
   */
  export type test_resultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_result
     */
    select?: test_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_result
     */
    omit?: test_resultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_resultInclude<ExtArgs> | null
    /**
     * The data needed to update a test_result.
     */
    data: XOR<test_resultUpdateInput, test_resultUncheckedUpdateInput>
    /**
     * Choose, which test_result to update.
     */
    where: test_resultWhereUniqueInput
  }

  /**
   * test_result updateMany
   */
  export type test_resultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update test_results.
     */
    data: XOR<test_resultUpdateManyMutationInput, test_resultUncheckedUpdateManyInput>
    /**
     * Filter which test_results to update
     */
    where?: test_resultWhereInput
    /**
     * Limit how many test_results to update.
     */
    limit?: number
  }

  /**
   * test_result upsert
   */
  export type test_resultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_result
     */
    select?: test_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_result
     */
    omit?: test_resultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_resultInclude<ExtArgs> | null
    /**
     * The filter to search for the test_result to update in case it exists.
     */
    where: test_resultWhereUniqueInput
    /**
     * In case the test_result found by the `where` argument doesn't exist, create a new test_result with this data.
     */
    create: XOR<test_resultCreateInput, test_resultUncheckedCreateInput>
    /**
     * In case the test_result was found with the provided `where` argument, update it with this data.
     */
    update: XOR<test_resultUpdateInput, test_resultUncheckedUpdateInput>
  }

  /**
   * test_result delete
   */
  export type test_resultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_result
     */
    select?: test_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_result
     */
    omit?: test_resultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_resultInclude<ExtArgs> | null
    /**
     * Filter which test_result to delete.
     */
    where: test_resultWhereUniqueInput
  }

  /**
   * test_result deleteMany
   */
  export type test_resultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which test_results to delete
     */
    where?: test_resultWhereInput
    /**
     * Limit how many test_results to delete.
     */
    limit?: number
  }

  /**
   * test_result.student
   */
  export type test_result$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    where?: studentWhereInput
  }

  /**
   * test_result without action
   */
  export type test_resultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the test_result
     */
    select?: test_resultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the test_result
     */
    omit?: test_resultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: test_resultInclude<ExtArgs> | null
  }


  /**
   * Model classes
   */

  export type AggregateClasses = {
    _count: ClassesCountAggregateOutputType | null
    _min: ClassesMinAggregateOutputType | null
    _max: ClassesMaxAggregateOutputType | null
  }

  export type ClassesMinAggregateOutputType = {
    class_code: string | null
    class_name: string | null
    class_base: string | null
  }

  export type ClassesMaxAggregateOutputType = {
    class_code: string | null
    class_name: string | null
    class_base: string | null
  }

  export type ClassesCountAggregateOutputType = {
    class_code: number
    class_name: number
    class_base: number
    _all: number
  }


  export type ClassesMinAggregateInputType = {
    class_code?: true
    class_name?: true
    class_base?: true
  }

  export type ClassesMaxAggregateInputType = {
    class_code?: true
    class_name?: true
    class_base?: true
  }

  export type ClassesCountAggregateInputType = {
    class_code?: true
    class_name?: true
    class_base?: true
    _all?: true
  }

  export type ClassesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which classes to aggregate.
     */
    where?: classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classes to fetch.
     */
    orderBy?: classesOrderByWithRelationInput | classesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned classes
    **/
    _count?: true | ClassesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassesMaxAggregateInputType
  }

  export type GetClassesAggregateType<T extends ClassesAggregateArgs> = {
        [P in keyof T & keyof AggregateClasses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClasses[P]>
      : GetScalarType<T[P], AggregateClasses[P]>
  }




  export type classesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: classesWhereInput
    orderBy?: classesOrderByWithAggregationInput | classesOrderByWithAggregationInput[]
    by: ClassesScalarFieldEnum[] | ClassesScalarFieldEnum
    having?: classesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassesCountAggregateInputType | true
    _min?: ClassesMinAggregateInputType
    _max?: ClassesMaxAggregateInputType
  }

  export type ClassesGroupByOutputType = {
    class_code: string
    class_name: string | null
    class_base: string | null
    _count: ClassesCountAggregateOutputType | null
    _min: ClassesMinAggregateOutputType | null
    _max: ClassesMaxAggregateOutputType | null
  }

  type GetClassesGroupByPayload<T extends classesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassesGroupByOutputType[P]>
            : GetScalarType<T[P], ClassesGroupByOutputType[P]>
        }
      >
    >


  export type classesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    class_code?: boolean
    class_name?: boolean
    class_base?: boolean
    active_class?: boolean | classes$active_classArgs<ExtArgs>
    _count?: boolean | ClassesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classes"]>



  export type classesSelectScalar = {
    class_code?: boolean
    class_name?: boolean
    class_base?: boolean
  }

  export type classesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"class_code" | "class_name" | "class_base", ExtArgs["result"]["classes"]>
  export type classesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    active_class?: boolean | classes$active_classArgs<ExtArgs>
    _count?: boolean | ClassesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $classesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "classes"
    objects: {
      active_class: Prisma.$active_classPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      class_code: string
      class_name: string | null
      class_base: string | null
    }, ExtArgs["result"]["classes"]>
    composites: {}
  }

  type classesGetPayload<S extends boolean | null | undefined | classesDefaultArgs> = $Result.GetResult<Prisma.$classesPayload, S>

  type classesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<classesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassesCountAggregateInputType | true
    }

  export interface classesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['classes'], meta: { name: 'classes' } }
    /**
     * Find zero or one Classes that matches the filter.
     * @param {classesFindUniqueArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends classesFindUniqueArgs>(args: SelectSubset<T, classesFindUniqueArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Classes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {classesFindUniqueOrThrowArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends classesFindUniqueOrThrowArgs>(args: SelectSubset<T, classesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesFindFirstArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends classesFindFirstArgs>(args?: SelectSubset<T, classesFindFirstArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Classes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesFindFirstOrThrowArgs} args - Arguments to find a Classes
     * @example
     * // Get one Classes
     * const classes = await prisma.classes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends classesFindFirstOrThrowArgs>(args?: SelectSubset<T, classesFindFirstOrThrowArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.classes.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.classes.findMany({ take: 10 })
     * 
     * // Only select the `class_code`
     * const classesWithClass_codeOnly = await prisma.classes.findMany({ select: { class_code: true } })
     * 
     */
    findMany<T extends classesFindManyArgs>(args?: SelectSubset<T, classesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Classes.
     * @param {classesCreateArgs} args - Arguments to create a Classes.
     * @example
     * // Create one Classes
     * const Classes = await prisma.classes.create({
     *   data: {
     *     // ... data to create a Classes
     *   }
     * })
     * 
     */
    create<T extends classesCreateArgs>(args: SelectSubset<T, classesCreateArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classes.
     * @param {classesCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const classes = await prisma.classes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends classesCreateManyArgs>(args?: SelectSubset<T, classesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Classes.
     * @param {classesDeleteArgs} args - Arguments to delete one Classes.
     * @example
     * // Delete one Classes
     * const Classes = await prisma.classes.delete({
     *   where: {
     *     // ... filter to delete one Classes
     *   }
     * })
     * 
     */
    delete<T extends classesDeleteArgs>(args: SelectSubset<T, classesDeleteArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Classes.
     * @param {classesUpdateArgs} args - Arguments to update one Classes.
     * @example
     * // Update one Classes
     * const classes = await prisma.classes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends classesUpdateArgs>(args: SelectSubset<T, classesUpdateArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classes.
     * @param {classesDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.classes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends classesDeleteManyArgs>(args?: SelectSubset<T, classesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const classes = await prisma.classes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends classesUpdateManyArgs>(args: SelectSubset<T, classesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Classes.
     * @param {classesUpsertArgs} args - Arguments to update or create a Classes.
     * @example
     * // Update or create a Classes
     * const classes = await prisma.classes.upsert({
     *   create: {
     *     // ... data to create a Classes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Classes we want to update
     *   }
     * })
     */
    upsert<T extends classesUpsertArgs>(args: SelectSubset<T, classesUpsertArgs<ExtArgs>>): Prisma__classesClient<$Result.GetResult<Prisma.$classesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.classes.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends classesCountArgs>(
      args?: Subset<T, classesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassesAggregateArgs>(args: Subset<T, ClassesAggregateArgs>): Prisma.PrismaPromise<GetClassesAggregateType<T>>

    /**
     * Group by Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends classesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: classesGroupByArgs['orderBy'] }
        : { orderBy?: classesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, classesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the classes model
   */
  readonly fields: classesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for classes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__classesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    active_class<T extends classes$active_classArgs<ExtArgs> = {}>(args?: Subset<T, classes$active_classArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$active_classPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the classes model
   */
  interface classesFieldRefs {
    readonly class_code: FieldRef<"classes", 'String'>
    readonly class_name: FieldRef<"classes", 'String'>
    readonly class_base: FieldRef<"classes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * classes findUnique
   */
  export type classesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * Filter, which classes to fetch.
     */
    where: classesWhereUniqueInput
  }

  /**
   * classes findUniqueOrThrow
   */
  export type classesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * Filter, which classes to fetch.
     */
    where: classesWhereUniqueInput
  }

  /**
   * classes findFirst
   */
  export type classesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * Filter, which classes to fetch.
     */
    where?: classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classes to fetch.
     */
    orderBy?: classesOrderByWithRelationInput | classesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for classes.
     */
    cursor?: classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of classes.
     */
    distinct?: ClassesScalarFieldEnum | ClassesScalarFieldEnum[]
  }

  /**
   * classes findFirstOrThrow
   */
  export type classesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * Filter, which classes to fetch.
     */
    where?: classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classes to fetch.
     */
    orderBy?: classesOrderByWithRelationInput | classesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for classes.
     */
    cursor?: classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of classes.
     */
    distinct?: ClassesScalarFieldEnum | ClassesScalarFieldEnum[]
  }

  /**
   * classes findMany
   */
  export type classesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * Filter, which classes to fetch.
     */
    where?: classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classes to fetch.
     */
    orderBy?: classesOrderByWithRelationInput | classesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing classes.
     */
    cursor?: classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classes.
     */
    skip?: number
    distinct?: ClassesScalarFieldEnum | ClassesScalarFieldEnum[]
  }

  /**
   * classes create
   */
  export type classesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * The data needed to create a classes.
     */
    data: XOR<classesCreateInput, classesUncheckedCreateInput>
  }

  /**
   * classes createMany
   */
  export type classesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many classes.
     */
    data: classesCreateManyInput | classesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * classes update
   */
  export type classesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * The data needed to update a classes.
     */
    data: XOR<classesUpdateInput, classesUncheckedUpdateInput>
    /**
     * Choose, which classes to update.
     */
    where: classesWhereUniqueInput
  }

  /**
   * classes updateMany
   */
  export type classesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update classes.
     */
    data: XOR<classesUpdateManyMutationInput, classesUncheckedUpdateManyInput>
    /**
     * Filter which classes to update
     */
    where?: classesWhereInput
    /**
     * Limit how many classes to update.
     */
    limit?: number
  }

  /**
   * classes upsert
   */
  export type classesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * The filter to search for the classes to update in case it exists.
     */
    where: classesWhereUniqueInput
    /**
     * In case the classes found by the `where` argument doesn't exist, create a new classes with this data.
     */
    create: XOR<classesCreateInput, classesUncheckedCreateInput>
    /**
     * In case the classes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<classesUpdateInput, classesUncheckedUpdateInput>
  }

  /**
   * classes delete
   */
  export type classesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
    /**
     * Filter which classes to delete.
     */
    where: classesWhereUniqueInput
  }

  /**
   * classes deleteMany
   */
  export type classesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which classes to delete
     */
    where?: classesWhereInput
    /**
     * Limit how many classes to delete.
     */
    limit?: number
  }

  /**
   * classes.active_class
   */
  export type classes$active_classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_class
     */
    select?: active_classSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_class
     */
    omit?: active_classOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_classInclude<ExtArgs> | null
    where?: active_classWhereInput
    orderBy?: active_classOrderByWithRelationInput | active_classOrderByWithRelationInput[]
    cursor?: active_classWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Active_classScalarFieldEnum | Active_classScalarFieldEnum[]
  }

  /**
   * classes without action
   */
  export type classesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classes
     */
    select?: classesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classes
     */
    omit?: classesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classesInclude<ExtArgs> | null
  }


  /**
   * Model parent_form
   */

  export type AggregateParent_form = {
    _count: Parent_formCountAggregateOutputType | null
    _avg: Parent_formAvgAggregateOutputType | null
    _sum: Parent_formSumAggregateOutputType | null
    _min: Parent_formMinAggregateOutputType | null
    _max: Parent_formMaxAggregateOutputType | null
  }

  export type Parent_formAvgAggregateOutputType = {
    parent_form_id: number | null
  }

  export type Parent_formSumAggregateOutputType = {
    parent_form_id: number | null
  }

  export type Parent_formMinAggregateOutputType = {
    parent_form_id: number | null
    parent_form_content: Uint8Array | null
    parent_form_created: Date | null
  }

  export type Parent_formMaxAggregateOutputType = {
    parent_form_id: number | null
    parent_form_content: Uint8Array | null
    parent_form_created: Date | null
  }

  export type Parent_formCountAggregateOutputType = {
    parent_form_id: number
    parent_form_content: number
    parent_form_created: number
    _all: number
  }


  export type Parent_formAvgAggregateInputType = {
    parent_form_id?: true
  }

  export type Parent_formSumAggregateInputType = {
    parent_form_id?: true
  }

  export type Parent_formMinAggregateInputType = {
    parent_form_id?: true
    parent_form_content?: true
    parent_form_created?: true
  }

  export type Parent_formMaxAggregateInputType = {
    parent_form_id?: true
    parent_form_content?: true
    parent_form_created?: true
  }

  export type Parent_formCountAggregateInputType = {
    parent_form_id?: true
    parent_form_content?: true
    parent_form_created?: true
    _all?: true
  }

  export type Parent_formAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parent_form to aggregate.
     */
    where?: parent_formWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parent_forms to fetch.
     */
    orderBy?: parent_formOrderByWithRelationInput | parent_formOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: parent_formWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parent_forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parent_forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parent_forms
    **/
    _count?: true | Parent_formCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Parent_formAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Parent_formSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Parent_formMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Parent_formMaxAggregateInputType
  }

  export type GetParent_formAggregateType<T extends Parent_formAggregateArgs> = {
        [P in keyof T & keyof AggregateParent_form]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParent_form[P]>
      : GetScalarType<T[P], AggregateParent_form[P]>
  }




  export type parent_formGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: parent_formWhereInput
    orderBy?: parent_formOrderByWithAggregationInput | parent_formOrderByWithAggregationInput[]
    by: Parent_formScalarFieldEnum[] | Parent_formScalarFieldEnum
    having?: parent_formScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Parent_formCountAggregateInputType | true
    _avg?: Parent_formAvgAggregateInputType
    _sum?: Parent_formSumAggregateInputType
    _min?: Parent_formMinAggregateInputType
    _max?: Parent_formMaxAggregateInputType
  }

  export type Parent_formGroupByOutputType = {
    parent_form_id: number
    parent_form_content: Uint8Array
    parent_form_created: Date | null
    _count: Parent_formCountAggregateOutputType | null
    _avg: Parent_formAvgAggregateOutputType | null
    _sum: Parent_formSumAggregateOutputType | null
    _min: Parent_formMinAggregateOutputType | null
    _max: Parent_formMaxAggregateOutputType | null
  }

  type GetParent_formGroupByPayload<T extends parent_formGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Parent_formGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Parent_formGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Parent_formGroupByOutputType[P]>
            : GetScalarType<T[P], Parent_formGroupByOutputType[P]>
        }
      >
    >


  export type parent_formSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    parent_form_id?: boolean
    parent_form_content?: boolean
    parent_form_created?: boolean
  }, ExtArgs["result"]["parent_form"]>



  export type parent_formSelectScalar = {
    parent_form_id?: boolean
    parent_form_content?: boolean
    parent_form_created?: boolean
  }

  export type parent_formOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"parent_form_id" | "parent_form_content" | "parent_form_created", ExtArgs["result"]["parent_form"]>

  export type $parent_formPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "parent_form"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      parent_form_id: number
      parent_form_content: Uint8Array
      parent_form_created: Date | null
    }, ExtArgs["result"]["parent_form"]>
    composites: {}
  }

  type parent_formGetPayload<S extends boolean | null | undefined | parent_formDefaultArgs> = $Result.GetResult<Prisma.$parent_formPayload, S>

  type parent_formCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<parent_formFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Parent_formCountAggregateInputType | true
    }

  export interface parent_formDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['parent_form'], meta: { name: 'parent_form' } }
    /**
     * Find zero or one Parent_form that matches the filter.
     * @param {parent_formFindUniqueArgs} args - Arguments to find a Parent_form
     * @example
     * // Get one Parent_form
     * const parent_form = await prisma.parent_form.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends parent_formFindUniqueArgs>(args: SelectSubset<T, parent_formFindUniqueArgs<ExtArgs>>): Prisma__parent_formClient<$Result.GetResult<Prisma.$parent_formPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Parent_form that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {parent_formFindUniqueOrThrowArgs} args - Arguments to find a Parent_form
     * @example
     * // Get one Parent_form
     * const parent_form = await prisma.parent_form.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends parent_formFindUniqueOrThrowArgs>(args: SelectSubset<T, parent_formFindUniqueOrThrowArgs<ExtArgs>>): Prisma__parent_formClient<$Result.GetResult<Prisma.$parent_formPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parent_form that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parent_formFindFirstArgs} args - Arguments to find a Parent_form
     * @example
     * // Get one Parent_form
     * const parent_form = await prisma.parent_form.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends parent_formFindFirstArgs>(args?: SelectSubset<T, parent_formFindFirstArgs<ExtArgs>>): Prisma__parent_formClient<$Result.GetResult<Prisma.$parent_formPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parent_form that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parent_formFindFirstOrThrowArgs} args - Arguments to find a Parent_form
     * @example
     * // Get one Parent_form
     * const parent_form = await prisma.parent_form.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends parent_formFindFirstOrThrowArgs>(args?: SelectSubset<T, parent_formFindFirstOrThrowArgs<ExtArgs>>): Prisma__parent_formClient<$Result.GetResult<Prisma.$parent_formPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parent_forms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parent_formFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parent_forms
     * const parent_forms = await prisma.parent_form.findMany()
     * 
     * // Get first 10 Parent_forms
     * const parent_forms = await prisma.parent_form.findMany({ take: 10 })
     * 
     * // Only select the `parent_form_id`
     * const parent_formWithParent_form_idOnly = await prisma.parent_form.findMany({ select: { parent_form_id: true } })
     * 
     */
    findMany<T extends parent_formFindManyArgs>(args?: SelectSubset<T, parent_formFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parent_formPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Parent_form.
     * @param {parent_formCreateArgs} args - Arguments to create a Parent_form.
     * @example
     * // Create one Parent_form
     * const Parent_form = await prisma.parent_form.create({
     *   data: {
     *     // ... data to create a Parent_form
     *   }
     * })
     * 
     */
    create<T extends parent_formCreateArgs>(args: SelectSubset<T, parent_formCreateArgs<ExtArgs>>): Prisma__parent_formClient<$Result.GetResult<Prisma.$parent_formPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parent_forms.
     * @param {parent_formCreateManyArgs} args - Arguments to create many Parent_forms.
     * @example
     * // Create many Parent_forms
     * const parent_form = await prisma.parent_form.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends parent_formCreateManyArgs>(args?: SelectSubset<T, parent_formCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Parent_form.
     * @param {parent_formDeleteArgs} args - Arguments to delete one Parent_form.
     * @example
     * // Delete one Parent_form
     * const Parent_form = await prisma.parent_form.delete({
     *   where: {
     *     // ... filter to delete one Parent_form
     *   }
     * })
     * 
     */
    delete<T extends parent_formDeleteArgs>(args: SelectSubset<T, parent_formDeleteArgs<ExtArgs>>): Prisma__parent_formClient<$Result.GetResult<Prisma.$parent_formPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Parent_form.
     * @param {parent_formUpdateArgs} args - Arguments to update one Parent_form.
     * @example
     * // Update one Parent_form
     * const parent_form = await prisma.parent_form.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends parent_formUpdateArgs>(args: SelectSubset<T, parent_formUpdateArgs<ExtArgs>>): Prisma__parent_formClient<$Result.GetResult<Prisma.$parent_formPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parent_forms.
     * @param {parent_formDeleteManyArgs} args - Arguments to filter Parent_forms to delete.
     * @example
     * // Delete a few Parent_forms
     * const { count } = await prisma.parent_form.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends parent_formDeleteManyArgs>(args?: SelectSubset<T, parent_formDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parent_forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parent_formUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parent_forms
     * const parent_form = await prisma.parent_form.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends parent_formUpdateManyArgs>(args: SelectSubset<T, parent_formUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parent_form.
     * @param {parent_formUpsertArgs} args - Arguments to update or create a Parent_form.
     * @example
     * // Update or create a Parent_form
     * const parent_form = await prisma.parent_form.upsert({
     *   create: {
     *     // ... data to create a Parent_form
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parent_form we want to update
     *   }
     * })
     */
    upsert<T extends parent_formUpsertArgs>(args: SelectSubset<T, parent_formUpsertArgs<ExtArgs>>): Prisma__parent_formClient<$Result.GetResult<Prisma.$parent_formPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parent_forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parent_formCountArgs} args - Arguments to filter Parent_forms to count.
     * @example
     * // Count the number of Parent_forms
     * const count = await prisma.parent_form.count({
     *   where: {
     *     // ... the filter for the Parent_forms we want to count
     *   }
     * })
    **/
    count<T extends parent_formCountArgs>(
      args?: Subset<T, parent_formCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Parent_formCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parent_form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Parent_formAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Parent_formAggregateArgs>(args: Subset<T, Parent_formAggregateArgs>): Prisma.PrismaPromise<GetParent_formAggregateType<T>>

    /**
     * Group by Parent_form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parent_formGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends parent_formGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: parent_formGroupByArgs['orderBy'] }
        : { orderBy?: parent_formGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, parent_formGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParent_formGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the parent_form model
   */
  readonly fields: parent_formFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for parent_form.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__parent_formClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the parent_form model
   */
  interface parent_formFieldRefs {
    readonly parent_form_id: FieldRef<"parent_form", 'Int'>
    readonly parent_form_content: FieldRef<"parent_form", 'Bytes'>
    readonly parent_form_created: FieldRef<"parent_form", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * parent_form findUnique
   */
  export type parent_formFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_form
     */
    select?: parent_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_form
     */
    omit?: parent_formOmit<ExtArgs> | null
    /**
     * Filter, which parent_form to fetch.
     */
    where: parent_formWhereUniqueInput
  }

  /**
   * parent_form findUniqueOrThrow
   */
  export type parent_formFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_form
     */
    select?: parent_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_form
     */
    omit?: parent_formOmit<ExtArgs> | null
    /**
     * Filter, which parent_form to fetch.
     */
    where: parent_formWhereUniqueInput
  }

  /**
   * parent_form findFirst
   */
  export type parent_formFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_form
     */
    select?: parent_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_form
     */
    omit?: parent_formOmit<ExtArgs> | null
    /**
     * Filter, which parent_form to fetch.
     */
    where?: parent_formWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parent_forms to fetch.
     */
    orderBy?: parent_formOrderByWithRelationInput | parent_formOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parent_forms.
     */
    cursor?: parent_formWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parent_forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parent_forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parent_forms.
     */
    distinct?: Parent_formScalarFieldEnum | Parent_formScalarFieldEnum[]
  }

  /**
   * parent_form findFirstOrThrow
   */
  export type parent_formFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_form
     */
    select?: parent_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_form
     */
    omit?: parent_formOmit<ExtArgs> | null
    /**
     * Filter, which parent_form to fetch.
     */
    where?: parent_formWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parent_forms to fetch.
     */
    orderBy?: parent_formOrderByWithRelationInput | parent_formOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parent_forms.
     */
    cursor?: parent_formWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parent_forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parent_forms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parent_forms.
     */
    distinct?: Parent_formScalarFieldEnum | Parent_formScalarFieldEnum[]
  }

  /**
   * parent_form findMany
   */
  export type parent_formFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_form
     */
    select?: parent_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_form
     */
    omit?: parent_formOmit<ExtArgs> | null
    /**
     * Filter, which parent_forms to fetch.
     */
    where?: parent_formWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parent_forms to fetch.
     */
    orderBy?: parent_formOrderByWithRelationInput | parent_formOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parent_forms.
     */
    cursor?: parent_formWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parent_forms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parent_forms.
     */
    skip?: number
    distinct?: Parent_formScalarFieldEnum | Parent_formScalarFieldEnum[]
  }

  /**
   * parent_form create
   */
  export type parent_formCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_form
     */
    select?: parent_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_form
     */
    omit?: parent_formOmit<ExtArgs> | null
    /**
     * The data needed to create a parent_form.
     */
    data: XOR<parent_formCreateInput, parent_formUncheckedCreateInput>
  }

  /**
   * parent_form createMany
   */
  export type parent_formCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many parent_forms.
     */
    data: parent_formCreateManyInput | parent_formCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * parent_form update
   */
  export type parent_formUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_form
     */
    select?: parent_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_form
     */
    omit?: parent_formOmit<ExtArgs> | null
    /**
     * The data needed to update a parent_form.
     */
    data: XOR<parent_formUpdateInput, parent_formUncheckedUpdateInput>
    /**
     * Choose, which parent_form to update.
     */
    where: parent_formWhereUniqueInput
  }

  /**
   * parent_form updateMany
   */
  export type parent_formUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update parent_forms.
     */
    data: XOR<parent_formUpdateManyMutationInput, parent_formUncheckedUpdateManyInput>
    /**
     * Filter which parent_forms to update
     */
    where?: parent_formWhereInput
    /**
     * Limit how many parent_forms to update.
     */
    limit?: number
  }

  /**
   * parent_form upsert
   */
  export type parent_formUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_form
     */
    select?: parent_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_form
     */
    omit?: parent_formOmit<ExtArgs> | null
    /**
     * The filter to search for the parent_form to update in case it exists.
     */
    where: parent_formWhereUniqueInput
    /**
     * In case the parent_form found by the `where` argument doesn't exist, create a new parent_form with this data.
     */
    create: XOR<parent_formCreateInput, parent_formUncheckedCreateInput>
    /**
     * In case the parent_form was found with the provided `where` argument, update it with this data.
     */
    update: XOR<parent_formUpdateInput, parent_formUncheckedUpdateInput>
  }

  /**
   * parent_form delete
   */
  export type parent_formDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_form
     */
    select?: parent_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_form
     */
    omit?: parent_formOmit<ExtArgs> | null
    /**
     * Filter which parent_form to delete.
     */
    where: parent_formWhereUniqueInput
  }

  /**
   * parent_form deleteMany
   */
  export type parent_formDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parent_forms to delete
     */
    where?: parent_formWhereInput
    /**
     * Limit how many parent_forms to delete.
     */
    limit?: number
  }

  /**
   * parent_form without action
   */
  export type parent_formDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_form
     */
    select?: parent_formSelect<ExtArgs> | null
    /**
     * Omit specific fields from the parent_form
     */
    omit?: parent_formOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Active_classScalarFieldEnum: {
    active_class_id: 'active_class_id',
    class_code: 'class_code',
    period: 'period',
    class_coordinator: 'class_coordinator'
  };

  export type Active_classScalarFieldEnum = (typeof Active_classScalarFieldEnum)[keyof typeof Active_classScalarFieldEnum]


  export const AgendaScalarFieldEnum: {
    agenda_id: 'agenda_id',
    subject_class_id: 'subject_class_id',
    agenda_title: 'agenda_title',
    agenda_context: 'agenda_context',
    agenda_annouced: 'agenda_annouced',
    agenda_due: 'agenda_due'
  };

  export type AgendaScalarFieldEnum = (typeof AgendaScalarFieldEnum)[keyof typeof AgendaScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    employee_id: 'employee_id',
    employee_fn: 'employee_fn',
    employee_ln: 'employee_ln',
    employee_dob: 'employee_dob',
    employee_join: 'employee_join',
    employee_img: 'employee_img',
    employee_info: 'employee_info',
    employee_degree: 'employee_degree',
    employee_exp: 'employee_exp',
    employee_sal1: 'employee_sal1',
    employee_sal2: 'employee_sal2',
    employee_wh: 'employee_wh'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const Employee_roleScalarFieldEnum: {
    employee_role_id: 'employee_role_id',
    role_id: 'role_id',
    employee_id: 'employee_id'
  };

  export type Employee_roleScalarFieldEnum = (typeof Employee_roleScalarFieldEnum)[keyof typeof Employee_roleScalarFieldEnum]


  export const Final_gradeScalarFieldEnum: {
    final_grade_id: 'final_grade_id',
    subject_code: 'subject_code',
    final_grade: 'final_grade',
    student_id: 'student_id',
    test_period: 'test_period',
    created_at: 'created_at',
    final_status: 'final_status'
  };

  export type Final_gradeScalarFieldEnum = (typeof Final_gradeScalarFieldEnum)[keyof typeof Final_gradeScalarFieldEnum]


  export const JobScalarFieldEnum: {
    job_id: 'job_id',
    parent_id: 'parent_id',
    job_company: 'job_company',
    job_title: 'job_title',
    work_email: 'work_email',
    work_number: 'work_number'
  };

  export type JobScalarFieldEnum = (typeof JobScalarFieldEnum)[keyof typeof JobScalarFieldEnum]


  export const ParentScalarFieldEnum: {
    parent_id: 'parent_id',
    parent_fn: 'parent_fn',
    parent_ln: 'parent_ln',
    parent_dob: 'parent_dob',
    parent_pers_number: 'parent_pers_number',
    parent_pers_email: 'parent_pers_email'
  };

  export type ParentScalarFieldEnum = (typeof ParentScalarFieldEnum)[keyof typeof ParentScalarFieldEnum]


  export const PeriodScalarFieldEnum: {
    period: 'period',
    period_status: 'period_status'
  };

  export type PeriodScalarFieldEnum = (typeof PeriodScalarFieldEnum)[keyof typeof PeriodScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    role_id: 'role_id',
    role_name: 'role_name',
    role_description: 'role_description'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const School_emailScalarFieldEnum: {
    school_num_id: 'school_num_id',
    school_reg: 'school_reg',
    school_email: 'school_email',
    school_email_label: 'school_email_label'
  };

  export type School_emailScalarFieldEnum = (typeof School_emailScalarFieldEnum)[keyof typeof School_emailScalarFieldEnum]


  export const School_infoScalarFieldEnum: {
    school_reg: 'school_reg',
    school_name: 'school_name',
    school_address: 'school_address',
    school_lat: 'school_lat',
    school_long: 'school_long',
    school_princ: 'school_princ'
  };

  export type School_infoScalarFieldEnum = (typeof School_infoScalarFieldEnum)[keyof typeof School_infoScalarFieldEnum]


  export const School_numScalarFieldEnum: {
    school_num_id: 'school_num_id',
    school_reg: 'school_reg',
    school_phone: 'school_phone',
    school_phone_label: 'school_phone_label'
  };

  export type School_numScalarFieldEnum = (typeof School_numScalarFieldEnum)[keyof typeof School_numScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    student_id: 'student_id',
    mother_id: 'mother_id',
    father_id: 'father_id',
    student_fname: 'student_fname',
    student_lname: 'student_lname',
    student_dob: 'student_dob',
    student_account: 'student_account',
    student_pass: 'student_pass',
    note: 'note'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const Subject_classScalarFieldEnum: {
    subject_class_id: 'subject_class_id',
    subject_code: 'subject_code',
    instructor: 'instructor'
  };

  export type Subject_classScalarFieldEnum = (typeof Subject_classScalarFieldEnum)[keyof typeof Subject_classScalarFieldEnum]


  export const SubjectsScalarFieldEnum: {
    subject_code: 'subject_code',
    subject_name: 'subject_name',
    subject_cat: 'subject_cat'
  };

  export type SubjectsScalarFieldEnum = (typeof SubjectsScalarFieldEnum)[keyof typeof SubjectsScalarFieldEnum]


  export const TestScalarFieldEnum: {
    test_id: 'test_id',
    test_title: 'test_title',
    test_description: 'test_description',
    subject_class_id: 'subject_class_id',
    test_total: 'test_total',
    test_visibility: 'test_visibility',
    test_annouced: 'test_annouced',
    test_due: 'test_due',
    test_period: 'test_period'
  };

  export type TestScalarFieldEnum = (typeof TestScalarFieldEnum)[keyof typeof TestScalarFieldEnum]


  export const Test_resultScalarFieldEnum: {
    test_result_id: 'test_result_id',
    test_id: 'test_id',
    student_id: 'student_id',
    test_result: 'test_result',
    test_note: 'test_note'
  };

  export type Test_resultScalarFieldEnum = (typeof Test_resultScalarFieldEnum)[keyof typeof Test_resultScalarFieldEnum]


  export const ClassesScalarFieldEnum: {
    class_code: 'class_code',
    class_name: 'class_name',
    class_base: 'class_base'
  };

  export type ClassesScalarFieldEnum = (typeof ClassesScalarFieldEnum)[keyof typeof ClassesScalarFieldEnum]


  export const Parent_formScalarFieldEnum: {
    parent_form_id: 'parent_form_id',
    parent_form_content: 'parent_form_content',
    parent_form_created: 'parent_form_created'
  };

  export type Parent_formScalarFieldEnum = (typeof Parent_formScalarFieldEnum)[keyof typeof Parent_formScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const active_classOrderByRelevanceFieldEnum: {
    class_code: 'class_code'
  };

  export type active_classOrderByRelevanceFieldEnum = (typeof active_classOrderByRelevanceFieldEnum)[keyof typeof active_classOrderByRelevanceFieldEnum]


  export const agendaOrderByRelevanceFieldEnum: {
    agenda_title: 'agenda_title',
    agenda_context: 'agenda_context'
  };

  export type agendaOrderByRelevanceFieldEnum = (typeof agendaOrderByRelevanceFieldEnum)[keyof typeof agendaOrderByRelevanceFieldEnum]


  export const employeeOrderByRelevanceFieldEnum: {
    employee_fn: 'employee_fn',
    employee_ln: 'employee_ln',
    employee_img: 'employee_img',
    employee_info: 'employee_info',
    employee_degree: 'employee_degree'
  };

  export type employeeOrderByRelevanceFieldEnum = (typeof employeeOrderByRelevanceFieldEnum)[keyof typeof employeeOrderByRelevanceFieldEnum]


  export const final_gradeOrderByRelevanceFieldEnum: {
    subject_code: 'subject_code',
    student_id: 'student_id',
    final_status: 'final_status'
  };

  export type final_gradeOrderByRelevanceFieldEnum = (typeof final_gradeOrderByRelevanceFieldEnum)[keyof typeof final_gradeOrderByRelevanceFieldEnum]


  export const jobOrderByRelevanceFieldEnum: {
    job_company: 'job_company',
    job_title: 'job_title',
    work_email: 'work_email',
    work_number: 'work_number'
  };

  export type jobOrderByRelevanceFieldEnum = (typeof jobOrderByRelevanceFieldEnum)[keyof typeof jobOrderByRelevanceFieldEnum]


  export const parentOrderByRelevanceFieldEnum: {
    parent_fn: 'parent_fn',
    parent_ln: 'parent_ln',
    parent_pers_number: 'parent_pers_number',
    parent_pers_email: 'parent_pers_email'
  };

  export type parentOrderByRelevanceFieldEnum = (typeof parentOrderByRelevanceFieldEnum)[keyof typeof parentOrderByRelevanceFieldEnum]


  export const periodOrderByRelevanceFieldEnum: {
    period_status: 'period_status'
  };

  export type periodOrderByRelevanceFieldEnum = (typeof periodOrderByRelevanceFieldEnum)[keyof typeof periodOrderByRelevanceFieldEnum]


  export const rolesOrderByRelevanceFieldEnum: {
    role_name: 'role_name',
    role_description: 'role_description'
  };

  export type rolesOrderByRelevanceFieldEnum = (typeof rolesOrderByRelevanceFieldEnum)[keyof typeof rolesOrderByRelevanceFieldEnum]


  export const school_emailOrderByRelevanceFieldEnum: {
    school_email: 'school_email',
    school_email_label: 'school_email_label'
  };

  export type school_emailOrderByRelevanceFieldEnum = (typeof school_emailOrderByRelevanceFieldEnum)[keyof typeof school_emailOrderByRelevanceFieldEnum]


  export const school_infoOrderByRelevanceFieldEnum: {
    school_name: 'school_name',
    school_address: 'school_address',
    school_princ: 'school_princ'
  };

  export type school_infoOrderByRelevanceFieldEnum = (typeof school_infoOrderByRelevanceFieldEnum)[keyof typeof school_infoOrderByRelevanceFieldEnum]


  export const school_numOrderByRelevanceFieldEnum: {
    school_phone: 'school_phone',
    school_phone_label: 'school_phone_label'
  };

  export type school_numOrderByRelevanceFieldEnum = (typeof school_numOrderByRelevanceFieldEnum)[keyof typeof school_numOrderByRelevanceFieldEnum]


  export const studentOrderByRelevanceFieldEnum: {
    student_id: 'student_id',
    student_fname: 'student_fname',
    student_lname: 'student_lname',
    student_account: 'student_account',
    student_pass: 'student_pass',
    note: 'note'
  };

  export type studentOrderByRelevanceFieldEnum = (typeof studentOrderByRelevanceFieldEnum)[keyof typeof studentOrderByRelevanceFieldEnum]


  export const subject_classOrderByRelevanceFieldEnum: {
    subject_code: 'subject_code'
  };

  export type subject_classOrderByRelevanceFieldEnum = (typeof subject_classOrderByRelevanceFieldEnum)[keyof typeof subject_classOrderByRelevanceFieldEnum]


  export const subjectsOrderByRelevanceFieldEnum: {
    subject_code: 'subject_code',
    subject_name: 'subject_name'
  };

  export type subjectsOrderByRelevanceFieldEnum = (typeof subjectsOrderByRelevanceFieldEnum)[keyof typeof subjectsOrderByRelevanceFieldEnum]


  export const testOrderByRelevanceFieldEnum: {
    test_title: 'test_title',
    test_description: 'test_description',
    test_visibility: 'test_visibility'
  };

  export type testOrderByRelevanceFieldEnum = (typeof testOrderByRelevanceFieldEnum)[keyof typeof testOrderByRelevanceFieldEnum]


  export const test_resultOrderByRelevanceFieldEnum: {
    student_id: 'student_id',
    test_note: 'test_note'
  };

  export type test_resultOrderByRelevanceFieldEnum = (typeof test_resultOrderByRelevanceFieldEnum)[keyof typeof test_resultOrderByRelevanceFieldEnum]


  export const classesOrderByRelevanceFieldEnum: {
    class_code: 'class_code',
    class_name: 'class_name',
    class_base: 'class_base'
  };

  export type classesOrderByRelevanceFieldEnum = (typeof classesOrderByRelevanceFieldEnum)[keyof typeof classesOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'final_grade_test_period'
   */
  export type Enumfinal_grade_test_periodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'final_grade_test_period'>
    


  /**
   * Reference to a field of type 'subjects_subject_cat'
   */
  export type Enumsubjects_subject_catFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'subjects_subject_cat'>
    


  /**
   * Reference to a field of type 'test_test_period'
   */
  export type Enumtest_test_periodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'test_test_period'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    
  /**
   * Deep Input Types
   */


  export type active_classWhereInput = {
    AND?: active_classWhereInput | active_classWhereInput[]
    OR?: active_classWhereInput[]
    NOT?: active_classWhereInput | active_classWhereInput[]
    active_class_id?: IntFilter<"active_class"> | number
    class_code?: StringNullableFilter<"active_class"> | string | null
    period?: IntNullableFilter<"active_class"> | number | null
    class_coordinator?: IntNullableFilter<"active_class"> | number | null
    Renamedclass?: XOR<ClassesNullableScalarRelationFilter, classesWhereInput> | null
    period_active_class_periodToperiod?: XOR<PeriodNullableScalarRelationFilter, periodWhereInput> | null
    employee?: XOR<EmployeeNullableScalarRelationFilter, employeeWhereInput> | null
  }

  export type active_classOrderByWithRelationInput = {
    active_class_id?: SortOrder
    class_code?: SortOrderInput | SortOrder
    period?: SortOrderInput | SortOrder
    class_coordinator?: SortOrderInput | SortOrder
    Renamedclass?: classesOrderByWithRelationInput
    period_active_class_periodToperiod?: periodOrderByWithRelationInput
    employee?: employeeOrderByWithRelationInput
    _relevance?: active_classOrderByRelevanceInput
  }

  export type active_classWhereUniqueInput = Prisma.AtLeast<{
    active_class_id?: number
    AND?: active_classWhereInput | active_classWhereInput[]
    OR?: active_classWhereInput[]
    NOT?: active_classWhereInput | active_classWhereInput[]
    class_code?: StringNullableFilter<"active_class"> | string | null
    period?: IntNullableFilter<"active_class"> | number | null
    class_coordinator?: IntNullableFilter<"active_class"> | number | null
    Renamedclass?: XOR<ClassesNullableScalarRelationFilter, classesWhereInput> | null
    period_active_class_periodToperiod?: XOR<PeriodNullableScalarRelationFilter, periodWhereInput> | null
    employee?: XOR<EmployeeNullableScalarRelationFilter, employeeWhereInput> | null
  }, "active_class_id">

  export type active_classOrderByWithAggregationInput = {
    active_class_id?: SortOrder
    class_code?: SortOrderInput | SortOrder
    period?: SortOrderInput | SortOrder
    class_coordinator?: SortOrderInput | SortOrder
    _count?: active_classCountOrderByAggregateInput
    _avg?: active_classAvgOrderByAggregateInput
    _max?: active_classMaxOrderByAggregateInput
    _min?: active_classMinOrderByAggregateInput
    _sum?: active_classSumOrderByAggregateInput
  }

  export type active_classScalarWhereWithAggregatesInput = {
    AND?: active_classScalarWhereWithAggregatesInput | active_classScalarWhereWithAggregatesInput[]
    OR?: active_classScalarWhereWithAggregatesInput[]
    NOT?: active_classScalarWhereWithAggregatesInput | active_classScalarWhereWithAggregatesInput[]
    active_class_id?: IntWithAggregatesFilter<"active_class"> | number
    class_code?: StringNullableWithAggregatesFilter<"active_class"> | string | null
    period?: IntNullableWithAggregatesFilter<"active_class"> | number | null
    class_coordinator?: IntNullableWithAggregatesFilter<"active_class"> | number | null
  }

  export type agendaWhereInput = {
    AND?: agendaWhereInput | agendaWhereInput[]
    OR?: agendaWhereInput[]
    NOT?: agendaWhereInput | agendaWhereInput[]
    agenda_id?: IntFilter<"agenda"> | number
    subject_class_id?: IntNullableFilter<"agenda"> | number | null
    agenda_title?: StringFilter<"agenda"> | string
    agenda_context?: StringFilter<"agenda"> | string
    agenda_annouced?: DateTimeNullableFilter<"agenda"> | Date | string | null
    agenda_due?: DateTimeNullableFilter<"agenda"> | Date | string | null
    subject_class?: XOR<Subject_classNullableScalarRelationFilter, subject_classWhereInput> | null
  }

  export type agendaOrderByWithRelationInput = {
    agenda_id?: SortOrder
    subject_class_id?: SortOrderInput | SortOrder
    agenda_title?: SortOrder
    agenda_context?: SortOrder
    agenda_annouced?: SortOrderInput | SortOrder
    agenda_due?: SortOrderInput | SortOrder
    subject_class?: subject_classOrderByWithRelationInput
    _relevance?: agendaOrderByRelevanceInput
  }

  export type agendaWhereUniqueInput = Prisma.AtLeast<{
    agenda_id?: number
    AND?: agendaWhereInput | agendaWhereInput[]
    OR?: agendaWhereInput[]
    NOT?: agendaWhereInput | agendaWhereInput[]
    subject_class_id?: IntNullableFilter<"agenda"> | number | null
    agenda_title?: StringFilter<"agenda"> | string
    agenda_context?: StringFilter<"agenda"> | string
    agenda_annouced?: DateTimeNullableFilter<"agenda"> | Date | string | null
    agenda_due?: DateTimeNullableFilter<"agenda"> | Date | string | null
    subject_class?: XOR<Subject_classNullableScalarRelationFilter, subject_classWhereInput> | null
  }, "agenda_id">

  export type agendaOrderByWithAggregationInput = {
    agenda_id?: SortOrder
    subject_class_id?: SortOrderInput | SortOrder
    agenda_title?: SortOrder
    agenda_context?: SortOrder
    agenda_annouced?: SortOrderInput | SortOrder
    agenda_due?: SortOrderInput | SortOrder
    _count?: agendaCountOrderByAggregateInput
    _avg?: agendaAvgOrderByAggregateInput
    _max?: agendaMaxOrderByAggregateInput
    _min?: agendaMinOrderByAggregateInput
    _sum?: agendaSumOrderByAggregateInput
  }

  export type agendaScalarWhereWithAggregatesInput = {
    AND?: agendaScalarWhereWithAggregatesInput | agendaScalarWhereWithAggregatesInput[]
    OR?: agendaScalarWhereWithAggregatesInput[]
    NOT?: agendaScalarWhereWithAggregatesInput | agendaScalarWhereWithAggregatesInput[]
    agenda_id?: IntWithAggregatesFilter<"agenda"> | number
    subject_class_id?: IntNullableWithAggregatesFilter<"agenda"> | number | null
    agenda_title?: StringWithAggregatesFilter<"agenda"> | string
    agenda_context?: StringWithAggregatesFilter<"agenda"> | string
    agenda_annouced?: DateTimeNullableWithAggregatesFilter<"agenda"> | Date | string | null
    agenda_due?: DateTimeNullableWithAggregatesFilter<"agenda"> | Date | string | null
  }

  export type employeeWhereInput = {
    AND?: employeeWhereInput | employeeWhereInput[]
    OR?: employeeWhereInput[]
    NOT?: employeeWhereInput | employeeWhereInput[]
    employee_id?: IntFilter<"employee"> | number
    employee_fn?: StringFilter<"employee"> | string
    employee_ln?: StringFilter<"employee"> | string
    employee_dob?: DateTimeFilter<"employee"> | Date | string
    employee_join?: DateTimeNullableFilter<"employee"> | Date | string | null
    employee_img?: StringNullableFilter<"employee"> | string | null
    employee_info?: StringNullableFilter<"employee"> | string | null
    employee_degree?: StringNullableFilter<"employee"> | string | null
    employee_exp?: DateTimeNullableFilter<"employee"> | Date | string | null
    employee_sal1?: FloatFilter<"employee"> | number
    employee_sal2?: FloatNullableFilter<"employee"> | number | null
    employee_wh?: FloatNullableFilter<"employee"> | number | null
    active_class?: Active_classListRelationFilter
    employee_role?: Employee_roleListRelationFilter
    subject_class?: Subject_classListRelationFilter
  }

  export type employeeOrderByWithRelationInput = {
    employee_id?: SortOrder
    employee_fn?: SortOrder
    employee_ln?: SortOrder
    employee_dob?: SortOrder
    employee_join?: SortOrderInput | SortOrder
    employee_img?: SortOrderInput | SortOrder
    employee_info?: SortOrderInput | SortOrder
    employee_degree?: SortOrderInput | SortOrder
    employee_exp?: SortOrderInput | SortOrder
    employee_sal1?: SortOrder
    employee_sal2?: SortOrderInput | SortOrder
    employee_wh?: SortOrderInput | SortOrder
    active_class?: active_classOrderByRelationAggregateInput
    employee_role?: employee_roleOrderByRelationAggregateInput
    subject_class?: subject_classOrderByRelationAggregateInput
    _relevance?: employeeOrderByRelevanceInput
  }

  export type employeeWhereUniqueInput = Prisma.AtLeast<{
    employee_id?: number
    AND?: employeeWhereInput | employeeWhereInput[]
    OR?: employeeWhereInput[]
    NOT?: employeeWhereInput | employeeWhereInput[]
    employee_fn?: StringFilter<"employee"> | string
    employee_ln?: StringFilter<"employee"> | string
    employee_dob?: DateTimeFilter<"employee"> | Date | string
    employee_join?: DateTimeNullableFilter<"employee"> | Date | string | null
    employee_img?: StringNullableFilter<"employee"> | string | null
    employee_info?: StringNullableFilter<"employee"> | string | null
    employee_degree?: StringNullableFilter<"employee"> | string | null
    employee_exp?: DateTimeNullableFilter<"employee"> | Date | string | null
    employee_sal1?: FloatFilter<"employee"> | number
    employee_sal2?: FloatNullableFilter<"employee"> | number | null
    employee_wh?: FloatNullableFilter<"employee"> | number | null
    active_class?: Active_classListRelationFilter
    employee_role?: Employee_roleListRelationFilter
    subject_class?: Subject_classListRelationFilter
  }, "employee_id">

  export type employeeOrderByWithAggregationInput = {
    employee_id?: SortOrder
    employee_fn?: SortOrder
    employee_ln?: SortOrder
    employee_dob?: SortOrder
    employee_join?: SortOrderInput | SortOrder
    employee_img?: SortOrderInput | SortOrder
    employee_info?: SortOrderInput | SortOrder
    employee_degree?: SortOrderInput | SortOrder
    employee_exp?: SortOrderInput | SortOrder
    employee_sal1?: SortOrder
    employee_sal2?: SortOrderInput | SortOrder
    employee_wh?: SortOrderInput | SortOrder
    _count?: employeeCountOrderByAggregateInput
    _avg?: employeeAvgOrderByAggregateInput
    _max?: employeeMaxOrderByAggregateInput
    _min?: employeeMinOrderByAggregateInput
    _sum?: employeeSumOrderByAggregateInput
  }

  export type employeeScalarWhereWithAggregatesInput = {
    AND?: employeeScalarWhereWithAggregatesInput | employeeScalarWhereWithAggregatesInput[]
    OR?: employeeScalarWhereWithAggregatesInput[]
    NOT?: employeeScalarWhereWithAggregatesInput | employeeScalarWhereWithAggregatesInput[]
    employee_id?: IntWithAggregatesFilter<"employee"> | number
    employee_fn?: StringWithAggregatesFilter<"employee"> | string
    employee_ln?: StringWithAggregatesFilter<"employee"> | string
    employee_dob?: DateTimeWithAggregatesFilter<"employee"> | Date | string
    employee_join?: DateTimeNullableWithAggregatesFilter<"employee"> | Date | string | null
    employee_img?: StringNullableWithAggregatesFilter<"employee"> | string | null
    employee_info?: StringNullableWithAggregatesFilter<"employee"> | string | null
    employee_degree?: StringNullableWithAggregatesFilter<"employee"> | string | null
    employee_exp?: DateTimeNullableWithAggregatesFilter<"employee"> | Date | string | null
    employee_sal1?: FloatWithAggregatesFilter<"employee"> | number
    employee_sal2?: FloatNullableWithAggregatesFilter<"employee"> | number | null
    employee_wh?: FloatNullableWithAggregatesFilter<"employee"> | number | null
  }

  export type employee_roleWhereInput = {
    AND?: employee_roleWhereInput | employee_roleWhereInput[]
    OR?: employee_roleWhereInput[]
    NOT?: employee_roleWhereInput | employee_roleWhereInput[]
    employee_role_id?: IntFilter<"employee_role"> | number
    role_id?: IntFilter<"employee_role"> | number
    employee_id?: IntFilter<"employee_role"> | number
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }

  export type employee_roleOrderByWithRelationInput = {
    employee_role_id?: SortOrder
    role_id?: SortOrder
    employee_id?: SortOrder
    roles?: rolesOrderByWithRelationInput
    employee?: employeeOrderByWithRelationInput
  }

  export type employee_roleWhereUniqueInput = Prisma.AtLeast<{
    employee_role_id?: number
    AND?: employee_roleWhereInput | employee_roleWhereInput[]
    OR?: employee_roleWhereInput[]
    NOT?: employee_roleWhereInput | employee_roleWhereInput[]
    role_id?: IntFilter<"employee_role"> | number
    employee_id?: IntFilter<"employee_role"> | number
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }, "employee_role_id">

  export type employee_roleOrderByWithAggregationInput = {
    employee_role_id?: SortOrder
    role_id?: SortOrder
    employee_id?: SortOrder
    _count?: employee_roleCountOrderByAggregateInput
    _avg?: employee_roleAvgOrderByAggregateInput
    _max?: employee_roleMaxOrderByAggregateInput
    _min?: employee_roleMinOrderByAggregateInput
    _sum?: employee_roleSumOrderByAggregateInput
  }

  export type employee_roleScalarWhereWithAggregatesInput = {
    AND?: employee_roleScalarWhereWithAggregatesInput | employee_roleScalarWhereWithAggregatesInput[]
    OR?: employee_roleScalarWhereWithAggregatesInput[]
    NOT?: employee_roleScalarWhereWithAggregatesInput | employee_roleScalarWhereWithAggregatesInput[]
    employee_role_id?: IntWithAggregatesFilter<"employee_role"> | number
    role_id?: IntWithAggregatesFilter<"employee_role"> | number
    employee_id?: IntWithAggregatesFilter<"employee_role"> | number
  }

  export type final_gradeWhereInput = {
    AND?: final_gradeWhereInput | final_gradeWhereInput[]
    OR?: final_gradeWhereInput[]
    NOT?: final_gradeWhereInput | final_gradeWhereInput[]
    final_grade_id?: IntFilter<"final_grade"> | number
    subject_code?: StringNullableFilter<"final_grade"> | string | null
    final_grade?: FloatNullableFilter<"final_grade"> | number | null
    student_id?: StringNullableFilter<"final_grade"> | string | null
    test_period?: Enumfinal_grade_test_periodNullableFilter<"final_grade"> | $Enums.final_grade_test_period | null
    created_at?: DateTimeNullableFilter<"final_grade"> | Date | string | null
    final_status?: StringNullableFilter<"final_grade"> | string | null
    subjects?: XOR<SubjectsNullableScalarRelationFilter, subjectsWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, studentWhereInput> | null
  }

  export type final_gradeOrderByWithRelationInput = {
    final_grade_id?: SortOrder
    subject_code?: SortOrderInput | SortOrder
    final_grade?: SortOrderInput | SortOrder
    student_id?: SortOrderInput | SortOrder
    test_period?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    final_status?: SortOrderInput | SortOrder
    subjects?: subjectsOrderByWithRelationInput
    student?: studentOrderByWithRelationInput
    _relevance?: final_gradeOrderByRelevanceInput
  }

  export type final_gradeWhereUniqueInput = Prisma.AtLeast<{
    final_grade_id?: number
    AND?: final_gradeWhereInput | final_gradeWhereInput[]
    OR?: final_gradeWhereInput[]
    NOT?: final_gradeWhereInput | final_gradeWhereInput[]
    subject_code?: StringNullableFilter<"final_grade"> | string | null
    final_grade?: FloatNullableFilter<"final_grade"> | number | null
    student_id?: StringNullableFilter<"final_grade"> | string | null
    test_period?: Enumfinal_grade_test_periodNullableFilter<"final_grade"> | $Enums.final_grade_test_period | null
    created_at?: DateTimeNullableFilter<"final_grade"> | Date | string | null
    final_status?: StringNullableFilter<"final_grade"> | string | null
    subjects?: XOR<SubjectsNullableScalarRelationFilter, subjectsWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, studentWhereInput> | null
  }, "final_grade_id">

  export type final_gradeOrderByWithAggregationInput = {
    final_grade_id?: SortOrder
    subject_code?: SortOrderInput | SortOrder
    final_grade?: SortOrderInput | SortOrder
    student_id?: SortOrderInput | SortOrder
    test_period?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    final_status?: SortOrderInput | SortOrder
    _count?: final_gradeCountOrderByAggregateInput
    _avg?: final_gradeAvgOrderByAggregateInput
    _max?: final_gradeMaxOrderByAggregateInput
    _min?: final_gradeMinOrderByAggregateInput
    _sum?: final_gradeSumOrderByAggregateInput
  }

  export type final_gradeScalarWhereWithAggregatesInput = {
    AND?: final_gradeScalarWhereWithAggregatesInput | final_gradeScalarWhereWithAggregatesInput[]
    OR?: final_gradeScalarWhereWithAggregatesInput[]
    NOT?: final_gradeScalarWhereWithAggregatesInput | final_gradeScalarWhereWithAggregatesInput[]
    final_grade_id?: IntWithAggregatesFilter<"final_grade"> | number
    subject_code?: StringNullableWithAggregatesFilter<"final_grade"> | string | null
    final_grade?: FloatNullableWithAggregatesFilter<"final_grade"> | number | null
    student_id?: StringNullableWithAggregatesFilter<"final_grade"> | string | null
    test_period?: Enumfinal_grade_test_periodNullableWithAggregatesFilter<"final_grade"> | $Enums.final_grade_test_period | null
    created_at?: DateTimeNullableWithAggregatesFilter<"final_grade"> | Date | string | null
    final_status?: StringNullableWithAggregatesFilter<"final_grade"> | string | null
  }

  export type jobWhereInput = {
    AND?: jobWhereInput | jobWhereInput[]
    OR?: jobWhereInput[]
    NOT?: jobWhereInput | jobWhereInput[]
    job_id?: IntFilter<"job"> | number
    parent_id?: IntFilter<"job"> | number
    job_company?: StringFilter<"job"> | string
    job_title?: StringFilter<"job"> | string
    work_email?: StringNullableFilter<"job"> | string | null
    work_number?: StringNullableFilter<"job"> | string | null
    parent?: XOR<ParentScalarRelationFilter, parentWhereInput>
  }

  export type jobOrderByWithRelationInput = {
    job_id?: SortOrder
    parent_id?: SortOrder
    job_company?: SortOrder
    job_title?: SortOrder
    work_email?: SortOrderInput | SortOrder
    work_number?: SortOrderInput | SortOrder
    parent?: parentOrderByWithRelationInput
    _relevance?: jobOrderByRelevanceInput
  }

  export type jobWhereUniqueInput = Prisma.AtLeast<{
    job_id?: number
    AND?: jobWhereInput | jobWhereInput[]
    OR?: jobWhereInput[]
    NOT?: jobWhereInput | jobWhereInput[]
    parent_id?: IntFilter<"job"> | number
    job_company?: StringFilter<"job"> | string
    job_title?: StringFilter<"job"> | string
    work_email?: StringNullableFilter<"job"> | string | null
    work_number?: StringNullableFilter<"job"> | string | null
    parent?: XOR<ParentScalarRelationFilter, parentWhereInput>
  }, "job_id">

  export type jobOrderByWithAggregationInput = {
    job_id?: SortOrder
    parent_id?: SortOrder
    job_company?: SortOrder
    job_title?: SortOrder
    work_email?: SortOrderInput | SortOrder
    work_number?: SortOrderInput | SortOrder
    _count?: jobCountOrderByAggregateInput
    _avg?: jobAvgOrderByAggregateInput
    _max?: jobMaxOrderByAggregateInput
    _min?: jobMinOrderByAggregateInput
    _sum?: jobSumOrderByAggregateInput
  }

  export type jobScalarWhereWithAggregatesInput = {
    AND?: jobScalarWhereWithAggregatesInput | jobScalarWhereWithAggregatesInput[]
    OR?: jobScalarWhereWithAggregatesInput[]
    NOT?: jobScalarWhereWithAggregatesInput | jobScalarWhereWithAggregatesInput[]
    job_id?: IntWithAggregatesFilter<"job"> | number
    parent_id?: IntWithAggregatesFilter<"job"> | number
    job_company?: StringWithAggregatesFilter<"job"> | string
    job_title?: StringWithAggregatesFilter<"job"> | string
    work_email?: StringNullableWithAggregatesFilter<"job"> | string | null
    work_number?: StringNullableWithAggregatesFilter<"job"> | string | null
  }

  export type parentWhereInput = {
    AND?: parentWhereInput | parentWhereInput[]
    OR?: parentWhereInput[]
    NOT?: parentWhereInput | parentWhereInput[]
    parent_id?: IntFilter<"parent"> | number
    parent_fn?: StringFilter<"parent"> | string
    parent_ln?: StringFilter<"parent"> | string
    parent_dob?: DateTimeFilter<"parent"> | Date | string
    parent_pers_number?: StringFilter<"parent"> | string
    parent_pers_email?: StringNullableFilter<"parent"> | string | null
    job?: JobListRelationFilter
    student_student_father_idToparent?: StudentListRelationFilter
    student_student_mother_idToparent?: StudentListRelationFilter
  }

  export type parentOrderByWithRelationInput = {
    parent_id?: SortOrder
    parent_fn?: SortOrder
    parent_ln?: SortOrder
    parent_dob?: SortOrder
    parent_pers_number?: SortOrder
    parent_pers_email?: SortOrderInput | SortOrder
    job?: jobOrderByRelationAggregateInput
    student_student_father_idToparent?: studentOrderByRelationAggregateInput
    student_student_mother_idToparent?: studentOrderByRelationAggregateInput
    _relevance?: parentOrderByRelevanceInput
  }

  export type parentWhereUniqueInput = Prisma.AtLeast<{
    parent_id?: number
    AND?: parentWhereInput | parentWhereInput[]
    OR?: parentWhereInput[]
    NOT?: parentWhereInput | parentWhereInput[]
    parent_fn?: StringFilter<"parent"> | string
    parent_ln?: StringFilter<"parent"> | string
    parent_dob?: DateTimeFilter<"parent"> | Date | string
    parent_pers_number?: StringFilter<"parent"> | string
    parent_pers_email?: StringNullableFilter<"parent"> | string | null
    job?: JobListRelationFilter
    student_student_father_idToparent?: StudentListRelationFilter
    student_student_mother_idToparent?: StudentListRelationFilter
  }, "parent_id">

  export type parentOrderByWithAggregationInput = {
    parent_id?: SortOrder
    parent_fn?: SortOrder
    parent_ln?: SortOrder
    parent_dob?: SortOrder
    parent_pers_number?: SortOrder
    parent_pers_email?: SortOrderInput | SortOrder
    _count?: parentCountOrderByAggregateInput
    _avg?: parentAvgOrderByAggregateInput
    _max?: parentMaxOrderByAggregateInput
    _min?: parentMinOrderByAggregateInput
    _sum?: parentSumOrderByAggregateInput
  }

  export type parentScalarWhereWithAggregatesInput = {
    AND?: parentScalarWhereWithAggregatesInput | parentScalarWhereWithAggregatesInput[]
    OR?: parentScalarWhereWithAggregatesInput[]
    NOT?: parentScalarWhereWithAggregatesInput | parentScalarWhereWithAggregatesInput[]
    parent_id?: IntWithAggregatesFilter<"parent"> | number
    parent_fn?: StringWithAggregatesFilter<"parent"> | string
    parent_ln?: StringWithAggregatesFilter<"parent"> | string
    parent_dob?: DateTimeWithAggregatesFilter<"parent"> | Date | string
    parent_pers_number?: StringWithAggregatesFilter<"parent"> | string
    parent_pers_email?: StringNullableWithAggregatesFilter<"parent"> | string | null
  }

  export type periodWhereInput = {
    AND?: periodWhereInput | periodWhereInput[]
    OR?: periodWhereInput[]
    NOT?: periodWhereInput | periodWhereInput[]
    period?: IntFilter<"period"> | number
    period_status?: StringFilter<"period"> | string
    active_class_active_class_periodToperiod?: Active_classListRelationFilter
  }

  export type periodOrderByWithRelationInput = {
    period?: SortOrder
    period_status?: SortOrder
    active_class_active_class_periodToperiod?: active_classOrderByRelationAggregateInput
    _relevance?: periodOrderByRelevanceInput
  }

  export type periodWhereUniqueInput = Prisma.AtLeast<{
    period?: number
    AND?: periodWhereInput | periodWhereInput[]
    OR?: periodWhereInput[]
    NOT?: periodWhereInput | periodWhereInput[]
    period_status?: StringFilter<"period"> | string
    active_class_active_class_periodToperiod?: Active_classListRelationFilter
  }, "period">

  export type periodOrderByWithAggregationInput = {
    period?: SortOrder
    period_status?: SortOrder
    _count?: periodCountOrderByAggregateInput
    _avg?: periodAvgOrderByAggregateInput
    _max?: periodMaxOrderByAggregateInput
    _min?: periodMinOrderByAggregateInput
    _sum?: periodSumOrderByAggregateInput
  }

  export type periodScalarWhereWithAggregatesInput = {
    AND?: periodScalarWhereWithAggregatesInput | periodScalarWhereWithAggregatesInput[]
    OR?: periodScalarWhereWithAggregatesInput[]
    NOT?: periodScalarWhereWithAggregatesInput | periodScalarWhereWithAggregatesInput[]
    period?: IntWithAggregatesFilter<"period"> | number
    period_status?: StringWithAggregatesFilter<"period"> | string
  }

  export type rolesWhereInput = {
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    role_id?: IntFilter<"roles"> | number
    role_name?: StringFilter<"roles"> | string
    role_description?: StringNullableFilter<"roles"> | string | null
    employee_role?: Employee_roleListRelationFilter
  }

  export type rolesOrderByWithRelationInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    role_description?: SortOrderInput | SortOrder
    employee_role?: employee_roleOrderByRelationAggregateInput
    _relevance?: rolesOrderByRelevanceInput
  }

  export type rolesWhereUniqueInput = Prisma.AtLeast<{
    role_id?: number
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    role_name?: StringFilter<"roles"> | string
    role_description?: StringNullableFilter<"roles"> | string | null
    employee_role?: Employee_roleListRelationFilter
  }, "role_id">

  export type rolesOrderByWithAggregationInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    role_description?: SortOrderInput | SortOrder
    _count?: rolesCountOrderByAggregateInput
    _avg?: rolesAvgOrderByAggregateInput
    _max?: rolesMaxOrderByAggregateInput
    _min?: rolesMinOrderByAggregateInput
    _sum?: rolesSumOrderByAggregateInput
  }

  export type rolesScalarWhereWithAggregatesInput = {
    AND?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    OR?: rolesScalarWhereWithAggregatesInput[]
    NOT?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    role_id?: IntWithAggregatesFilter<"roles"> | number
    role_name?: StringWithAggregatesFilter<"roles"> | string
    role_description?: StringNullableWithAggregatesFilter<"roles"> | string | null
  }

  export type school_emailWhereInput = {
    AND?: school_emailWhereInput | school_emailWhereInput[]
    OR?: school_emailWhereInput[]
    NOT?: school_emailWhereInput | school_emailWhereInput[]
    school_num_id?: IntFilter<"school_email"> | number
    school_reg?: IntFilter<"school_email"> | number
    school_email?: StringFilter<"school_email"> | string
    school_email_label?: StringFilter<"school_email"> | string
    school_info?: XOR<School_infoScalarRelationFilter, school_infoWhereInput>
  }

  export type school_emailOrderByWithRelationInput = {
    school_num_id?: SortOrder
    school_reg?: SortOrder
    school_email?: SortOrder
    school_email_label?: SortOrder
    school_info?: school_infoOrderByWithRelationInput
    _relevance?: school_emailOrderByRelevanceInput
  }

  export type school_emailWhereUniqueInput = Prisma.AtLeast<{
    school_num_id?: number
    AND?: school_emailWhereInput | school_emailWhereInput[]
    OR?: school_emailWhereInput[]
    NOT?: school_emailWhereInput | school_emailWhereInput[]
    school_reg?: IntFilter<"school_email"> | number
    school_email?: StringFilter<"school_email"> | string
    school_email_label?: StringFilter<"school_email"> | string
    school_info?: XOR<School_infoScalarRelationFilter, school_infoWhereInput>
  }, "school_num_id">

  export type school_emailOrderByWithAggregationInput = {
    school_num_id?: SortOrder
    school_reg?: SortOrder
    school_email?: SortOrder
    school_email_label?: SortOrder
    _count?: school_emailCountOrderByAggregateInput
    _avg?: school_emailAvgOrderByAggregateInput
    _max?: school_emailMaxOrderByAggregateInput
    _min?: school_emailMinOrderByAggregateInput
    _sum?: school_emailSumOrderByAggregateInput
  }

  export type school_emailScalarWhereWithAggregatesInput = {
    AND?: school_emailScalarWhereWithAggregatesInput | school_emailScalarWhereWithAggregatesInput[]
    OR?: school_emailScalarWhereWithAggregatesInput[]
    NOT?: school_emailScalarWhereWithAggregatesInput | school_emailScalarWhereWithAggregatesInput[]
    school_num_id?: IntWithAggregatesFilter<"school_email"> | number
    school_reg?: IntWithAggregatesFilter<"school_email"> | number
    school_email?: StringWithAggregatesFilter<"school_email"> | string
    school_email_label?: StringWithAggregatesFilter<"school_email"> | string
  }

  export type school_infoWhereInput = {
    AND?: school_infoWhereInput | school_infoWhereInput[]
    OR?: school_infoWhereInput[]
    NOT?: school_infoWhereInput | school_infoWhereInput[]
    school_reg?: IntFilter<"school_info"> | number
    school_name?: StringFilter<"school_info"> | string
    school_address?: StringFilter<"school_info"> | string
    school_lat?: FloatFilter<"school_info"> | number
    school_long?: FloatFilter<"school_info"> | number
    school_princ?: StringFilter<"school_info"> | string
    school_email?: School_emailListRelationFilter
    school_num?: School_numListRelationFilter
  }

  export type school_infoOrderByWithRelationInput = {
    school_reg?: SortOrder
    school_name?: SortOrder
    school_address?: SortOrder
    school_lat?: SortOrder
    school_long?: SortOrder
    school_princ?: SortOrder
    school_email?: school_emailOrderByRelationAggregateInput
    school_num?: school_numOrderByRelationAggregateInput
    _relevance?: school_infoOrderByRelevanceInput
  }

  export type school_infoWhereUniqueInput = Prisma.AtLeast<{
    school_reg?: number
    AND?: school_infoWhereInput | school_infoWhereInput[]
    OR?: school_infoWhereInput[]
    NOT?: school_infoWhereInput | school_infoWhereInput[]
    school_name?: StringFilter<"school_info"> | string
    school_address?: StringFilter<"school_info"> | string
    school_lat?: FloatFilter<"school_info"> | number
    school_long?: FloatFilter<"school_info"> | number
    school_princ?: StringFilter<"school_info"> | string
    school_email?: School_emailListRelationFilter
    school_num?: School_numListRelationFilter
  }, "school_reg">

  export type school_infoOrderByWithAggregationInput = {
    school_reg?: SortOrder
    school_name?: SortOrder
    school_address?: SortOrder
    school_lat?: SortOrder
    school_long?: SortOrder
    school_princ?: SortOrder
    _count?: school_infoCountOrderByAggregateInput
    _avg?: school_infoAvgOrderByAggregateInput
    _max?: school_infoMaxOrderByAggregateInput
    _min?: school_infoMinOrderByAggregateInput
    _sum?: school_infoSumOrderByAggregateInput
  }

  export type school_infoScalarWhereWithAggregatesInput = {
    AND?: school_infoScalarWhereWithAggregatesInput | school_infoScalarWhereWithAggregatesInput[]
    OR?: school_infoScalarWhereWithAggregatesInput[]
    NOT?: school_infoScalarWhereWithAggregatesInput | school_infoScalarWhereWithAggregatesInput[]
    school_reg?: IntWithAggregatesFilter<"school_info"> | number
    school_name?: StringWithAggregatesFilter<"school_info"> | string
    school_address?: StringWithAggregatesFilter<"school_info"> | string
    school_lat?: FloatWithAggregatesFilter<"school_info"> | number
    school_long?: FloatWithAggregatesFilter<"school_info"> | number
    school_princ?: StringWithAggregatesFilter<"school_info"> | string
  }

  export type school_numWhereInput = {
    AND?: school_numWhereInput | school_numWhereInput[]
    OR?: school_numWhereInput[]
    NOT?: school_numWhereInput | school_numWhereInput[]
    school_num_id?: IntFilter<"school_num"> | number
    school_reg?: IntFilter<"school_num"> | number
    school_phone?: StringFilter<"school_num"> | string
    school_phone_label?: StringFilter<"school_num"> | string
    school_info?: XOR<School_infoScalarRelationFilter, school_infoWhereInput>
  }

  export type school_numOrderByWithRelationInput = {
    school_num_id?: SortOrder
    school_reg?: SortOrder
    school_phone?: SortOrder
    school_phone_label?: SortOrder
    school_info?: school_infoOrderByWithRelationInput
    _relevance?: school_numOrderByRelevanceInput
  }

  export type school_numWhereUniqueInput = Prisma.AtLeast<{
    school_num_id?: number
    AND?: school_numWhereInput | school_numWhereInput[]
    OR?: school_numWhereInput[]
    NOT?: school_numWhereInput | school_numWhereInput[]
    school_reg?: IntFilter<"school_num"> | number
    school_phone?: StringFilter<"school_num"> | string
    school_phone_label?: StringFilter<"school_num"> | string
    school_info?: XOR<School_infoScalarRelationFilter, school_infoWhereInput>
  }, "school_num_id">

  export type school_numOrderByWithAggregationInput = {
    school_num_id?: SortOrder
    school_reg?: SortOrder
    school_phone?: SortOrder
    school_phone_label?: SortOrder
    _count?: school_numCountOrderByAggregateInput
    _avg?: school_numAvgOrderByAggregateInput
    _max?: school_numMaxOrderByAggregateInput
    _min?: school_numMinOrderByAggregateInput
    _sum?: school_numSumOrderByAggregateInput
  }

  export type school_numScalarWhereWithAggregatesInput = {
    AND?: school_numScalarWhereWithAggregatesInput | school_numScalarWhereWithAggregatesInput[]
    OR?: school_numScalarWhereWithAggregatesInput[]
    NOT?: school_numScalarWhereWithAggregatesInput | school_numScalarWhereWithAggregatesInput[]
    school_num_id?: IntWithAggregatesFilter<"school_num"> | number
    school_reg?: IntWithAggregatesFilter<"school_num"> | number
    school_phone?: StringWithAggregatesFilter<"school_num"> | string
    school_phone_label?: StringWithAggregatesFilter<"school_num"> | string
  }

  export type studentWhereInput = {
    AND?: studentWhereInput | studentWhereInput[]
    OR?: studentWhereInput[]
    NOT?: studentWhereInput | studentWhereInput[]
    student_id?: StringFilter<"student"> | string
    mother_id?: IntFilter<"student"> | number
    father_id?: IntFilter<"student"> | number
    student_fname?: StringFilter<"student"> | string
    student_lname?: StringFilter<"student"> | string
    student_dob?: DateTimeFilter<"student"> | Date | string
    student_account?: StringFilter<"student"> | string
    student_pass?: StringFilter<"student"> | string
    note?: StringNullableFilter<"student"> | string | null
    final_grade?: Final_gradeListRelationFilter
    parent_student_father_idToparent?: XOR<ParentScalarRelationFilter, parentWhereInput>
    parent_student_mother_idToparent?: XOR<ParentScalarRelationFilter, parentWhereInput>
    test_result?: Test_resultListRelationFilter
  }

  export type studentOrderByWithRelationInput = {
    student_id?: SortOrder
    mother_id?: SortOrder
    father_id?: SortOrder
    student_fname?: SortOrder
    student_lname?: SortOrder
    student_dob?: SortOrder
    student_account?: SortOrder
    student_pass?: SortOrder
    note?: SortOrderInput | SortOrder
    final_grade?: final_gradeOrderByRelationAggregateInput
    parent_student_father_idToparent?: parentOrderByWithRelationInput
    parent_student_mother_idToparent?: parentOrderByWithRelationInput
    test_result?: test_resultOrderByRelationAggregateInput
    _relevance?: studentOrderByRelevanceInput
  }

  export type studentWhereUniqueInput = Prisma.AtLeast<{
    student_id?: string
    AND?: studentWhereInput | studentWhereInput[]
    OR?: studentWhereInput[]
    NOT?: studentWhereInput | studentWhereInput[]
    mother_id?: IntFilter<"student"> | number
    father_id?: IntFilter<"student"> | number
    student_fname?: StringFilter<"student"> | string
    student_lname?: StringFilter<"student"> | string
    student_dob?: DateTimeFilter<"student"> | Date | string
    student_account?: StringFilter<"student"> | string
    student_pass?: StringFilter<"student"> | string
    note?: StringNullableFilter<"student"> | string | null
    final_grade?: Final_gradeListRelationFilter
    parent_student_father_idToparent?: XOR<ParentScalarRelationFilter, parentWhereInput>
    parent_student_mother_idToparent?: XOR<ParentScalarRelationFilter, parentWhereInput>
    test_result?: Test_resultListRelationFilter
  }, "student_id">

  export type studentOrderByWithAggregationInput = {
    student_id?: SortOrder
    mother_id?: SortOrder
    father_id?: SortOrder
    student_fname?: SortOrder
    student_lname?: SortOrder
    student_dob?: SortOrder
    student_account?: SortOrder
    student_pass?: SortOrder
    note?: SortOrderInput | SortOrder
    _count?: studentCountOrderByAggregateInput
    _avg?: studentAvgOrderByAggregateInput
    _max?: studentMaxOrderByAggregateInput
    _min?: studentMinOrderByAggregateInput
    _sum?: studentSumOrderByAggregateInput
  }

  export type studentScalarWhereWithAggregatesInput = {
    AND?: studentScalarWhereWithAggregatesInput | studentScalarWhereWithAggregatesInput[]
    OR?: studentScalarWhereWithAggregatesInput[]
    NOT?: studentScalarWhereWithAggregatesInput | studentScalarWhereWithAggregatesInput[]
    student_id?: StringWithAggregatesFilter<"student"> | string
    mother_id?: IntWithAggregatesFilter<"student"> | number
    father_id?: IntWithAggregatesFilter<"student"> | number
    student_fname?: StringWithAggregatesFilter<"student"> | string
    student_lname?: StringWithAggregatesFilter<"student"> | string
    student_dob?: DateTimeWithAggregatesFilter<"student"> | Date | string
    student_account?: StringWithAggregatesFilter<"student"> | string
    student_pass?: StringWithAggregatesFilter<"student"> | string
    note?: StringNullableWithAggregatesFilter<"student"> | string | null
  }

  export type subject_classWhereInput = {
    AND?: subject_classWhereInput | subject_classWhereInput[]
    OR?: subject_classWhereInput[]
    NOT?: subject_classWhereInput | subject_classWhereInput[]
    subject_class_id?: IntFilter<"subject_class"> | number
    subject_code?: StringFilter<"subject_class"> | string
    instructor?: IntNullableFilter<"subject_class"> | number | null
    agenda?: AgendaListRelationFilter
    employee?: XOR<EmployeeNullableScalarRelationFilter, employeeWhereInput> | null
    subjects?: XOR<SubjectsScalarRelationFilter, subjectsWhereInput>
    test?: TestListRelationFilter
  }

  export type subject_classOrderByWithRelationInput = {
    subject_class_id?: SortOrder
    subject_code?: SortOrder
    instructor?: SortOrderInput | SortOrder
    agenda?: agendaOrderByRelationAggregateInput
    employee?: employeeOrderByWithRelationInput
    subjects?: subjectsOrderByWithRelationInput
    test?: testOrderByRelationAggregateInput
    _relevance?: subject_classOrderByRelevanceInput
  }

  export type subject_classWhereUniqueInput = Prisma.AtLeast<{
    subject_class_id?: number
    AND?: subject_classWhereInput | subject_classWhereInput[]
    OR?: subject_classWhereInput[]
    NOT?: subject_classWhereInput | subject_classWhereInput[]
    subject_code?: StringFilter<"subject_class"> | string
    instructor?: IntNullableFilter<"subject_class"> | number | null
    agenda?: AgendaListRelationFilter
    employee?: XOR<EmployeeNullableScalarRelationFilter, employeeWhereInput> | null
    subjects?: XOR<SubjectsScalarRelationFilter, subjectsWhereInput>
    test?: TestListRelationFilter
  }, "subject_class_id">

  export type subject_classOrderByWithAggregationInput = {
    subject_class_id?: SortOrder
    subject_code?: SortOrder
    instructor?: SortOrderInput | SortOrder
    _count?: subject_classCountOrderByAggregateInput
    _avg?: subject_classAvgOrderByAggregateInput
    _max?: subject_classMaxOrderByAggregateInput
    _min?: subject_classMinOrderByAggregateInput
    _sum?: subject_classSumOrderByAggregateInput
  }

  export type subject_classScalarWhereWithAggregatesInput = {
    AND?: subject_classScalarWhereWithAggregatesInput | subject_classScalarWhereWithAggregatesInput[]
    OR?: subject_classScalarWhereWithAggregatesInput[]
    NOT?: subject_classScalarWhereWithAggregatesInput | subject_classScalarWhereWithAggregatesInput[]
    subject_class_id?: IntWithAggregatesFilter<"subject_class"> | number
    subject_code?: StringWithAggregatesFilter<"subject_class"> | string
    instructor?: IntNullableWithAggregatesFilter<"subject_class"> | number | null
  }

  export type subjectsWhereInput = {
    AND?: subjectsWhereInput | subjectsWhereInput[]
    OR?: subjectsWhereInput[]
    NOT?: subjectsWhereInput | subjectsWhereInput[]
    subject_code?: StringFilter<"subjects"> | string
    subject_name?: StringFilter<"subjects"> | string
    subject_cat?: Enumsubjects_subject_catNullableFilter<"subjects"> | $Enums.subjects_subject_cat | null
    final_grade?: Final_gradeListRelationFilter
    subject_class?: Subject_classListRelationFilter
  }

  export type subjectsOrderByWithRelationInput = {
    subject_code?: SortOrder
    subject_name?: SortOrder
    subject_cat?: SortOrderInput | SortOrder
    final_grade?: final_gradeOrderByRelationAggregateInput
    subject_class?: subject_classOrderByRelationAggregateInput
    _relevance?: subjectsOrderByRelevanceInput
  }

  export type subjectsWhereUniqueInput = Prisma.AtLeast<{
    subject_code?: string
    AND?: subjectsWhereInput | subjectsWhereInput[]
    OR?: subjectsWhereInput[]
    NOT?: subjectsWhereInput | subjectsWhereInput[]
    subject_name?: StringFilter<"subjects"> | string
    subject_cat?: Enumsubjects_subject_catNullableFilter<"subjects"> | $Enums.subjects_subject_cat | null
    final_grade?: Final_gradeListRelationFilter
    subject_class?: Subject_classListRelationFilter
  }, "subject_code">

  export type subjectsOrderByWithAggregationInput = {
    subject_code?: SortOrder
    subject_name?: SortOrder
    subject_cat?: SortOrderInput | SortOrder
    _count?: subjectsCountOrderByAggregateInput
    _max?: subjectsMaxOrderByAggregateInput
    _min?: subjectsMinOrderByAggregateInput
  }

  export type subjectsScalarWhereWithAggregatesInput = {
    AND?: subjectsScalarWhereWithAggregatesInput | subjectsScalarWhereWithAggregatesInput[]
    OR?: subjectsScalarWhereWithAggregatesInput[]
    NOT?: subjectsScalarWhereWithAggregatesInput | subjectsScalarWhereWithAggregatesInput[]
    subject_code?: StringWithAggregatesFilter<"subjects"> | string
    subject_name?: StringWithAggregatesFilter<"subjects"> | string
    subject_cat?: Enumsubjects_subject_catNullableWithAggregatesFilter<"subjects"> | $Enums.subjects_subject_cat | null
  }

  export type testWhereInput = {
    AND?: testWhereInput | testWhereInput[]
    OR?: testWhereInput[]
    NOT?: testWhereInput | testWhereInput[]
    test_id?: IntFilter<"test"> | number
    test_title?: StringNullableFilter<"test"> | string | null
    test_description?: StringNullableFilter<"test"> | string | null
    subject_class_id?: IntNullableFilter<"test"> | number | null
    test_total?: IntNullableFilter<"test"> | number | null
    test_visibility?: StringNullableFilter<"test"> | string | null
    test_annouced?: DateTimeNullableFilter<"test"> | Date | string | null
    test_due?: DateTimeNullableFilter<"test"> | Date | string | null
    test_period?: Enumtest_test_periodNullableFilter<"test"> | $Enums.test_test_period | null
    subject_class?: XOR<Subject_classNullableScalarRelationFilter, subject_classWhereInput> | null
    test_result?: Test_resultListRelationFilter
  }

  export type testOrderByWithRelationInput = {
    test_id?: SortOrder
    test_title?: SortOrderInput | SortOrder
    test_description?: SortOrderInput | SortOrder
    subject_class_id?: SortOrderInput | SortOrder
    test_total?: SortOrderInput | SortOrder
    test_visibility?: SortOrderInput | SortOrder
    test_annouced?: SortOrderInput | SortOrder
    test_due?: SortOrderInput | SortOrder
    test_period?: SortOrderInput | SortOrder
    subject_class?: subject_classOrderByWithRelationInput
    test_result?: test_resultOrderByRelationAggregateInput
    _relevance?: testOrderByRelevanceInput
  }

  export type testWhereUniqueInput = Prisma.AtLeast<{
    test_id?: number
    AND?: testWhereInput | testWhereInput[]
    OR?: testWhereInput[]
    NOT?: testWhereInput | testWhereInput[]
    test_title?: StringNullableFilter<"test"> | string | null
    test_description?: StringNullableFilter<"test"> | string | null
    subject_class_id?: IntNullableFilter<"test"> | number | null
    test_total?: IntNullableFilter<"test"> | number | null
    test_visibility?: StringNullableFilter<"test"> | string | null
    test_annouced?: DateTimeNullableFilter<"test"> | Date | string | null
    test_due?: DateTimeNullableFilter<"test"> | Date | string | null
    test_period?: Enumtest_test_periodNullableFilter<"test"> | $Enums.test_test_period | null
    subject_class?: XOR<Subject_classNullableScalarRelationFilter, subject_classWhereInput> | null
    test_result?: Test_resultListRelationFilter
  }, "test_id">

  export type testOrderByWithAggregationInput = {
    test_id?: SortOrder
    test_title?: SortOrderInput | SortOrder
    test_description?: SortOrderInput | SortOrder
    subject_class_id?: SortOrderInput | SortOrder
    test_total?: SortOrderInput | SortOrder
    test_visibility?: SortOrderInput | SortOrder
    test_annouced?: SortOrderInput | SortOrder
    test_due?: SortOrderInput | SortOrder
    test_period?: SortOrderInput | SortOrder
    _count?: testCountOrderByAggregateInput
    _avg?: testAvgOrderByAggregateInput
    _max?: testMaxOrderByAggregateInput
    _min?: testMinOrderByAggregateInput
    _sum?: testSumOrderByAggregateInput
  }

  export type testScalarWhereWithAggregatesInput = {
    AND?: testScalarWhereWithAggregatesInput | testScalarWhereWithAggregatesInput[]
    OR?: testScalarWhereWithAggregatesInput[]
    NOT?: testScalarWhereWithAggregatesInput | testScalarWhereWithAggregatesInput[]
    test_id?: IntWithAggregatesFilter<"test"> | number
    test_title?: StringNullableWithAggregatesFilter<"test"> | string | null
    test_description?: StringNullableWithAggregatesFilter<"test"> | string | null
    subject_class_id?: IntNullableWithAggregatesFilter<"test"> | number | null
    test_total?: IntNullableWithAggregatesFilter<"test"> | number | null
    test_visibility?: StringNullableWithAggregatesFilter<"test"> | string | null
    test_annouced?: DateTimeNullableWithAggregatesFilter<"test"> | Date | string | null
    test_due?: DateTimeNullableWithAggregatesFilter<"test"> | Date | string | null
    test_period?: Enumtest_test_periodNullableWithAggregatesFilter<"test"> | $Enums.test_test_period | null
  }

  export type test_resultWhereInput = {
    AND?: test_resultWhereInput | test_resultWhereInput[]
    OR?: test_resultWhereInput[]
    NOT?: test_resultWhereInput | test_resultWhereInput[]
    test_result_id?: IntFilter<"test_result"> | number
    test_id?: IntFilter<"test_result"> | number
    student_id?: StringNullableFilter<"test_result"> | string | null
    test_result?: FloatFilter<"test_result"> | number
    test_note?: StringNullableFilter<"test_result"> | string | null
    test?: XOR<TestScalarRelationFilter, testWhereInput>
    student?: XOR<StudentNullableScalarRelationFilter, studentWhereInput> | null
  }

  export type test_resultOrderByWithRelationInput = {
    test_result_id?: SortOrder
    test_id?: SortOrder
    student_id?: SortOrderInput | SortOrder
    test_result?: SortOrder
    test_note?: SortOrderInput | SortOrder
    test?: testOrderByWithRelationInput
    student?: studentOrderByWithRelationInput
    _relevance?: test_resultOrderByRelevanceInput
  }

  export type test_resultWhereUniqueInput = Prisma.AtLeast<{
    test_result_id?: number
    AND?: test_resultWhereInput | test_resultWhereInput[]
    OR?: test_resultWhereInput[]
    NOT?: test_resultWhereInput | test_resultWhereInput[]
    test_id?: IntFilter<"test_result"> | number
    student_id?: StringNullableFilter<"test_result"> | string | null
    test_result?: FloatFilter<"test_result"> | number
    test_note?: StringNullableFilter<"test_result"> | string | null
    test?: XOR<TestScalarRelationFilter, testWhereInput>
    student?: XOR<StudentNullableScalarRelationFilter, studentWhereInput> | null
  }, "test_result_id">

  export type test_resultOrderByWithAggregationInput = {
    test_result_id?: SortOrder
    test_id?: SortOrder
    student_id?: SortOrderInput | SortOrder
    test_result?: SortOrder
    test_note?: SortOrderInput | SortOrder
    _count?: test_resultCountOrderByAggregateInput
    _avg?: test_resultAvgOrderByAggregateInput
    _max?: test_resultMaxOrderByAggregateInput
    _min?: test_resultMinOrderByAggregateInput
    _sum?: test_resultSumOrderByAggregateInput
  }

  export type test_resultScalarWhereWithAggregatesInput = {
    AND?: test_resultScalarWhereWithAggregatesInput | test_resultScalarWhereWithAggregatesInput[]
    OR?: test_resultScalarWhereWithAggregatesInput[]
    NOT?: test_resultScalarWhereWithAggregatesInput | test_resultScalarWhereWithAggregatesInput[]
    test_result_id?: IntWithAggregatesFilter<"test_result"> | number
    test_id?: IntWithAggregatesFilter<"test_result"> | number
    student_id?: StringNullableWithAggregatesFilter<"test_result"> | string | null
    test_result?: FloatWithAggregatesFilter<"test_result"> | number
    test_note?: StringNullableWithAggregatesFilter<"test_result"> | string | null
  }

  export type classesWhereInput = {
    AND?: classesWhereInput | classesWhereInput[]
    OR?: classesWhereInput[]
    NOT?: classesWhereInput | classesWhereInput[]
    class_code?: StringFilter<"classes"> | string
    class_name?: StringNullableFilter<"classes"> | string | null
    class_base?: StringNullableFilter<"classes"> | string | null
    active_class?: Active_classListRelationFilter
  }

  export type classesOrderByWithRelationInput = {
    class_code?: SortOrder
    class_name?: SortOrderInput | SortOrder
    class_base?: SortOrderInput | SortOrder
    active_class?: active_classOrderByRelationAggregateInput
    _relevance?: classesOrderByRelevanceInput
  }

  export type classesWhereUniqueInput = Prisma.AtLeast<{
    class_code?: string
    AND?: classesWhereInput | classesWhereInput[]
    OR?: classesWhereInput[]
    NOT?: classesWhereInput | classesWhereInput[]
    class_name?: StringNullableFilter<"classes"> | string | null
    class_base?: StringNullableFilter<"classes"> | string | null
    active_class?: Active_classListRelationFilter
  }, "class_code">

  export type classesOrderByWithAggregationInput = {
    class_code?: SortOrder
    class_name?: SortOrderInput | SortOrder
    class_base?: SortOrderInput | SortOrder
    _count?: classesCountOrderByAggregateInput
    _max?: classesMaxOrderByAggregateInput
    _min?: classesMinOrderByAggregateInput
  }

  export type classesScalarWhereWithAggregatesInput = {
    AND?: classesScalarWhereWithAggregatesInput | classesScalarWhereWithAggregatesInput[]
    OR?: classesScalarWhereWithAggregatesInput[]
    NOT?: classesScalarWhereWithAggregatesInput | classesScalarWhereWithAggregatesInput[]
    class_code?: StringWithAggregatesFilter<"classes"> | string
    class_name?: StringNullableWithAggregatesFilter<"classes"> | string | null
    class_base?: StringNullableWithAggregatesFilter<"classes"> | string | null
  }

  export type parent_formWhereInput = {
    AND?: parent_formWhereInput | parent_formWhereInput[]
    OR?: parent_formWhereInput[]
    NOT?: parent_formWhereInput | parent_formWhereInput[]
    parent_form_id?: IntFilter<"parent_form"> | number
    parent_form_content?: BytesFilter<"parent_form"> | Uint8Array
    parent_form_created?: DateTimeNullableFilter<"parent_form"> | Date | string | null
  }

  export type parent_formOrderByWithRelationInput = {
    parent_form_id?: SortOrder
    parent_form_content?: SortOrder
    parent_form_created?: SortOrderInput | SortOrder
  }

  export type parent_formWhereUniqueInput = Prisma.AtLeast<{
    parent_form_id?: number
    AND?: parent_formWhereInput | parent_formWhereInput[]
    OR?: parent_formWhereInput[]
    NOT?: parent_formWhereInput | parent_formWhereInput[]
    parent_form_content?: BytesFilter<"parent_form"> | Uint8Array
    parent_form_created?: DateTimeNullableFilter<"parent_form"> | Date | string | null
  }, "parent_form_id">

  export type parent_formOrderByWithAggregationInput = {
    parent_form_id?: SortOrder
    parent_form_content?: SortOrder
    parent_form_created?: SortOrderInput | SortOrder
    _count?: parent_formCountOrderByAggregateInput
    _avg?: parent_formAvgOrderByAggregateInput
    _max?: parent_formMaxOrderByAggregateInput
    _min?: parent_formMinOrderByAggregateInput
    _sum?: parent_formSumOrderByAggregateInput
  }

  export type parent_formScalarWhereWithAggregatesInput = {
    AND?: parent_formScalarWhereWithAggregatesInput | parent_formScalarWhereWithAggregatesInput[]
    OR?: parent_formScalarWhereWithAggregatesInput[]
    NOT?: parent_formScalarWhereWithAggregatesInput | parent_formScalarWhereWithAggregatesInput[]
    parent_form_id?: IntWithAggregatesFilter<"parent_form"> | number
    parent_form_content?: BytesWithAggregatesFilter<"parent_form"> | Uint8Array
    parent_form_created?: DateTimeNullableWithAggregatesFilter<"parent_form"> | Date | string | null
  }

  export type active_classCreateInput = {
    Renamedclass?: classesCreateNestedOneWithoutActive_classInput
    period_active_class_periodToperiod?: periodCreateNestedOneWithoutActive_class_active_class_periodToperiodInput
    employee?: employeeCreateNestedOneWithoutActive_classInput
  }

  export type active_classUncheckedCreateInput = {
    active_class_id?: number
    class_code?: string | null
    period?: number | null
    class_coordinator?: number | null
  }

  export type active_classUpdateInput = {
    Renamedclass?: classesUpdateOneWithoutActive_classNestedInput
    period_active_class_periodToperiod?: periodUpdateOneWithoutActive_class_active_class_periodToperiodNestedInput
    employee?: employeeUpdateOneWithoutActive_classNestedInput
  }

  export type active_classUncheckedUpdateInput = {
    active_class_id?: IntFieldUpdateOperationsInput | number
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableIntFieldUpdateOperationsInput | number | null
    class_coordinator?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type active_classCreateManyInput = {
    active_class_id?: number
    class_code?: string | null
    period?: number | null
    class_coordinator?: number | null
  }

  export type active_classUpdateManyMutationInput = {

  }

  export type active_classUncheckedUpdateManyInput = {
    active_class_id?: IntFieldUpdateOperationsInput | number
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableIntFieldUpdateOperationsInput | number | null
    class_coordinator?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type agendaCreateInput = {
    agenda_title: string
    agenda_context: string
    agenda_annouced?: Date | string | null
    agenda_due?: Date | string | null
    subject_class?: subject_classCreateNestedOneWithoutAgendaInput
  }

  export type agendaUncheckedCreateInput = {
    agenda_id?: number
    subject_class_id?: number | null
    agenda_title: string
    agenda_context: string
    agenda_annouced?: Date | string | null
    agenda_due?: Date | string | null
  }

  export type agendaUpdateInput = {
    agenda_title?: StringFieldUpdateOperationsInput | string
    agenda_context?: StringFieldUpdateOperationsInput | string
    agenda_annouced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agenda_due?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subject_class?: subject_classUpdateOneWithoutAgendaNestedInput
  }

  export type agendaUncheckedUpdateInput = {
    agenda_id?: IntFieldUpdateOperationsInput | number
    subject_class_id?: NullableIntFieldUpdateOperationsInput | number | null
    agenda_title?: StringFieldUpdateOperationsInput | string
    agenda_context?: StringFieldUpdateOperationsInput | string
    agenda_annouced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agenda_due?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type agendaCreateManyInput = {
    agenda_id?: number
    subject_class_id?: number | null
    agenda_title: string
    agenda_context: string
    agenda_annouced?: Date | string | null
    agenda_due?: Date | string | null
  }

  export type agendaUpdateManyMutationInput = {
    agenda_title?: StringFieldUpdateOperationsInput | string
    agenda_context?: StringFieldUpdateOperationsInput | string
    agenda_annouced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agenda_due?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type agendaUncheckedUpdateManyInput = {
    agenda_id?: IntFieldUpdateOperationsInput | number
    subject_class_id?: NullableIntFieldUpdateOperationsInput | number | null
    agenda_title?: StringFieldUpdateOperationsInput | string
    agenda_context?: StringFieldUpdateOperationsInput | string
    agenda_annouced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agenda_due?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type employeeCreateInput = {
    employee_fn: string
    employee_ln: string
    employee_dob: Date | string
    employee_join?: Date | string | null
    employee_img?: string | null
    employee_info?: string | null
    employee_degree?: string | null
    employee_exp?: Date | string | null
    employee_sal1?: number
    employee_sal2?: number | null
    employee_wh?: number | null
    active_class?: active_classCreateNestedManyWithoutEmployeeInput
    employee_role?: employee_roleCreateNestedManyWithoutEmployeeInput
    subject_class?: subject_classCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateInput = {
    employee_id?: number
    employee_fn: string
    employee_ln: string
    employee_dob: Date | string
    employee_join?: Date | string | null
    employee_img?: string | null
    employee_info?: string | null
    employee_degree?: string | null
    employee_exp?: Date | string | null
    employee_sal1?: number
    employee_sal2?: number | null
    employee_wh?: number | null
    active_class?: active_classUncheckedCreateNestedManyWithoutEmployeeInput
    employee_role?: employee_roleUncheckedCreateNestedManyWithoutEmployeeInput
    subject_class?: subject_classUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUpdateInput = {
    employee_fn?: StringFieldUpdateOperationsInput | string
    employee_ln?: StringFieldUpdateOperationsInput | string
    employee_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    employee_join?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_img?: NullableStringFieldUpdateOperationsInput | string | null
    employee_info?: NullableStringFieldUpdateOperationsInput | string | null
    employee_degree?: NullableStringFieldUpdateOperationsInput | string | null
    employee_exp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_sal1?: FloatFieldUpdateOperationsInput | number
    employee_sal2?: NullableFloatFieldUpdateOperationsInput | number | null
    employee_wh?: NullableFloatFieldUpdateOperationsInput | number | null
    active_class?: active_classUpdateManyWithoutEmployeeNestedInput
    employee_role?: employee_roleUpdateManyWithoutEmployeeNestedInput
    subject_class?: subject_classUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_fn?: StringFieldUpdateOperationsInput | string
    employee_ln?: StringFieldUpdateOperationsInput | string
    employee_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    employee_join?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_img?: NullableStringFieldUpdateOperationsInput | string | null
    employee_info?: NullableStringFieldUpdateOperationsInput | string | null
    employee_degree?: NullableStringFieldUpdateOperationsInput | string | null
    employee_exp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_sal1?: FloatFieldUpdateOperationsInput | number
    employee_sal2?: NullableFloatFieldUpdateOperationsInput | number | null
    employee_wh?: NullableFloatFieldUpdateOperationsInput | number | null
    active_class?: active_classUncheckedUpdateManyWithoutEmployeeNestedInput
    employee_role?: employee_roleUncheckedUpdateManyWithoutEmployeeNestedInput
    subject_class?: subject_classUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeCreateManyInput = {
    employee_id?: number
    employee_fn: string
    employee_ln: string
    employee_dob: Date | string
    employee_join?: Date | string | null
    employee_img?: string | null
    employee_info?: string | null
    employee_degree?: string | null
    employee_exp?: Date | string | null
    employee_sal1?: number
    employee_sal2?: number | null
    employee_wh?: number | null
  }

  export type employeeUpdateManyMutationInput = {
    employee_fn?: StringFieldUpdateOperationsInput | string
    employee_ln?: StringFieldUpdateOperationsInput | string
    employee_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    employee_join?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_img?: NullableStringFieldUpdateOperationsInput | string | null
    employee_info?: NullableStringFieldUpdateOperationsInput | string | null
    employee_degree?: NullableStringFieldUpdateOperationsInput | string | null
    employee_exp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_sal1?: FloatFieldUpdateOperationsInput | number
    employee_sal2?: NullableFloatFieldUpdateOperationsInput | number | null
    employee_wh?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type employeeUncheckedUpdateManyInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_fn?: StringFieldUpdateOperationsInput | string
    employee_ln?: StringFieldUpdateOperationsInput | string
    employee_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    employee_join?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_img?: NullableStringFieldUpdateOperationsInput | string | null
    employee_info?: NullableStringFieldUpdateOperationsInput | string | null
    employee_degree?: NullableStringFieldUpdateOperationsInput | string | null
    employee_exp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_sal1?: FloatFieldUpdateOperationsInput | number
    employee_sal2?: NullableFloatFieldUpdateOperationsInput | number | null
    employee_wh?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type employee_roleCreateInput = {
    roles: rolesCreateNestedOneWithoutEmployee_roleInput
    employee: employeeCreateNestedOneWithoutEmployee_roleInput
  }

  export type employee_roleUncheckedCreateInput = {
    employee_role_id?: number
    role_id: number
    employee_id: number
  }

  export type employee_roleUpdateInput = {
    roles?: rolesUpdateOneRequiredWithoutEmployee_roleNestedInput
    employee?: employeeUpdateOneRequiredWithoutEmployee_roleNestedInput
  }

  export type employee_roleUncheckedUpdateInput = {
    employee_role_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
  }

  export type employee_roleCreateManyInput = {
    employee_role_id?: number
    role_id: number
    employee_id: number
  }

  export type employee_roleUpdateManyMutationInput = {

  }

  export type employee_roleUncheckedUpdateManyInput = {
    employee_role_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
  }

  export type final_gradeCreateInput = {
    final_grade?: number | null
    test_period?: $Enums.final_grade_test_period | null
    created_at?: Date | string | null
    final_status?: string | null
    subjects?: subjectsCreateNestedOneWithoutFinal_gradeInput
    student?: studentCreateNestedOneWithoutFinal_gradeInput
  }

  export type final_gradeUncheckedCreateInput = {
    final_grade_id?: number
    subject_code?: string | null
    final_grade?: number | null
    student_id?: string | null
    test_period?: $Enums.final_grade_test_period | null
    created_at?: Date | string | null
    final_status?: string | null
  }

  export type final_gradeUpdateInput = {
    final_grade?: NullableFloatFieldUpdateOperationsInput | number | null
    test_period?: NullableEnumfinal_grade_test_periodFieldUpdateOperationsInput | $Enums.final_grade_test_period | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_status?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: subjectsUpdateOneWithoutFinal_gradeNestedInput
    student?: studentUpdateOneWithoutFinal_gradeNestedInput
  }

  export type final_gradeUncheckedUpdateInput = {
    final_grade_id?: IntFieldUpdateOperationsInput | number
    subject_code?: NullableStringFieldUpdateOperationsInput | string | null
    final_grade?: NullableFloatFieldUpdateOperationsInput | number | null
    student_id?: NullableStringFieldUpdateOperationsInput | string | null
    test_period?: NullableEnumfinal_grade_test_periodFieldUpdateOperationsInput | $Enums.final_grade_test_period | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type final_gradeCreateManyInput = {
    final_grade_id?: number
    subject_code?: string | null
    final_grade?: number | null
    student_id?: string | null
    test_period?: $Enums.final_grade_test_period | null
    created_at?: Date | string | null
    final_status?: string | null
  }

  export type final_gradeUpdateManyMutationInput = {
    final_grade?: NullableFloatFieldUpdateOperationsInput | number | null
    test_period?: NullableEnumfinal_grade_test_periodFieldUpdateOperationsInput | $Enums.final_grade_test_period | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type final_gradeUncheckedUpdateManyInput = {
    final_grade_id?: IntFieldUpdateOperationsInput | number
    subject_code?: NullableStringFieldUpdateOperationsInput | string | null
    final_grade?: NullableFloatFieldUpdateOperationsInput | number | null
    student_id?: NullableStringFieldUpdateOperationsInput | string | null
    test_period?: NullableEnumfinal_grade_test_periodFieldUpdateOperationsInput | $Enums.final_grade_test_period | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type jobCreateInput = {
    job_company: string
    job_title: string
    work_email?: string | null
    work_number?: string | null
    parent: parentCreateNestedOneWithoutJobInput
  }

  export type jobUncheckedCreateInput = {
    job_id?: number
    parent_id: number
    job_company: string
    job_title: string
    work_email?: string | null
    work_number?: string | null
  }

  export type jobUpdateInput = {
    job_company?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    work_email?: NullableStringFieldUpdateOperationsInput | string | null
    work_number?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: parentUpdateOneRequiredWithoutJobNestedInput
  }

  export type jobUncheckedUpdateInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    parent_id?: IntFieldUpdateOperationsInput | number
    job_company?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    work_email?: NullableStringFieldUpdateOperationsInput | string | null
    work_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type jobCreateManyInput = {
    job_id?: number
    parent_id: number
    job_company: string
    job_title: string
    work_email?: string | null
    work_number?: string | null
  }

  export type jobUpdateManyMutationInput = {
    job_company?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    work_email?: NullableStringFieldUpdateOperationsInput | string | null
    work_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type jobUncheckedUpdateManyInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    parent_id?: IntFieldUpdateOperationsInput | number
    job_company?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    work_email?: NullableStringFieldUpdateOperationsInput | string | null
    work_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type parentCreateInput = {
    parent_fn: string
    parent_ln: string
    parent_dob: Date | string
    parent_pers_number: string
    parent_pers_email?: string | null
    job?: jobCreateNestedManyWithoutParentInput
    student_student_father_idToparent?: studentCreateNestedManyWithoutParent_student_father_idToparentInput
    student_student_mother_idToparent?: studentCreateNestedManyWithoutParent_student_mother_idToparentInput
  }

  export type parentUncheckedCreateInput = {
    parent_id?: number
    parent_fn: string
    parent_ln: string
    parent_dob: Date | string
    parent_pers_number: string
    parent_pers_email?: string | null
    job?: jobUncheckedCreateNestedManyWithoutParentInput
    student_student_father_idToparent?: studentUncheckedCreateNestedManyWithoutParent_student_father_idToparentInput
    student_student_mother_idToparent?: studentUncheckedCreateNestedManyWithoutParent_student_mother_idToparentInput
  }

  export type parentUpdateInput = {
    parent_fn?: StringFieldUpdateOperationsInput | string
    parent_ln?: StringFieldUpdateOperationsInput | string
    parent_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_pers_number?: StringFieldUpdateOperationsInput | string
    parent_pers_email?: NullableStringFieldUpdateOperationsInput | string | null
    job?: jobUpdateManyWithoutParentNestedInput
    student_student_father_idToparent?: studentUpdateManyWithoutParent_student_father_idToparentNestedInput
    student_student_mother_idToparent?: studentUpdateManyWithoutParent_student_mother_idToparentNestedInput
  }

  export type parentUncheckedUpdateInput = {
    parent_id?: IntFieldUpdateOperationsInput | number
    parent_fn?: StringFieldUpdateOperationsInput | string
    parent_ln?: StringFieldUpdateOperationsInput | string
    parent_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_pers_number?: StringFieldUpdateOperationsInput | string
    parent_pers_email?: NullableStringFieldUpdateOperationsInput | string | null
    job?: jobUncheckedUpdateManyWithoutParentNestedInput
    student_student_father_idToparent?: studentUncheckedUpdateManyWithoutParent_student_father_idToparentNestedInput
    student_student_mother_idToparent?: studentUncheckedUpdateManyWithoutParent_student_mother_idToparentNestedInput
  }

  export type parentCreateManyInput = {
    parent_id?: number
    parent_fn: string
    parent_ln: string
    parent_dob: Date | string
    parent_pers_number: string
    parent_pers_email?: string | null
  }

  export type parentUpdateManyMutationInput = {
    parent_fn?: StringFieldUpdateOperationsInput | string
    parent_ln?: StringFieldUpdateOperationsInput | string
    parent_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_pers_number?: StringFieldUpdateOperationsInput | string
    parent_pers_email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type parentUncheckedUpdateManyInput = {
    parent_id?: IntFieldUpdateOperationsInput | number
    parent_fn?: StringFieldUpdateOperationsInput | string
    parent_ln?: StringFieldUpdateOperationsInput | string
    parent_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_pers_number?: StringFieldUpdateOperationsInput | string
    parent_pers_email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type periodCreateInput = {
    period: number
    period_status: string
    active_class_active_class_periodToperiod?: active_classCreateNestedManyWithoutPeriod_active_class_periodToperiodInput
  }

  export type periodUncheckedCreateInput = {
    period: number
    period_status: string
    active_class_active_class_periodToperiod?: active_classUncheckedCreateNestedManyWithoutPeriod_active_class_periodToperiodInput
  }

  export type periodUpdateInput = {
    period?: IntFieldUpdateOperationsInput | number
    period_status?: StringFieldUpdateOperationsInput | string
    active_class_active_class_periodToperiod?: active_classUpdateManyWithoutPeriod_active_class_periodToperiodNestedInput
  }

  export type periodUncheckedUpdateInput = {
    period?: IntFieldUpdateOperationsInput | number
    period_status?: StringFieldUpdateOperationsInput | string
    active_class_active_class_periodToperiod?: active_classUncheckedUpdateManyWithoutPeriod_active_class_periodToperiodNestedInput
  }

  export type periodCreateManyInput = {
    period: number
    period_status: string
  }

  export type periodUpdateManyMutationInput = {
    period?: IntFieldUpdateOperationsInput | number
    period_status?: StringFieldUpdateOperationsInput | string
  }

  export type periodUncheckedUpdateManyInput = {
    period?: IntFieldUpdateOperationsInput | number
    period_status?: StringFieldUpdateOperationsInput | string
  }

  export type rolesCreateInput = {
    role_name: string
    role_description?: string | null
    employee_role?: employee_roleCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateInput = {
    role_id?: number
    role_name: string
    role_description?: string | null
    employee_role?: employee_roleUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesUpdateInput = {
    role_name?: StringFieldUpdateOperationsInput | string
    role_description?: NullableStringFieldUpdateOperationsInput | string | null
    employee_role?: employee_roleUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    role_description?: NullableStringFieldUpdateOperationsInput | string | null
    employee_role?: employee_roleUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type rolesCreateManyInput = {
    role_id?: number
    role_name: string
    role_description?: string | null
  }

  export type rolesUpdateManyMutationInput = {
    role_name?: StringFieldUpdateOperationsInput | string
    role_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rolesUncheckedUpdateManyInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    role_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type school_emailCreateInput = {
    school_email: string
    school_email_label: string
    school_info: school_infoCreateNestedOneWithoutSchool_emailInput
  }

  export type school_emailUncheckedCreateInput = {
    school_num_id?: number
    school_reg: number
    school_email: string
    school_email_label: string
  }

  export type school_emailUpdateInput = {
    school_email?: StringFieldUpdateOperationsInput | string
    school_email_label?: StringFieldUpdateOperationsInput | string
    school_info?: school_infoUpdateOneRequiredWithoutSchool_emailNestedInput
  }

  export type school_emailUncheckedUpdateInput = {
    school_num_id?: IntFieldUpdateOperationsInput | number
    school_reg?: IntFieldUpdateOperationsInput | number
    school_email?: StringFieldUpdateOperationsInput | string
    school_email_label?: StringFieldUpdateOperationsInput | string
  }

  export type school_emailCreateManyInput = {
    school_num_id?: number
    school_reg: number
    school_email: string
    school_email_label: string
  }

  export type school_emailUpdateManyMutationInput = {
    school_email?: StringFieldUpdateOperationsInput | string
    school_email_label?: StringFieldUpdateOperationsInput | string
  }

  export type school_emailUncheckedUpdateManyInput = {
    school_num_id?: IntFieldUpdateOperationsInput | number
    school_reg?: IntFieldUpdateOperationsInput | number
    school_email?: StringFieldUpdateOperationsInput | string
    school_email_label?: StringFieldUpdateOperationsInput | string
  }

  export type school_infoCreateInput = {
    school_reg: number
    school_name: string
    school_address: string
    school_lat: number
    school_long: number
    school_princ: string
    school_email?: school_emailCreateNestedManyWithoutSchool_infoInput
    school_num?: school_numCreateNestedManyWithoutSchool_infoInput
  }

  export type school_infoUncheckedCreateInput = {
    school_reg: number
    school_name: string
    school_address: string
    school_lat: number
    school_long: number
    school_princ: string
    school_email?: school_emailUncheckedCreateNestedManyWithoutSchool_infoInput
    school_num?: school_numUncheckedCreateNestedManyWithoutSchool_infoInput
  }

  export type school_infoUpdateInput = {
    school_reg?: IntFieldUpdateOperationsInput | number
    school_name?: StringFieldUpdateOperationsInput | string
    school_address?: StringFieldUpdateOperationsInput | string
    school_lat?: FloatFieldUpdateOperationsInput | number
    school_long?: FloatFieldUpdateOperationsInput | number
    school_princ?: StringFieldUpdateOperationsInput | string
    school_email?: school_emailUpdateManyWithoutSchool_infoNestedInput
    school_num?: school_numUpdateManyWithoutSchool_infoNestedInput
  }

  export type school_infoUncheckedUpdateInput = {
    school_reg?: IntFieldUpdateOperationsInput | number
    school_name?: StringFieldUpdateOperationsInput | string
    school_address?: StringFieldUpdateOperationsInput | string
    school_lat?: FloatFieldUpdateOperationsInput | number
    school_long?: FloatFieldUpdateOperationsInput | number
    school_princ?: StringFieldUpdateOperationsInput | string
    school_email?: school_emailUncheckedUpdateManyWithoutSchool_infoNestedInput
    school_num?: school_numUncheckedUpdateManyWithoutSchool_infoNestedInput
  }

  export type school_infoCreateManyInput = {
    school_reg: number
    school_name: string
    school_address: string
    school_lat: number
    school_long: number
    school_princ: string
  }

  export type school_infoUpdateManyMutationInput = {
    school_reg?: IntFieldUpdateOperationsInput | number
    school_name?: StringFieldUpdateOperationsInput | string
    school_address?: StringFieldUpdateOperationsInput | string
    school_lat?: FloatFieldUpdateOperationsInput | number
    school_long?: FloatFieldUpdateOperationsInput | number
    school_princ?: StringFieldUpdateOperationsInput | string
  }

  export type school_infoUncheckedUpdateManyInput = {
    school_reg?: IntFieldUpdateOperationsInput | number
    school_name?: StringFieldUpdateOperationsInput | string
    school_address?: StringFieldUpdateOperationsInput | string
    school_lat?: FloatFieldUpdateOperationsInput | number
    school_long?: FloatFieldUpdateOperationsInput | number
    school_princ?: StringFieldUpdateOperationsInput | string
  }

  export type school_numCreateInput = {
    school_phone: string
    school_phone_label: string
    school_info: school_infoCreateNestedOneWithoutSchool_numInput
  }

  export type school_numUncheckedCreateInput = {
    school_num_id?: number
    school_reg: number
    school_phone: string
    school_phone_label: string
  }

  export type school_numUpdateInput = {
    school_phone?: StringFieldUpdateOperationsInput | string
    school_phone_label?: StringFieldUpdateOperationsInput | string
    school_info?: school_infoUpdateOneRequiredWithoutSchool_numNestedInput
  }

  export type school_numUncheckedUpdateInput = {
    school_num_id?: IntFieldUpdateOperationsInput | number
    school_reg?: IntFieldUpdateOperationsInput | number
    school_phone?: StringFieldUpdateOperationsInput | string
    school_phone_label?: StringFieldUpdateOperationsInput | string
  }

  export type school_numCreateManyInput = {
    school_num_id?: number
    school_reg: number
    school_phone: string
    school_phone_label: string
  }

  export type school_numUpdateManyMutationInput = {
    school_phone?: StringFieldUpdateOperationsInput | string
    school_phone_label?: StringFieldUpdateOperationsInput | string
  }

  export type school_numUncheckedUpdateManyInput = {
    school_num_id?: IntFieldUpdateOperationsInput | number
    school_reg?: IntFieldUpdateOperationsInput | number
    school_phone?: StringFieldUpdateOperationsInput | string
    school_phone_label?: StringFieldUpdateOperationsInput | string
  }

  export type studentCreateInput = {
    student_id: string
    student_fname: string
    student_lname: string
    student_dob: Date | string
    student_account: string
    student_pass: string
    note?: string | null
    final_grade?: final_gradeCreateNestedManyWithoutStudentInput
    parent_student_father_idToparent: parentCreateNestedOneWithoutStudent_student_father_idToparentInput
    parent_student_mother_idToparent: parentCreateNestedOneWithoutStudent_student_mother_idToparentInput
    test_result?: test_resultCreateNestedManyWithoutStudentInput
  }

  export type studentUncheckedCreateInput = {
    student_id: string
    mother_id: number
    father_id: number
    student_fname: string
    student_lname: string
    student_dob: Date | string
    student_account: string
    student_pass: string
    note?: string | null
    final_grade?: final_gradeUncheckedCreateNestedManyWithoutStudentInput
    test_result?: test_resultUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentUpdateInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    student_fname?: StringFieldUpdateOperationsInput | string
    student_lname?: StringFieldUpdateOperationsInput | string
    student_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    student_account?: StringFieldUpdateOperationsInput | string
    student_pass?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    final_grade?: final_gradeUpdateManyWithoutStudentNestedInput
    parent_student_father_idToparent?: parentUpdateOneRequiredWithoutStudent_student_father_idToparentNestedInput
    parent_student_mother_idToparent?: parentUpdateOneRequiredWithoutStudent_student_mother_idToparentNestedInput
    test_result?: test_resultUpdateManyWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    mother_id?: IntFieldUpdateOperationsInput | number
    father_id?: IntFieldUpdateOperationsInput | number
    student_fname?: StringFieldUpdateOperationsInput | string
    student_lname?: StringFieldUpdateOperationsInput | string
    student_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    student_account?: StringFieldUpdateOperationsInput | string
    student_pass?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    final_grade?: final_gradeUncheckedUpdateManyWithoutStudentNestedInput
    test_result?: test_resultUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type studentCreateManyInput = {
    student_id: string
    mother_id: number
    father_id: number
    student_fname: string
    student_lname: string
    student_dob: Date | string
    student_account: string
    student_pass: string
    note?: string | null
  }

  export type studentUpdateManyMutationInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    student_fname?: StringFieldUpdateOperationsInput | string
    student_lname?: StringFieldUpdateOperationsInput | string
    student_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    student_account?: StringFieldUpdateOperationsInput | string
    student_pass?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type studentUncheckedUpdateManyInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    mother_id?: IntFieldUpdateOperationsInput | number
    father_id?: IntFieldUpdateOperationsInput | number
    student_fname?: StringFieldUpdateOperationsInput | string
    student_lname?: StringFieldUpdateOperationsInput | string
    student_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    student_account?: StringFieldUpdateOperationsInput | string
    student_pass?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type subject_classCreateInput = {
    agenda?: agendaCreateNestedManyWithoutSubject_classInput
    employee?: employeeCreateNestedOneWithoutSubject_classInput
    subjects: subjectsCreateNestedOneWithoutSubject_classInput
    test?: testCreateNestedManyWithoutSubject_classInput
  }

  export type subject_classUncheckedCreateInput = {
    subject_class_id?: number
    subject_code: string
    instructor?: number | null
    agenda?: agendaUncheckedCreateNestedManyWithoutSubject_classInput
    test?: testUncheckedCreateNestedManyWithoutSubject_classInput
  }

  export type subject_classUpdateInput = {
    agenda?: agendaUpdateManyWithoutSubject_classNestedInput
    employee?: employeeUpdateOneWithoutSubject_classNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutSubject_classNestedInput
    test?: testUpdateManyWithoutSubject_classNestedInput
  }

  export type subject_classUncheckedUpdateInput = {
    subject_class_id?: IntFieldUpdateOperationsInput | number
    subject_code?: StringFieldUpdateOperationsInput | string
    instructor?: NullableIntFieldUpdateOperationsInput | number | null
    agenda?: agendaUncheckedUpdateManyWithoutSubject_classNestedInput
    test?: testUncheckedUpdateManyWithoutSubject_classNestedInput
  }

  export type subject_classCreateManyInput = {
    subject_class_id?: number
    subject_code: string
    instructor?: number | null
  }

  export type subject_classUpdateManyMutationInput = {

  }

  export type subject_classUncheckedUpdateManyInput = {
    subject_class_id?: IntFieldUpdateOperationsInput | number
    subject_code?: StringFieldUpdateOperationsInput | string
    instructor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type subjectsCreateInput = {
    subject_code: string
    subject_name: string
    subject_cat?: $Enums.subjects_subject_cat | null
    final_grade?: final_gradeCreateNestedManyWithoutSubjectsInput
    subject_class?: subject_classCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsUncheckedCreateInput = {
    subject_code: string
    subject_name: string
    subject_cat?: $Enums.subjects_subject_cat | null
    final_grade?: final_gradeUncheckedCreateNestedManyWithoutSubjectsInput
    subject_class?: subject_classUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsUpdateInput = {
    subject_code?: StringFieldUpdateOperationsInput | string
    subject_name?: StringFieldUpdateOperationsInput | string
    subject_cat?: NullableEnumsubjects_subject_catFieldUpdateOperationsInput | $Enums.subjects_subject_cat | null
    final_grade?: final_gradeUpdateManyWithoutSubjectsNestedInput
    subject_class?: subject_classUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectsUncheckedUpdateInput = {
    subject_code?: StringFieldUpdateOperationsInput | string
    subject_name?: StringFieldUpdateOperationsInput | string
    subject_cat?: NullableEnumsubjects_subject_catFieldUpdateOperationsInput | $Enums.subjects_subject_cat | null
    final_grade?: final_gradeUncheckedUpdateManyWithoutSubjectsNestedInput
    subject_class?: subject_classUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectsCreateManyInput = {
    subject_code: string
    subject_name: string
    subject_cat?: $Enums.subjects_subject_cat | null
  }

  export type subjectsUpdateManyMutationInput = {
    subject_code?: StringFieldUpdateOperationsInput | string
    subject_name?: StringFieldUpdateOperationsInput | string
    subject_cat?: NullableEnumsubjects_subject_catFieldUpdateOperationsInput | $Enums.subjects_subject_cat | null
  }

  export type subjectsUncheckedUpdateManyInput = {
    subject_code?: StringFieldUpdateOperationsInput | string
    subject_name?: StringFieldUpdateOperationsInput | string
    subject_cat?: NullableEnumsubjects_subject_catFieldUpdateOperationsInput | $Enums.subjects_subject_cat | null
  }

  export type testCreateInput = {
    test_title?: string | null
    test_description?: string | null
    test_total?: number | null
    test_visibility?: string | null
    test_annouced?: Date | string | null
    test_due?: Date | string | null
    test_period?: $Enums.test_test_period | null
    subject_class?: subject_classCreateNestedOneWithoutTestInput
    test_result?: test_resultCreateNestedManyWithoutTestInput
  }

  export type testUncheckedCreateInput = {
    test_id?: number
    test_title?: string | null
    test_description?: string | null
    subject_class_id?: number | null
    test_total?: number | null
    test_visibility?: string | null
    test_annouced?: Date | string | null
    test_due?: Date | string | null
    test_period?: $Enums.test_test_period | null
    test_result?: test_resultUncheckedCreateNestedManyWithoutTestInput
  }

  export type testUpdateInput = {
    test_title?: NullableStringFieldUpdateOperationsInput | string | null
    test_description?: NullableStringFieldUpdateOperationsInput | string | null
    test_total?: NullableIntFieldUpdateOperationsInput | number | null
    test_visibility?: NullableStringFieldUpdateOperationsInput | string | null
    test_annouced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_due?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_period?: NullableEnumtest_test_periodFieldUpdateOperationsInput | $Enums.test_test_period | null
    subject_class?: subject_classUpdateOneWithoutTestNestedInput
    test_result?: test_resultUpdateManyWithoutTestNestedInput
  }

  export type testUncheckedUpdateInput = {
    test_id?: IntFieldUpdateOperationsInput | number
    test_title?: NullableStringFieldUpdateOperationsInput | string | null
    test_description?: NullableStringFieldUpdateOperationsInput | string | null
    subject_class_id?: NullableIntFieldUpdateOperationsInput | number | null
    test_total?: NullableIntFieldUpdateOperationsInput | number | null
    test_visibility?: NullableStringFieldUpdateOperationsInput | string | null
    test_annouced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_due?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_period?: NullableEnumtest_test_periodFieldUpdateOperationsInput | $Enums.test_test_period | null
    test_result?: test_resultUncheckedUpdateManyWithoutTestNestedInput
  }

  export type testCreateManyInput = {
    test_id?: number
    test_title?: string | null
    test_description?: string | null
    subject_class_id?: number | null
    test_total?: number | null
    test_visibility?: string | null
    test_annouced?: Date | string | null
    test_due?: Date | string | null
    test_period?: $Enums.test_test_period | null
  }

  export type testUpdateManyMutationInput = {
    test_title?: NullableStringFieldUpdateOperationsInput | string | null
    test_description?: NullableStringFieldUpdateOperationsInput | string | null
    test_total?: NullableIntFieldUpdateOperationsInput | number | null
    test_visibility?: NullableStringFieldUpdateOperationsInput | string | null
    test_annouced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_due?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_period?: NullableEnumtest_test_periodFieldUpdateOperationsInput | $Enums.test_test_period | null
  }

  export type testUncheckedUpdateManyInput = {
    test_id?: IntFieldUpdateOperationsInput | number
    test_title?: NullableStringFieldUpdateOperationsInput | string | null
    test_description?: NullableStringFieldUpdateOperationsInput | string | null
    subject_class_id?: NullableIntFieldUpdateOperationsInput | number | null
    test_total?: NullableIntFieldUpdateOperationsInput | number | null
    test_visibility?: NullableStringFieldUpdateOperationsInput | string | null
    test_annouced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_due?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_period?: NullableEnumtest_test_periodFieldUpdateOperationsInput | $Enums.test_test_period | null
  }

  export type test_resultCreateInput = {
    test_result?: number
    test_note?: string | null
    test: testCreateNestedOneWithoutTest_resultInput
    student?: studentCreateNestedOneWithoutTest_resultInput
  }

  export type test_resultUncheckedCreateInput = {
    test_result_id?: number
    test_id: number
    student_id?: string | null
    test_result?: number
    test_note?: string | null
  }

  export type test_resultUpdateInput = {
    test_result?: FloatFieldUpdateOperationsInput | number
    test_note?: NullableStringFieldUpdateOperationsInput | string | null
    test?: testUpdateOneRequiredWithoutTest_resultNestedInput
    student?: studentUpdateOneWithoutTest_resultNestedInput
  }

  export type test_resultUncheckedUpdateInput = {
    test_result_id?: IntFieldUpdateOperationsInput | number
    test_id?: IntFieldUpdateOperationsInput | number
    student_id?: NullableStringFieldUpdateOperationsInput | string | null
    test_result?: FloatFieldUpdateOperationsInput | number
    test_note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type test_resultCreateManyInput = {
    test_result_id?: number
    test_id: number
    student_id?: string | null
    test_result?: number
    test_note?: string | null
  }

  export type test_resultUpdateManyMutationInput = {
    test_result?: FloatFieldUpdateOperationsInput | number
    test_note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type test_resultUncheckedUpdateManyInput = {
    test_result_id?: IntFieldUpdateOperationsInput | number
    test_id?: IntFieldUpdateOperationsInput | number
    student_id?: NullableStringFieldUpdateOperationsInput | string | null
    test_result?: FloatFieldUpdateOperationsInput | number
    test_note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type classesCreateInput = {
    class_code: string
    class_name?: string | null
    class_base?: string | null
    active_class?: active_classCreateNestedManyWithoutRenamedclassInput
  }

  export type classesUncheckedCreateInput = {
    class_code: string
    class_name?: string | null
    class_base?: string | null
    active_class?: active_classUncheckedCreateNestedManyWithoutRenamedclassInput
  }

  export type classesUpdateInput = {
    class_code?: StringFieldUpdateOperationsInput | string
    class_name?: NullableStringFieldUpdateOperationsInput | string | null
    class_base?: NullableStringFieldUpdateOperationsInput | string | null
    active_class?: active_classUpdateManyWithoutRenamedclassNestedInput
  }

  export type classesUncheckedUpdateInput = {
    class_code?: StringFieldUpdateOperationsInput | string
    class_name?: NullableStringFieldUpdateOperationsInput | string | null
    class_base?: NullableStringFieldUpdateOperationsInput | string | null
    active_class?: active_classUncheckedUpdateManyWithoutRenamedclassNestedInput
  }

  export type classesCreateManyInput = {
    class_code: string
    class_name?: string | null
    class_base?: string | null
  }

  export type classesUpdateManyMutationInput = {
    class_code?: StringFieldUpdateOperationsInput | string
    class_name?: NullableStringFieldUpdateOperationsInput | string | null
    class_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type classesUncheckedUpdateManyInput = {
    class_code?: StringFieldUpdateOperationsInput | string
    class_name?: NullableStringFieldUpdateOperationsInput | string | null
    class_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type parent_formCreateInput = {
    parent_form_content: Uint8Array
    parent_form_created?: Date | string | null
  }

  export type parent_formUncheckedCreateInput = {
    parent_form_id?: number
    parent_form_content: Uint8Array
    parent_form_created?: Date | string | null
  }

  export type parent_formUpdateInput = {
    parent_form_content?: BytesFieldUpdateOperationsInput | Uint8Array
    parent_form_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type parent_formUncheckedUpdateInput = {
    parent_form_id?: IntFieldUpdateOperationsInput | number
    parent_form_content?: BytesFieldUpdateOperationsInput | Uint8Array
    parent_form_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type parent_formCreateManyInput = {
    parent_form_id?: number
    parent_form_content: Uint8Array
    parent_form_created?: Date | string | null
  }

  export type parent_formUpdateManyMutationInput = {
    parent_form_content?: BytesFieldUpdateOperationsInput | Uint8Array
    parent_form_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type parent_formUncheckedUpdateManyInput = {
    parent_form_id?: IntFieldUpdateOperationsInput | number
    parent_form_content?: BytesFieldUpdateOperationsInput | Uint8Array
    parent_form_created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ClassesNullableScalarRelationFilter = {
    is?: classesWhereInput | null
    isNot?: classesWhereInput | null
  }

  export type PeriodNullableScalarRelationFilter = {
    is?: periodWhereInput | null
    isNot?: periodWhereInput | null
  }

  export type EmployeeNullableScalarRelationFilter = {
    is?: employeeWhereInput | null
    isNot?: employeeWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type active_classOrderByRelevanceInput = {
    fields: active_classOrderByRelevanceFieldEnum | active_classOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type active_classCountOrderByAggregateInput = {
    active_class_id?: SortOrder
    class_code?: SortOrder
    period?: SortOrder
    class_coordinator?: SortOrder
  }

  export type active_classAvgOrderByAggregateInput = {
    active_class_id?: SortOrder
    period?: SortOrder
    class_coordinator?: SortOrder
  }

  export type active_classMaxOrderByAggregateInput = {
    active_class_id?: SortOrder
    class_code?: SortOrder
    period?: SortOrder
    class_coordinator?: SortOrder
  }

  export type active_classMinOrderByAggregateInput = {
    active_class_id?: SortOrder
    class_code?: SortOrder
    period?: SortOrder
    class_coordinator?: SortOrder
  }

  export type active_classSumOrderByAggregateInput = {
    active_class_id?: SortOrder
    period?: SortOrder
    class_coordinator?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type Subject_classNullableScalarRelationFilter = {
    is?: subject_classWhereInput | null
    isNot?: subject_classWhereInput | null
  }

  export type agendaOrderByRelevanceInput = {
    fields: agendaOrderByRelevanceFieldEnum | agendaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type agendaCountOrderByAggregateInput = {
    agenda_id?: SortOrder
    subject_class_id?: SortOrder
    agenda_title?: SortOrder
    agenda_context?: SortOrder
    agenda_annouced?: SortOrder
    agenda_due?: SortOrder
  }

  export type agendaAvgOrderByAggregateInput = {
    agenda_id?: SortOrder
    subject_class_id?: SortOrder
  }

  export type agendaMaxOrderByAggregateInput = {
    agenda_id?: SortOrder
    subject_class_id?: SortOrder
    agenda_title?: SortOrder
    agenda_context?: SortOrder
    agenda_annouced?: SortOrder
    agenda_due?: SortOrder
  }

  export type agendaMinOrderByAggregateInput = {
    agenda_id?: SortOrder
    subject_class_id?: SortOrder
    agenda_title?: SortOrder
    agenda_context?: SortOrder
    agenda_annouced?: SortOrder
    agenda_due?: SortOrder
  }

  export type agendaSumOrderByAggregateInput = {
    agenda_id?: SortOrder
    subject_class_id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type Active_classListRelationFilter = {
    every?: active_classWhereInput
    some?: active_classWhereInput
    none?: active_classWhereInput
  }

  export type Employee_roleListRelationFilter = {
    every?: employee_roleWhereInput
    some?: employee_roleWhereInput
    none?: employee_roleWhereInput
  }

  export type Subject_classListRelationFilter = {
    every?: subject_classWhereInput
    some?: subject_classWhereInput
    none?: subject_classWhereInput
  }

  export type active_classOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type employee_roleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subject_classOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type employeeOrderByRelevanceInput = {
    fields: employeeOrderByRelevanceFieldEnum | employeeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type employeeCountOrderByAggregateInput = {
    employee_id?: SortOrder
    employee_fn?: SortOrder
    employee_ln?: SortOrder
    employee_dob?: SortOrder
    employee_join?: SortOrder
    employee_img?: SortOrder
    employee_info?: SortOrder
    employee_degree?: SortOrder
    employee_exp?: SortOrder
    employee_sal1?: SortOrder
    employee_sal2?: SortOrder
    employee_wh?: SortOrder
  }

  export type employeeAvgOrderByAggregateInput = {
    employee_id?: SortOrder
    employee_sal1?: SortOrder
    employee_sal2?: SortOrder
    employee_wh?: SortOrder
  }

  export type employeeMaxOrderByAggregateInput = {
    employee_id?: SortOrder
    employee_fn?: SortOrder
    employee_ln?: SortOrder
    employee_dob?: SortOrder
    employee_join?: SortOrder
    employee_img?: SortOrder
    employee_info?: SortOrder
    employee_degree?: SortOrder
    employee_exp?: SortOrder
    employee_sal1?: SortOrder
    employee_sal2?: SortOrder
    employee_wh?: SortOrder
  }

  export type employeeMinOrderByAggregateInput = {
    employee_id?: SortOrder
    employee_fn?: SortOrder
    employee_ln?: SortOrder
    employee_dob?: SortOrder
    employee_join?: SortOrder
    employee_img?: SortOrder
    employee_info?: SortOrder
    employee_degree?: SortOrder
    employee_exp?: SortOrder
    employee_sal1?: SortOrder
    employee_sal2?: SortOrder
    employee_wh?: SortOrder
  }

  export type employeeSumOrderByAggregateInput = {
    employee_id?: SortOrder
    employee_sal1?: SortOrder
    employee_sal2?: SortOrder
    employee_wh?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type RolesScalarRelationFilter = {
    is?: rolesWhereInput
    isNot?: rolesWhereInput
  }

  export type EmployeeScalarRelationFilter = {
    is?: employeeWhereInput
    isNot?: employeeWhereInput
  }

  export type employee_roleCountOrderByAggregateInput = {
    employee_role_id?: SortOrder
    role_id?: SortOrder
    employee_id?: SortOrder
  }

  export type employee_roleAvgOrderByAggregateInput = {
    employee_role_id?: SortOrder
    role_id?: SortOrder
    employee_id?: SortOrder
  }

  export type employee_roleMaxOrderByAggregateInput = {
    employee_role_id?: SortOrder
    role_id?: SortOrder
    employee_id?: SortOrder
  }

  export type employee_roleMinOrderByAggregateInput = {
    employee_role_id?: SortOrder
    role_id?: SortOrder
    employee_id?: SortOrder
  }

  export type employee_roleSumOrderByAggregateInput = {
    employee_role_id?: SortOrder
    role_id?: SortOrder
    employee_id?: SortOrder
  }

  export type Enumfinal_grade_test_periodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.final_grade_test_period | Enumfinal_grade_test_periodFieldRefInput<$PrismaModel> | null
    in?: $Enums.final_grade_test_period[] | null
    notIn?: $Enums.final_grade_test_period[] | null
    not?: NestedEnumfinal_grade_test_periodNullableFilter<$PrismaModel> | $Enums.final_grade_test_period | null
  }

  export type SubjectsNullableScalarRelationFilter = {
    is?: subjectsWhereInput | null
    isNot?: subjectsWhereInput | null
  }

  export type StudentNullableScalarRelationFilter = {
    is?: studentWhereInput | null
    isNot?: studentWhereInput | null
  }

  export type final_gradeOrderByRelevanceInput = {
    fields: final_gradeOrderByRelevanceFieldEnum | final_gradeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type final_gradeCountOrderByAggregateInput = {
    final_grade_id?: SortOrder
    subject_code?: SortOrder
    final_grade?: SortOrder
    student_id?: SortOrder
    test_period?: SortOrder
    created_at?: SortOrder
    final_status?: SortOrder
  }

  export type final_gradeAvgOrderByAggregateInput = {
    final_grade_id?: SortOrder
    final_grade?: SortOrder
  }

  export type final_gradeMaxOrderByAggregateInput = {
    final_grade_id?: SortOrder
    subject_code?: SortOrder
    final_grade?: SortOrder
    student_id?: SortOrder
    test_period?: SortOrder
    created_at?: SortOrder
    final_status?: SortOrder
  }

  export type final_gradeMinOrderByAggregateInput = {
    final_grade_id?: SortOrder
    subject_code?: SortOrder
    final_grade?: SortOrder
    student_id?: SortOrder
    test_period?: SortOrder
    created_at?: SortOrder
    final_status?: SortOrder
  }

  export type final_gradeSumOrderByAggregateInput = {
    final_grade_id?: SortOrder
    final_grade?: SortOrder
  }

  export type Enumfinal_grade_test_periodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.final_grade_test_period | Enumfinal_grade_test_periodFieldRefInput<$PrismaModel> | null
    in?: $Enums.final_grade_test_period[] | null
    notIn?: $Enums.final_grade_test_period[] | null
    not?: NestedEnumfinal_grade_test_periodNullableWithAggregatesFilter<$PrismaModel> | $Enums.final_grade_test_period | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumfinal_grade_test_periodNullableFilter<$PrismaModel>
    _max?: NestedEnumfinal_grade_test_periodNullableFilter<$PrismaModel>
  }

  export type ParentScalarRelationFilter = {
    is?: parentWhereInput
    isNot?: parentWhereInput
  }

  export type jobOrderByRelevanceInput = {
    fields: jobOrderByRelevanceFieldEnum | jobOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type jobCountOrderByAggregateInput = {
    job_id?: SortOrder
    parent_id?: SortOrder
    job_company?: SortOrder
    job_title?: SortOrder
    work_email?: SortOrder
    work_number?: SortOrder
  }

  export type jobAvgOrderByAggregateInput = {
    job_id?: SortOrder
    parent_id?: SortOrder
  }

  export type jobMaxOrderByAggregateInput = {
    job_id?: SortOrder
    parent_id?: SortOrder
    job_company?: SortOrder
    job_title?: SortOrder
    work_email?: SortOrder
    work_number?: SortOrder
  }

  export type jobMinOrderByAggregateInput = {
    job_id?: SortOrder
    parent_id?: SortOrder
    job_company?: SortOrder
    job_title?: SortOrder
    work_email?: SortOrder
    work_number?: SortOrder
  }

  export type jobSumOrderByAggregateInput = {
    job_id?: SortOrder
    parent_id?: SortOrder
  }

  export type JobListRelationFilter = {
    every?: jobWhereInput
    some?: jobWhereInput
    none?: jobWhereInput
  }

  export type StudentListRelationFilter = {
    every?: studentWhereInput
    some?: studentWhereInput
    none?: studentWhereInput
  }

  export type jobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type studentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type parentOrderByRelevanceInput = {
    fields: parentOrderByRelevanceFieldEnum | parentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type parentCountOrderByAggregateInput = {
    parent_id?: SortOrder
    parent_fn?: SortOrder
    parent_ln?: SortOrder
    parent_dob?: SortOrder
    parent_pers_number?: SortOrder
    parent_pers_email?: SortOrder
  }

  export type parentAvgOrderByAggregateInput = {
    parent_id?: SortOrder
  }

  export type parentMaxOrderByAggregateInput = {
    parent_id?: SortOrder
    parent_fn?: SortOrder
    parent_ln?: SortOrder
    parent_dob?: SortOrder
    parent_pers_number?: SortOrder
    parent_pers_email?: SortOrder
  }

  export type parentMinOrderByAggregateInput = {
    parent_id?: SortOrder
    parent_fn?: SortOrder
    parent_ln?: SortOrder
    parent_dob?: SortOrder
    parent_pers_number?: SortOrder
    parent_pers_email?: SortOrder
  }

  export type parentSumOrderByAggregateInput = {
    parent_id?: SortOrder
  }

  export type periodOrderByRelevanceInput = {
    fields: periodOrderByRelevanceFieldEnum | periodOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type periodCountOrderByAggregateInput = {
    period?: SortOrder
    period_status?: SortOrder
  }

  export type periodAvgOrderByAggregateInput = {
    period?: SortOrder
  }

  export type periodMaxOrderByAggregateInput = {
    period?: SortOrder
    period_status?: SortOrder
  }

  export type periodMinOrderByAggregateInput = {
    period?: SortOrder
    period_status?: SortOrder
  }

  export type periodSumOrderByAggregateInput = {
    period?: SortOrder
  }

  export type rolesOrderByRelevanceInput = {
    fields: rolesOrderByRelevanceFieldEnum | rolesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type rolesCountOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    role_description?: SortOrder
  }

  export type rolesAvgOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type rolesMaxOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    role_description?: SortOrder
  }

  export type rolesMinOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    role_description?: SortOrder
  }

  export type rolesSumOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type School_infoScalarRelationFilter = {
    is?: school_infoWhereInput
    isNot?: school_infoWhereInput
  }

  export type school_emailOrderByRelevanceInput = {
    fields: school_emailOrderByRelevanceFieldEnum | school_emailOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type school_emailCountOrderByAggregateInput = {
    school_num_id?: SortOrder
    school_reg?: SortOrder
    school_email?: SortOrder
    school_email_label?: SortOrder
  }

  export type school_emailAvgOrderByAggregateInput = {
    school_num_id?: SortOrder
    school_reg?: SortOrder
  }

  export type school_emailMaxOrderByAggregateInput = {
    school_num_id?: SortOrder
    school_reg?: SortOrder
    school_email?: SortOrder
    school_email_label?: SortOrder
  }

  export type school_emailMinOrderByAggregateInput = {
    school_num_id?: SortOrder
    school_reg?: SortOrder
    school_email?: SortOrder
    school_email_label?: SortOrder
  }

  export type school_emailSumOrderByAggregateInput = {
    school_num_id?: SortOrder
    school_reg?: SortOrder
  }

  export type School_emailListRelationFilter = {
    every?: school_emailWhereInput
    some?: school_emailWhereInput
    none?: school_emailWhereInput
  }

  export type School_numListRelationFilter = {
    every?: school_numWhereInput
    some?: school_numWhereInput
    none?: school_numWhereInput
  }

  export type school_emailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type school_numOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type school_infoOrderByRelevanceInput = {
    fields: school_infoOrderByRelevanceFieldEnum | school_infoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type school_infoCountOrderByAggregateInput = {
    school_reg?: SortOrder
    school_name?: SortOrder
    school_address?: SortOrder
    school_lat?: SortOrder
    school_long?: SortOrder
    school_princ?: SortOrder
  }

  export type school_infoAvgOrderByAggregateInput = {
    school_reg?: SortOrder
    school_lat?: SortOrder
    school_long?: SortOrder
  }

  export type school_infoMaxOrderByAggregateInput = {
    school_reg?: SortOrder
    school_name?: SortOrder
    school_address?: SortOrder
    school_lat?: SortOrder
    school_long?: SortOrder
    school_princ?: SortOrder
  }

  export type school_infoMinOrderByAggregateInput = {
    school_reg?: SortOrder
    school_name?: SortOrder
    school_address?: SortOrder
    school_lat?: SortOrder
    school_long?: SortOrder
    school_princ?: SortOrder
  }

  export type school_infoSumOrderByAggregateInput = {
    school_reg?: SortOrder
    school_lat?: SortOrder
    school_long?: SortOrder
  }

  export type school_numOrderByRelevanceInput = {
    fields: school_numOrderByRelevanceFieldEnum | school_numOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type school_numCountOrderByAggregateInput = {
    school_num_id?: SortOrder
    school_reg?: SortOrder
    school_phone?: SortOrder
    school_phone_label?: SortOrder
  }

  export type school_numAvgOrderByAggregateInput = {
    school_num_id?: SortOrder
    school_reg?: SortOrder
  }

  export type school_numMaxOrderByAggregateInput = {
    school_num_id?: SortOrder
    school_reg?: SortOrder
    school_phone?: SortOrder
    school_phone_label?: SortOrder
  }

  export type school_numMinOrderByAggregateInput = {
    school_num_id?: SortOrder
    school_reg?: SortOrder
    school_phone?: SortOrder
    school_phone_label?: SortOrder
  }

  export type school_numSumOrderByAggregateInput = {
    school_num_id?: SortOrder
    school_reg?: SortOrder
  }

  export type Final_gradeListRelationFilter = {
    every?: final_gradeWhereInput
    some?: final_gradeWhereInput
    none?: final_gradeWhereInput
  }

  export type Test_resultListRelationFilter = {
    every?: test_resultWhereInput
    some?: test_resultWhereInput
    none?: test_resultWhereInput
  }

  export type final_gradeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type test_resultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type studentOrderByRelevanceInput = {
    fields: studentOrderByRelevanceFieldEnum | studentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type studentCountOrderByAggregateInput = {
    student_id?: SortOrder
    mother_id?: SortOrder
    father_id?: SortOrder
    student_fname?: SortOrder
    student_lname?: SortOrder
    student_dob?: SortOrder
    student_account?: SortOrder
    student_pass?: SortOrder
    note?: SortOrder
  }

  export type studentAvgOrderByAggregateInput = {
    mother_id?: SortOrder
    father_id?: SortOrder
  }

  export type studentMaxOrderByAggregateInput = {
    student_id?: SortOrder
    mother_id?: SortOrder
    father_id?: SortOrder
    student_fname?: SortOrder
    student_lname?: SortOrder
    student_dob?: SortOrder
    student_account?: SortOrder
    student_pass?: SortOrder
    note?: SortOrder
  }

  export type studentMinOrderByAggregateInput = {
    student_id?: SortOrder
    mother_id?: SortOrder
    father_id?: SortOrder
    student_fname?: SortOrder
    student_lname?: SortOrder
    student_dob?: SortOrder
    student_account?: SortOrder
    student_pass?: SortOrder
    note?: SortOrder
  }

  export type studentSumOrderByAggregateInput = {
    mother_id?: SortOrder
    father_id?: SortOrder
  }

  export type AgendaListRelationFilter = {
    every?: agendaWhereInput
    some?: agendaWhereInput
    none?: agendaWhereInput
  }

  export type SubjectsScalarRelationFilter = {
    is?: subjectsWhereInput
    isNot?: subjectsWhereInput
  }

  export type TestListRelationFilter = {
    every?: testWhereInput
    some?: testWhereInput
    none?: testWhereInput
  }

  export type agendaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type testOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subject_classOrderByRelevanceInput = {
    fields: subject_classOrderByRelevanceFieldEnum | subject_classOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type subject_classCountOrderByAggregateInput = {
    subject_class_id?: SortOrder
    subject_code?: SortOrder
    instructor?: SortOrder
  }

  export type subject_classAvgOrderByAggregateInput = {
    subject_class_id?: SortOrder
    instructor?: SortOrder
  }

  export type subject_classMaxOrderByAggregateInput = {
    subject_class_id?: SortOrder
    subject_code?: SortOrder
    instructor?: SortOrder
  }

  export type subject_classMinOrderByAggregateInput = {
    subject_class_id?: SortOrder
    subject_code?: SortOrder
    instructor?: SortOrder
  }

  export type subject_classSumOrderByAggregateInput = {
    subject_class_id?: SortOrder
    instructor?: SortOrder
  }

  export type Enumsubjects_subject_catNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.subjects_subject_cat | Enumsubjects_subject_catFieldRefInput<$PrismaModel> | null
    in?: $Enums.subjects_subject_cat[] | null
    notIn?: $Enums.subjects_subject_cat[] | null
    not?: NestedEnumsubjects_subject_catNullableFilter<$PrismaModel> | $Enums.subjects_subject_cat | null
  }

  export type subjectsOrderByRelevanceInput = {
    fields: subjectsOrderByRelevanceFieldEnum | subjectsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type subjectsCountOrderByAggregateInput = {
    subject_code?: SortOrder
    subject_name?: SortOrder
    subject_cat?: SortOrder
  }

  export type subjectsMaxOrderByAggregateInput = {
    subject_code?: SortOrder
    subject_name?: SortOrder
    subject_cat?: SortOrder
  }

  export type subjectsMinOrderByAggregateInput = {
    subject_code?: SortOrder
    subject_name?: SortOrder
    subject_cat?: SortOrder
  }

  export type Enumsubjects_subject_catNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.subjects_subject_cat | Enumsubjects_subject_catFieldRefInput<$PrismaModel> | null
    in?: $Enums.subjects_subject_cat[] | null
    notIn?: $Enums.subjects_subject_cat[] | null
    not?: NestedEnumsubjects_subject_catNullableWithAggregatesFilter<$PrismaModel> | $Enums.subjects_subject_cat | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumsubjects_subject_catNullableFilter<$PrismaModel>
    _max?: NestedEnumsubjects_subject_catNullableFilter<$PrismaModel>
  }

  export type Enumtest_test_periodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.test_test_period | Enumtest_test_periodFieldRefInput<$PrismaModel> | null
    in?: $Enums.test_test_period[] | null
    notIn?: $Enums.test_test_period[] | null
    not?: NestedEnumtest_test_periodNullableFilter<$PrismaModel> | $Enums.test_test_period | null
  }

  export type testOrderByRelevanceInput = {
    fields: testOrderByRelevanceFieldEnum | testOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type testCountOrderByAggregateInput = {
    test_id?: SortOrder
    test_title?: SortOrder
    test_description?: SortOrder
    subject_class_id?: SortOrder
    test_total?: SortOrder
    test_visibility?: SortOrder
    test_annouced?: SortOrder
    test_due?: SortOrder
    test_period?: SortOrder
  }

  export type testAvgOrderByAggregateInput = {
    test_id?: SortOrder
    subject_class_id?: SortOrder
    test_total?: SortOrder
  }

  export type testMaxOrderByAggregateInput = {
    test_id?: SortOrder
    test_title?: SortOrder
    test_description?: SortOrder
    subject_class_id?: SortOrder
    test_total?: SortOrder
    test_visibility?: SortOrder
    test_annouced?: SortOrder
    test_due?: SortOrder
    test_period?: SortOrder
  }

  export type testMinOrderByAggregateInput = {
    test_id?: SortOrder
    test_title?: SortOrder
    test_description?: SortOrder
    subject_class_id?: SortOrder
    test_total?: SortOrder
    test_visibility?: SortOrder
    test_annouced?: SortOrder
    test_due?: SortOrder
    test_period?: SortOrder
  }

  export type testSumOrderByAggregateInput = {
    test_id?: SortOrder
    subject_class_id?: SortOrder
    test_total?: SortOrder
  }

  export type Enumtest_test_periodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_test_period | Enumtest_test_periodFieldRefInput<$PrismaModel> | null
    in?: $Enums.test_test_period[] | null
    notIn?: $Enums.test_test_period[] | null
    not?: NestedEnumtest_test_periodNullableWithAggregatesFilter<$PrismaModel> | $Enums.test_test_period | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumtest_test_periodNullableFilter<$PrismaModel>
    _max?: NestedEnumtest_test_periodNullableFilter<$PrismaModel>
  }

  export type TestScalarRelationFilter = {
    is?: testWhereInput
    isNot?: testWhereInput
  }

  export type test_resultOrderByRelevanceInput = {
    fields: test_resultOrderByRelevanceFieldEnum | test_resultOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type test_resultCountOrderByAggregateInput = {
    test_result_id?: SortOrder
    test_id?: SortOrder
    student_id?: SortOrder
    test_result?: SortOrder
    test_note?: SortOrder
  }

  export type test_resultAvgOrderByAggregateInput = {
    test_result_id?: SortOrder
    test_id?: SortOrder
    test_result?: SortOrder
  }

  export type test_resultMaxOrderByAggregateInput = {
    test_result_id?: SortOrder
    test_id?: SortOrder
    student_id?: SortOrder
    test_result?: SortOrder
    test_note?: SortOrder
  }

  export type test_resultMinOrderByAggregateInput = {
    test_result_id?: SortOrder
    test_id?: SortOrder
    student_id?: SortOrder
    test_result?: SortOrder
    test_note?: SortOrder
  }

  export type test_resultSumOrderByAggregateInput = {
    test_result_id?: SortOrder
    test_id?: SortOrder
    test_result?: SortOrder
  }

  export type classesOrderByRelevanceInput = {
    fields: classesOrderByRelevanceFieldEnum | classesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type classesCountOrderByAggregateInput = {
    class_code?: SortOrder
    class_name?: SortOrder
    class_base?: SortOrder
  }

  export type classesMaxOrderByAggregateInput = {
    class_code?: SortOrder
    class_name?: SortOrder
    class_base?: SortOrder
  }

  export type classesMinOrderByAggregateInput = {
    class_code?: SortOrder
    class_name?: SortOrder
    class_base?: SortOrder
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[]
    notIn?: Uint8Array[]
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type parent_formCountOrderByAggregateInput = {
    parent_form_id?: SortOrder
    parent_form_content?: SortOrder
    parent_form_created?: SortOrder
  }

  export type parent_formAvgOrderByAggregateInput = {
    parent_form_id?: SortOrder
  }

  export type parent_formMaxOrderByAggregateInput = {
    parent_form_id?: SortOrder
    parent_form_content?: SortOrder
    parent_form_created?: SortOrder
  }

  export type parent_formMinOrderByAggregateInput = {
    parent_form_id?: SortOrder
    parent_form_content?: SortOrder
    parent_form_created?: SortOrder
  }

  export type parent_formSumOrderByAggregateInput = {
    parent_form_id?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[]
    notIn?: Uint8Array[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type classesCreateNestedOneWithoutActive_classInput = {
    create?: XOR<classesCreateWithoutActive_classInput, classesUncheckedCreateWithoutActive_classInput>
    connectOrCreate?: classesCreateOrConnectWithoutActive_classInput
    connect?: classesWhereUniqueInput
  }

  export type periodCreateNestedOneWithoutActive_class_active_class_periodToperiodInput = {
    create?: XOR<periodCreateWithoutActive_class_active_class_periodToperiodInput, periodUncheckedCreateWithoutActive_class_active_class_periodToperiodInput>
    connectOrCreate?: periodCreateOrConnectWithoutActive_class_active_class_periodToperiodInput
    connect?: periodWhereUniqueInput
  }

  export type employeeCreateNestedOneWithoutActive_classInput = {
    create?: XOR<employeeCreateWithoutActive_classInput, employeeUncheckedCreateWithoutActive_classInput>
    connectOrCreate?: employeeCreateOrConnectWithoutActive_classInput
    connect?: employeeWhereUniqueInput
  }

  export type classesUpdateOneWithoutActive_classNestedInput = {
    create?: XOR<classesCreateWithoutActive_classInput, classesUncheckedCreateWithoutActive_classInput>
    connectOrCreate?: classesCreateOrConnectWithoutActive_classInput
    upsert?: classesUpsertWithoutActive_classInput
    disconnect?: classesWhereInput | boolean
    delete?: classesWhereInput | boolean
    connect?: classesWhereUniqueInput
    update?: XOR<XOR<classesUpdateToOneWithWhereWithoutActive_classInput, classesUpdateWithoutActive_classInput>, classesUncheckedUpdateWithoutActive_classInput>
  }

  export type periodUpdateOneWithoutActive_class_active_class_periodToperiodNestedInput = {
    create?: XOR<periodCreateWithoutActive_class_active_class_periodToperiodInput, periodUncheckedCreateWithoutActive_class_active_class_periodToperiodInput>
    connectOrCreate?: periodCreateOrConnectWithoutActive_class_active_class_periodToperiodInput
    upsert?: periodUpsertWithoutActive_class_active_class_periodToperiodInput
    disconnect?: periodWhereInput | boolean
    delete?: periodWhereInput | boolean
    connect?: periodWhereUniqueInput
    update?: XOR<XOR<periodUpdateToOneWithWhereWithoutActive_class_active_class_periodToperiodInput, periodUpdateWithoutActive_class_active_class_periodToperiodInput>, periodUncheckedUpdateWithoutActive_class_active_class_periodToperiodInput>
  }

  export type employeeUpdateOneWithoutActive_classNestedInput = {
    create?: XOR<employeeCreateWithoutActive_classInput, employeeUncheckedCreateWithoutActive_classInput>
    connectOrCreate?: employeeCreateOrConnectWithoutActive_classInput
    upsert?: employeeUpsertWithoutActive_classInput
    disconnect?: employeeWhereInput | boolean
    delete?: employeeWhereInput | boolean
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutActive_classInput, employeeUpdateWithoutActive_classInput>, employeeUncheckedUpdateWithoutActive_classInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type subject_classCreateNestedOneWithoutAgendaInput = {
    create?: XOR<subject_classCreateWithoutAgendaInput, subject_classUncheckedCreateWithoutAgendaInput>
    connectOrCreate?: subject_classCreateOrConnectWithoutAgendaInput
    connect?: subject_classWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type subject_classUpdateOneWithoutAgendaNestedInput = {
    create?: XOR<subject_classCreateWithoutAgendaInput, subject_classUncheckedCreateWithoutAgendaInput>
    connectOrCreate?: subject_classCreateOrConnectWithoutAgendaInput
    upsert?: subject_classUpsertWithoutAgendaInput
    disconnect?: subject_classWhereInput | boolean
    delete?: subject_classWhereInput | boolean
    connect?: subject_classWhereUniqueInput
    update?: XOR<XOR<subject_classUpdateToOneWithWhereWithoutAgendaInput, subject_classUpdateWithoutAgendaInput>, subject_classUncheckedUpdateWithoutAgendaInput>
  }

  export type active_classCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<active_classCreateWithoutEmployeeInput, active_classUncheckedCreateWithoutEmployeeInput> | active_classCreateWithoutEmployeeInput[] | active_classUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: active_classCreateOrConnectWithoutEmployeeInput | active_classCreateOrConnectWithoutEmployeeInput[]
    createMany?: active_classCreateManyEmployeeInputEnvelope
    connect?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
  }

  export type employee_roleCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<employee_roleCreateWithoutEmployeeInput, employee_roleUncheckedCreateWithoutEmployeeInput> | employee_roleCreateWithoutEmployeeInput[] | employee_roleUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: employee_roleCreateOrConnectWithoutEmployeeInput | employee_roleCreateOrConnectWithoutEmployeeInput[]
    createMany?: employee_roleCreateManyEmployeeInputEnvelope
    connect?: employee_roleWhereUniqueInput | employee_roleWhereUniqueInput[]
  }

  export type subject_classCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<subject_classCreateWithoutEmployeeInput, subject_classUncheckedCreateWithoutEmployeeInput> | subject_classCreateWithoutEmployeeInput[] | subject_classUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: subject_classCreateOrConnectWithoutEmployeeInput | subject_classCreateOrConnectWithoutEmployeeInput[]
    createMany?: subject_classCreateManyEmployeeInputEnvelope
    connect?: subject_classWhereUniqueInput | subject_classWhereUniqueInput[]
  }

  export type active_classUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<active_classCreateWithoutEmployeeInput, active_classUncheckedCreateWithoutEmployeeInput> | active_classCreateWithoutEmployeeInput[] | active_classUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: active_classCreateOrConnectWithoutEmployeeInput | active_classCreateOrConnectWithoutEmployeeInput[]
    createMany?: active_classCreateManyEmployeeInputEnvelope
    connect?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
  }

  export type employee_roleUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<employee_roleCreateWithoutEmployeeInput, employee_roleUncheckedCreateWithoutEmployeeInput> | employee_roleCreateWithoutEmployeeInput[] | employee_roleUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: employee_roleCreateOrConnectWithoutEmployeeInput | employee_roleCreateOrConnectWithoutEmployeeInput[]
    createMany?: employee_roleCreateManyEmployeeInputEnvelope
    connect?: employee_roleWhereUniqueInput | employee_roleWhereUniqueInput[]
  }

  export type subject_classUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<subject_classCreateWithoutEmployeeInput, subject_classUncheckedCreateWithoutEmployeeInput> | subject_classCreateWithoutEmployeeInput[] | subject_classUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: subject_classCreateOrConnectWithoutEmployeeInput | subject_classCreateOrConnectWithoutEmployeeInput[]
    createMany?: subject_classCreateManyEmployeeInputEnvelope
    connect?: subject_classWhereUniqueInput | subject_classWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type active_classUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<active_classCreateWithoutEmployeeInput, active_classUncheckedCreateWithoutEmployeeInput> | active_classCreateWithoutEmployeeInput[] | active_classUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: active_classCreateOrConnectWithoutEmployeeInput | active_classCreateOrConnectWithoutEmployeeInput[]
    upsert?: active_classUpsertWithWhereUniqueWithoutEmployeeInput | active_classUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: active_classCreateManyEmployeeInputEnvelope
    set?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    disconnect?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    delete?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    connect?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    update?: active_classUpdateWithWhereUniqueWithoutEmployeeInput | active_classUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: active_classUpdateManyWithWhereWithoutEmployeeInput | active_classUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: active_classScalarWhereInput | active_classScalarWhereInput[]
  }

  export type employee_roleUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<employee_roleCreateWithoutEmployeeInput, employee_roleUncheckedCreateWithoutEmployeeInput> | employee_roleCreateWithoutEmployeeInput[] | employee_roleUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: employee_roleCreateOrConnectWithoutEmployeeInput | employee_roleCreateOrConnectWithoutEmployeeInput[]
    upsert?: employee_roleUpsertWithWhereUniqueWithoutEmployeeInput | employee_roleUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: employee_roleCreateManyEmployeeInputEnvelope
    set?: employee_roleWhereUniqueInput | employee_roleWhereUniqueInput[]
    disconnect?: employee_roleWhereUniqueInput | employee_roleWhereUniqueInput[]
    delete?: employee_roleWhereUniqueInput | employee_roleWhereUniqueInput[]
    connect?: employee_roleWhereUniqueInput | employee_roleWhereUniqueInput[]
    update?: employee_roleUpdateWithWhereUniqueWithoutEmployeeInput | employee_roleUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: employee_roleUpdateManyWithWhereWithoutEmployeeInput | employee_roleUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: employee_roleScalarWhereInput | employee_roleScalarWhereInput[]
  }

  export type subject_classUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<subject_classCreateWithoutEmployeeInput, subject_classUncheckedCreateWithoutEmployeeInput> | subject_classCreateWithoutEmployeeInput[] | subject_classUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: subject_classCreateOrConnectWithoutEmployeeInput | subject_classCreateOrConnectWithoutEmployeeInput[]
    upsert?: subject_classUpsertWithWhereUniqueWithoutEmployeeInput | subject_classUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: subject_classCreateManyEmployeeInputEnvelope
    set?: subject_classWhereUniqueInput | subject_classWhereUniqueInput[]
    disconnect?: subject_classWhereUniqueInput | subject_classWhereUniqueInput[]
    delete?: subject_classWhereUniqueInput | subject_classWhereUniqueInput[]
    connect?: subject_classWhereUniqueInput | subject_classWhereUniqueInput[]
    update?: subject_classUpdateWithWhereUniqueWithoutEmployeeInput | subject_classUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: subject_classUpdateManyWithWhereWithoutEmployeeInput | subject_classUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: subject_classScalarWhereInput | subject_classScalarWhereInput[]
  }

  export type active_classUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<active_classCreateWithoutEmployeeInput, active_classUncheckedCreateWithoutEmployeeInput> | active_classCreateWithoutEmployeeInput[] | active_classUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: active_classCreateOrConnectWithoutEmployeeInput | active_classCreateOrConnectWithoutEmployeeInput[]
    upsert?: active_classUpsertWithWhereUniqueWithoutEmployeeInput | active_classUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: active_classCreateManyEmployeeInputEnvelope
    set?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    disconnect?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    delete?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    connect?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    update?: active_classUpdateWithWhereUniqueWithoutEmployeeInput | active_classUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: active_classUpdateManyWithWhereWithoutEmployeeInput | active_classUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: active_classScalarWhereInput | active_classScalarWhereInput[]
  }

  export type employee_roleUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<employee_roleCreateWithoutEmployeeInput, employee_roleUncheckedCreateWithoutEmployeeInput> | employee_roleCreateWithoutEmployeeInput[] | employee_roleUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: employee_roleCreateOrConnectWithoutEmployeeInput | employee_roleCreateOrConnectWithoutEmployeeInput[]
    upsert?: employee_roleUpsertWithWhereUniqueWithoutEmployeeInput | employee_roleUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: employee_roleCreateManyEmployeeInputEnvelope
    set?: employee_roleWhereUniqueInput | employee_roleWhereUniqueInput[]
    disconnect?: employee_roleWhereUniqueInput | employee_roleWhereUniqueInput[]
    delete?: employee_roleWhereUniqueInput | employee_roleWhereUniqueInput[]
    connect?: employee_roleWhereUniqueInput | employee_roleWhereUniqueInput[]
    update?: employee_roleUpdateWithWhereUniqueWithoutEmployeeInput | employee_roleUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: employee_roleUpdateManyWithWhereWithoutEmployeeInput | employee_roleUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: employee_roleScalarWhereInput | employee_roleScalarWhereInput[]
  }

  export type subject_classUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<subject_classCreateWithoutEmployeeInput, subject_classUncheckedCreateWithoutEmployeeInput> | subject_classCreateWithoutEmployeeInput[] | subject_classUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: subject_classCreateOrConnectWithoutEmployeeInput | subject_classCreateOrConnectWithoutEmployeeInput[]
    upsert?: subject_classUpsertWithWhereUniqueWithoutEmployeeInput | subject_classUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: subject_classCreateManyEmployeeInputEnvelope
    set?: subject_classWhereUniqueInput | subject_classWhereUniqueInput[]
    disconnect?: subject_classWhereUniqueInput | subject_classWhereUniqueInput[]
    delete?: subject_classWhereUniqueInput | subject_classWhereUniqueInput[]
    connect?: subject_classWhereUniqueInput | subject_classWhereUniqueInput[]
    update?: subject_classUpdateWithWhereUniqueWithoutEmployeeInput | subject_classUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: subject_classUpdateManyWithWhereWithoutEmployeeInput | subject_classUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: subject_classScalarWhereInput | subject_classScalarWhereInput[]
  }

  export type rolesCreateNestedOneWithoutEmployee_roleInput = {
    create?: XOR<rolesCreateWithoutEmployee_roleInput, rolesUncheckedCreateWithoutEmployee_roleInput>
    connectOrCreate?: rolesCreateOrConnectWithoutEmployee_roleInput
    connect?: rolesWhereUniqueInput
  }

  export type employeeCreateNestedOneWithoutEmployee_roleInput = {
    create?: XOR<employeeCreateWithoutEmployee_roleInput, employeeUncheckedCreateWithoutEmployee_roleInput>
    connectOrCreate?: employeeCreateOrConnectWithoutEmployee_roleInput
    connect?: employeeWhereUniqueInput
  }

  export type rolesUpdateOneRequiredWithoutEmployee_roleNestedInput = {
    create?: XOR<rolesCreateWithoutEmployee_roleInput, rolesUncheckedCreateWithoutEmployee_roleInput>
    connectOrCreate?: rolesCreateOrConnectWithoutEmployee_roleInput
    upsert?: rolesUpsertWithoutEmployee_roleInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutEmployee_roleInput, rolesUpdateWithoutEmployee_roleInput>, rolesUncheckedUpdateWithoutEmployee_roleInput>
  }

  export type employeeUpdateOneRequiredWithoutEmployee_roleNestedInput = {
    create?: XOR<employeeCreateWithoutEmployee_roleInput, employeeUncheckedCreateWithoutEmployee_roleInput>
    connectOrCreate?: employeeCreateOrConnectWithoutEmployee_roleInput
    upsert?: employeeUpsertWithoutEmployee_roleInput
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutEmployee_roleInput, employeeUpdateWithoutEmployee_roleInput>, employeeUncheckedUpdateWithoutEmployee_roleInput>
  }

  export type subjectsCreateNestedOneWithoutFinal_gradeInput = {
    create?: XOR<subjectsCreateWithoutFinal_gradeInput, subjectsUncheckedCreateWithoutFinal_gradeInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutFinal_gradeInput
    connect?: subjectsWhereUniqueInput
  }

  export type studentCreateNestedOneWithoutFinal_gradeInput = {
    create?: XOR<studentCreateWithoutFinal_gradeInput, studentUncheckedCreateWithoutFinal_gradeInput>
    connectOrCreate?: studentCreateOrConnectWithoutFinal_gradeInput
    connect?: studentWhereUniqueInput
  }

  export type NullableEnumfinal_grade_test_periodFieldUpdateOperationsInput = {
    set?: $Enums.final_grade_test_period | null
  }

  export type subjectsUpdateOneWithoutFinal_gradeNestedInput = {
    create?: XOR<subjectsCreateWithoutFinal_gradeInput, subjectsUncheckedCreateWithoutFinal_gradeInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutFinal_gradeInput
    upsert?: subjectsUpsertWithoutFinal_gradeInput
    disconnect?: subjectsWhereInput | boolean
    delete?: subjectsWhereInput | boolean
    connect?: subjectsWhereUniqueInput
    update?: XOR<XOR<subjectsUpdateToOneWithWhereWithoutFinal_gradeInput, subjectsUpdateWithoutFinal_gradeInput>, subjectsUncheckedUpdateWithoutFinal_gradeInput>
  }

  export type studentUpdateOneWithoutFinal_gradeNestedInput = {
    create?: XOR<studentCreateWithoutFinal_gradeInput, studentUncheckedCreateWithoutFinal_gradeInput>
    connectOrCreate?: studentCreateOrConnectWithoutFinal_gradeInput
    upsert?: studentUpsertWithoutFinal_gradeInput
    disconnect?: studentWhereInput | boolean
    delete?: studentWhereInput | boolean
    connect?: studentWhereUniqueInput
    update?: XOR<XOR<studentUpdateToOneWithWhereWithoutFinal_gradeInput, studentUpdateWithoutFinal_gradeInput>, studentUncheckedUpdateWithoutFinal_gradeInput>
  }

  export type parentCreateNestedOneWithoutJobInput = {
    create?: XOR<parentCreateWithoutJobInput, parentUncheckedCreateWithoutJobInput>
    connectOrCreate?: parentCreateOrConnectWithoutJobInput
    connect?: parentWhereUniqueInput
  }

  export type parentUpdateOneRequiredWithoutJobNestedInput = {
    create?: XOR<parentCreateWithoutJobInput, parentUncheckedCreateWithoutJobInput>
    connectOrCreate?: parentCreateOrConnectWithoutJobInput
    upsert?: parentUpsertWithoutJobInput
    connect?: parentWhereUniqueInput
    update?: XOR<XOR<parentUpdateToOneWithWhereWithoutJobInput, parentUpdateWithoutJobInput>, parentUncheckedUpdateWithoutJobInput>
  }

  export type jobCreateNestedManyWithoutParentInput = {
    create?: XOR<jobCreateWithoutParentInput, jobUncheckedCreateWithoutParentInput> | jobCreateWithoutParentInput[] | jobUncheckedCreateWithoutParentInput[]
    connectOrCreate?: jobCreateOrConnectWithoutParentInput | jobCreateOrConnectWithoutParentInput[]
    createMany?: jobCreateManyParentInputEnvelope
    connect?: jobWhereUniqueInput | jobWhereUniqueInput[]
  }

  export type studentCreateNestedManyWithoutParent_student_father_idToparentInput = {
    create?: XOR<studentCreateWithoutParent_student_father_idToparentInput, studentUncheckedCreateWithoutParent_student_father_idToparentInput> | studentCreateWithoutParent_student_father_idToparentInput[] | studentUncheckedCreateWithoutParent_student_father_idToparentInput[]
    connectOrCreate?: studentCreateOrConnectWithoutParent_student_father_idToparentInput | studentCreateOrConnectWithoutParent_student_father_idToparentInput[]
    createMany?: studentCreateManyParent_student_father_idToparentInputEnvelope
    connect?: studentWhereUniqueInput | studentWhereUniqueInput[]
  }

  export type studentCreateNestedManyWithoutParent_student_mother_idToparentInput = {
    create?: XOR<studentCreateWithoutParent_student_mother_idToparentInput, studentUncheckedCreateWithoutParent_student_mother_idToparentInput> | studentCreateWithoutParent_student_mother_idToparentInput[] | studentUncheckedCreateWithoutParent_student_mother_idToparentInput[]
    connectOrCreate?: studentCreateOrConnectWithoutParent_student_mother_idToparentInput | studentCreateOrConnectWithoutParent_student_mother_idToparentInput[]
    createMany?: studentCreateManyParent_student_mother_idToparentInputEnvelope
    connect?: studentWhereUniqueInput | studentWhereUniqueInput[]
  }

  export type jobUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<jobCreateWithoutParentInput, jobUncheckedCreateWithoutParentInput> | jobCreateWithoutParentInput[] | jobUncheckedCreateWithoutParentInput[]
    connectOrCreate?: jobCreateOrConnectWithoutParentInput | jobCreateOrConnectWithoutParentInput[]
    createMany?: jobCreateManyParentInputEnvelope
    connect?: jobWhereUniqueInput | jobWhereUniqueInput[]
  }

  export type studentUncheckedCreateNestedManyWithoutParent_student_father_idToparentInput = {
    create?: XOR<studentCreateWithoutParent_student_father_idToparentInput, studentUncheckedCreateWithoutParent_student_father_idToparentInput> | studentCreateWithoutParent_student_father_idToparentInput[] | studentUncheckedCreateWithoutParent_student_father_idToparentInput[]
    connectOrCreate?: studentCreateOrConnectWithoutParent_student_father_idToparentInput | studentCreateOrConnectWithoutParent_student_father_idToparentInput[]
    createMany?: studentCreateManyParent_student_father_idToparentInputEnvelope
    connect?: studentWhereUniqueInput | studentWhereUniqueInput[]
  }

  export type studentUncheckedCreateNestedManyWithoutParent_student_mother_idToparentInput = {
    create?: XOR<studentCreateWithoutParent_student_mother_idToparentInput, studentUncheckedCreateWithoutParent_student_mother_idToparentInput> | studentCreateWithoutParent_student_mother_idToparentInput[] | studentUncheckedCreateWithoutParent_student_mother_idToparentInput[]
    connectOrCreate?: studentCreateOrConnectWithoutParent_student_mother_idToparentInput | studentCreateOrConnectWithoutParent_student_mother_idToparentInput[]
    createMany?: studentCreateManyParent_student_mother_idToparentInputEnvelope
    connect?: studentWhereUniqueInput | studentWhereUniqueInput[]
  }

  export type jobUpdateManyWithoutParentNestedInput = {
    create?: XOR<jobCreateWithoutParentInput, jobUncheckedCreateWithoutParentInput> | jobCreateWithoutParentInput[] | jobUncheckedCreateWithoutParentInput[]
    connectOrCreate?: jobCreateOrConnectWithoutParentInput | jobCreateOrConnectWithoutParentInput[]
    upsert?: jobUpsertWithWhereUniqueWithoutParentInput | jobUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: jobCreateManyParentInputEnvelope
    set?: jobWhereUniqueInput | jobWhereUniqueInput[]
    disconnect?: jobWhereUniqueInput | jobWhereUniqueInput[]
    delete?: jobWhereUniqueInput | jobWhereUniqueInput[]
    connect?: jobWhereUniqueInput | jobWhereUniqueInput[]
    update?: jobUpdateWithWhereUniqueWithoutParentInput | jobUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: jobUpdateManyWithWhereWithoutParentInput | jobUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: jobScalarWhereInput | jobScalarWhereInput[]
  }

  export type studentUpdateManyWithoutParent_student_father_idToparentNestedInput = {
    create?: XOR<studentCreateWithoutParent_student_father_idToparentInput, studentUncheckedCreateWithoutParent_student_father_idToparentInput> | studentCreateWithoutParent_student_father_idToparentInput[] | studentUncheckedCreateWithoutParent_student_father_idToparentInput[]
    connectOrCreate?: studentCreateOrConnectWithoutParent_student_father_idToparentInput | studentCreateOrConnectWithoutParent_student_father_idToparentInput[]
    upsert?: studentUpsertWithWhereUniqueWithoutParent_student_father_idToparentInput | studentUpsertWithWhereUniqueWithoutParent_student_father_idToparentInput[]
    createMany?: studentCreateManyParent_student_father_idToparentInputEnvelope
    set?: studentWhereUniqueInput | studentWhereUniqueInput[]
    disconnect?: studentWhereUniqueInput | studentWhereUniqueInput[]
    delete?: studentWhereUniqueInput | studentWhereUniqueInput[]
    connect?: studentWhereUniqueInput | studentWhereUniqueInput[]
    update?: studentUpdateWithWhereUniqueWithoutParent_student_father_idToparentInput | studentUpdateWithWhereUniqueWithoutParent_student_father_idToparentInput[]
    updateMany?: studentUpdateManyWithWhereWithoutParent_student_father_idToparentInput | studentUpdateManyWithWhereWithoutParent_student_father_idToparentInput[]
    deleteMany?: studentScalarWhereInput | studentScalarWhereInput[]
  }

  export type studentUpdateManyWithoutParent_student_mother_idToparentNestedInput = {
    create?: XOR<studentCreateWithoutParent_student_mother_idToparentInput, studentUncheckedCreateWithoutParent_student_mother_idToparentInput> | studentCreateWithoutParent_student_mother_idToparentInput[] | studentUncheckedCreateWithoutParent_student_mother_idToparentInput[]
    connectOrCreate?: studentCreateOrConnectWithoutParent_student_mother_idToparentInput | studentCreateOrConnectWithoutParent_student_mother_idToparentInput[]
    upsert?: studentUpsertWithWhereUniqueWithoutParent_student_mother_idToparentInput | studentUpsertWithWhereUniqueWithoutParent_student_mother_idToparentInput[]
    createMany?: studentCreateManyParent_student_mother_idToparentInputEnvelope
    set?: studentWhereUniqueInput | studentWhereUniqueInput[]
    disconnect?: studentWhereUniqueInput | studentWhereUniqueInput[]
    delete?: studentWhereUniqueInput | studentWhereUniqueInput[]
    connect?: studentWhereUniqueInput | studentWhereUniqueInput[]
    update?: studentUpdateWithWhereUniqueWithoutParent_student_mother_idToparentInput | studentUpdateWithWhereUniqueWithoutParent_student_mother_idToparentInput[]
    updateMany?: studentUpdateManyWithWhereWithoutParent_student_mother_idToparentInput | studentUpdateManyWithWhereWithoutParent_student_mother_idToparentInput[]
    deleteMany?: studentScalarWhereInput | studentScalarWhereInput[]
  }

  export type jobUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<jobCreateWithoutParentInput, jobUncheckedCreateWithoutParentInput> | jobCreateWithoutParentInput[] | jobUncheckedCreateWithoutParentInput[]
    connectOrCreate?: jobCreateOrConnectWithoutParentInput | jobCreateOrConnectWithoutParentInput[]
    upsert?: jobUpsertWithWhereUniqueWithoutParentInput | jobUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: jobCreateManyParentInputEnvelope
    set?: jobWhereUniqueInput | jobWhereUniqueInput[]
    disconnect?: jobWhereUniqueInput | jobWhereUniqueInput[]
    delete?: jobWhereUniqueInput | jobWhereUniqueInput[]
    connect?: jobWhereUniqueInput | jobWhereUniqueInput[]
    update?: jobUpdateWithWhereUniqueWithoutParentInput | jobUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: jobUpdateManyWithWhereWithoutParentInput | jobUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: jobScalarWhereInput | jobScalarWhereInput[]
  }

  export type studentUncheckedUpdateManyWithoutParent_student_father_idToparentNestedInput = {
    create?: XOR<studentCreateWithoutParent_student_father_idToparentInput, studentUncheckedCreateWithoutParent_student_father_idToparentInput> | studentCreateWithoutParent_student_father_idToparentInput[] | studentUncheckedCreateWithoutParent_student_father_idToparentInput[]
    connectOrCreate?: studentCreateOrConnectWithoutParent_student_father_idToparentInput | studentCreateOrConnectWithoutParent_student_father_idToparentInput[]
    upsert?: studentUpsertWithWhereUniqueWithoutParent_student_father_idToparentInput | studentUpsertWithWhereUniqueWithoutParent_student_father_idToparentInput[]
    createMany?: studentCreateManyParent_student_father_idToparentInputEnvelope
    set?: studentWhereUniqueInput | studentWhereUniqueInput[]
    disconnect?: studentWhereUniqueInput | studentWhereUniqueInput[]
    delete?: studentWhereUniqueInput | studentWhereUniqueInput[]
    connect?: studentWhereUniqueInput | studentWhereUniqueInput[]
    update?: studentUpdateWithWhereUniqueWithoutParent_student_father_idToparentInput | studentUpdateWithWhereUniqueWithoutParent_student_father_idToparentInput[]
    updateMany?: studentUpdateManyWithWhereWithoutParent_student_father_idToparentInput | studentUpdateManyWithWhereWithoutParent_student_father_idToparentInput[]
    deleteMany?: studentScalarWhereInput | studentScalarWhereInput[]
  }

  export type studentUncheckedUpdateManyWithoutParent_student_mother_idToparentNestedInput = {
    create?: XOR<studentCreateWithoutParent_student_mother_idToparentInput, studentUncheckedCreateWithoutParent_student_mother_idToparentInput> | studentCreateWithoutParent_student_mother_idToparentInput[] | studentUncheckedCreateWithoutParent_student_mother_idToparentInput[]
    connectOrCreate?: studentCreateOrConnectWithoutParent_student_mother_idToparentInput | studentCreateOrConnectWithoutParent_student_mother_idToparentInput[]
    upsert?: studentUpsertWithWhereUniqueWithoutParent_student_mother_idToparentInput | studentUpsertWithWhereUniqueWithoutParent_student_mother_idToparentInput[]
    createMany?: studentCreateManyParent_student_mother_idToparentInputEnvelope
    set?: studentWhereUniqueInput | studentWhereUniqueInput[]
    disconnect?: studentWhereUniqueInput | studentWhereUniqueInput[]
    delete?: studentWhereUniqueInput | studentWhereUniqueInput[]
    connect?: studentWhereUniqueInput | studentWhereUniqueInput[]
    update?: studentUpdateWithWhereUniqueWithoutParent_student_mother_idToparentInput | studentUpdateWithWhereUniqueWithoutParent_student_mother_idToparentInput[]
    updateMany?: studentUpdateManyWithWhereWithoutParent_student_mother_idToparentInput | studentUpdateManyWithWhereWithoutParent_student_mother_idToparentInput[]
    deleteMany?: studentScalarWhereInput | studentScalarWhereInput[]
  }

  export type active_classCreateNestedManyWithoutPeriod_active_class_periodToperiodInput = {
    create?: XOR<active_classCreateWithoutPeriod_active_class_periodToperiodInput, active_classUncheckedCreateWithoutPeriod_active_class_periodToperiodInput> | active_classCreateWithoutPeriod_active_class_periodToperiodInput[] | active_classUncheckedCreateWithoutPeriod_active_class_periodToperiodInput[]
    connectOrCreate?: active_classCreateOrConnectWithoutPeriod_active_class_periodToperiodInput | active_classCreateOrConnectWithoutPeriod_active_class_periodToperiodInput[]
    createMany?: active_classCreateManyPeriod_active_class_periodToperiodInputEnvelope
    connect?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
  }

  export type active_classUncheckedCreateNestedManyWithoutPeriod_active_class_periodToperiodInput = {
    create?: XOR<active_classCreateWithoutPeriod_active_class_periodToperiodInput, active_classUncheckedCreateWithoutPeriod_active_class_periodToperiodInput> | active_classCreateWithoutPeriod_active_class_periodToperiodInput[] | active_classUncheckedCreateWithoutPeriod_active_class_periodToperiodInput[]
    connectOrCreate?: active_classCreateOrConnectWithoutPeriod_active_class_periodToperiodInput | active_classCreateOrConnectWithoutPeriod_active_class_periodToperiodInput[]
    createMany?: active_classCreateManyPeriod_active_class_periodToperiodInputEnvelope
    connect?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
  }

  export type active_classUpdateManyWithoutPeriod_active_class_periodToperiodNestedInput = {
    create?: XOR<active_classCreateWithoutPeriod_active_class_periodToperiodInput, active_classUncheckedCreateWithoutPeriod_active_class_periodToperiodInput> | active_classCreateWithoutPeriod_active_class_periodToperiodInput[] | active_classUncheckedCreateWithoutPeriod_active_class_periodToperiodInput[]
    connectOrCreate?: active_classCreateOrConnectWithoutPeriod_active_class_periodToperiodInput | active_classCreateOrConnectWithoutPeriod_active_class_periodToperiodInput[]
    upsert?: active_classUpsertWithWhereUniqueWithoutPeriod_active_class_periodToperiodInput | active_classUpsertWithWhereUniqueWithoutPeriod_active_class_periodToperiodInput[]
    createMany?: active_classCreateManyPeriod_active_class_periodToperiodInputEnvelope
    set?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    disconnect?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    delete?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    connect?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    update?: active_classUpdateWithWhereUniqueWithoutPeriod_active_class_periodToperiodInput | active_classUpdateWithWhereUniqueWithoutPeriod_active_class_periodToperiodInput[]
    updateMany?: active_classUpdateManyWithWhereWithoutPeriod_active_class_periodToperiodInput | active_classUpdateManyWithWhereWithoutPeriod_active_class_periodToperiodInput[]
    deleteMany?: active_classScalarWhereInput | active_classScalarWhereInput[]
  }

  export type active_classUncheckedUpdateManyWithoutPeriod_active_class_periodToperiodNestedInput = {
    create?: XOR<active_classCreateWithoutPeriod_active_class_periodToperiodInput, active_classUncheckedCreateWithoutPeriod_active_class_periodToperiodInput> | active_classCreateWithoutPeriod_active_class_periodToperiodInput[] | active_classUncheckedCreateWithoutPeriod_active_class_periodToperiodInput[]
    connectOrCreate?: active_classCreateOrConnectWithoutPeriod_active_class_periodToperiodInput | active_classCreateOrConnectWithoutPeriod_active_class_periodToperiodInput[]
    upsert?: active_classUpsertWithWhereUniqueWithoutPeriod_active_class_periodToperiodInput | active_classUpsertWithWhereUniqueWithoutPeriod_active_class_periodToperiodInput[]
    createMany?: active_classCreateManyPeriod_active_class_periodToperiodInputEnvelope
    set?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    disconnect?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    delete?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    connect?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    update?: active_classUpdateWithWhereUniqueWithoutPeriod_active_class_periodToperiodInput | active_classUpdateWithWhereUniqueWithoutPeriod_active_class_periodToperiodInput[]
    updateMany?: active_classUpdateManyWithWhereWithoutPeriod_active_class_periodToperiodInput | active_classUpdateManyWithWhereWithoutPeriod_active_class_periodToperiodInput[]
    deleteMany?: active_classScalarWhereInput | active_classScalarWhereInput[]
  }

  export type employee_roleCreateNestedManyWithoutRolesInput = {
    create?: XOR<employee_roleCreateWithoutRolesInput, employee_roleUncheckedCreateWithoutRolesInput> | employee_roleCreateWithoutRolesInput[] | employee_roleUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: employee_roleCreateOrConnectWithoutRolesInput | employee_roleCreateOrConnectWithoutRolesInput[]
    createMany?: employee_roleCreateManyRolesInputEnvelope
    connect?: employee_roleWhereUniqueInput | employee_roleWhereUniqueInput[]
  }

  export type employee_roleUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<employee_roleCreateWithoutRolesInput, employee_roleUncheckedCreateWithoutRolesInput> | employee_roleCreateWithoutRolesInput[] | employee_roleUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: employee_roleCreateOrConnectWithoutRolesInput | employee_roleCreateOrConnectWithoutRolesInput[]
    createMany?: employee_roleCreateManyRolesInputEnvelope
    connect?: employee_roleWhereUniqueInput | employee_roleWhereUniqueInput[]
  }

  export type employee_roleUpdateManyWithoutRolesNestedInput = {
    create?: XOR<employee_roleCreateWithoutRolesInput, employee_roleUncheckedCreateWithoutRolesInput> | employee_roleCreateWithoutRolesInput[] | employee_roleUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: employee_roleCreateOrConnectWithoutRolesInput | employee_roleCreateOrConnectWithoutRolesInput[]
    upsert?: employee_roleUpsertWithWhereUniqueWithoutRolesInput | employee_roleUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: employee_roleCreateManyRolesInputEnvelope
    set?: employee_roleWhereUniqueInput | employee_roleWhereUniqueInput[]
    disconnect?: employee_roleWhereUniqueInput | employee_roleWhereUniqueInput[]
    delete?: employee_roleWhereUniqueInput | employee_roleWhereUniqueInput[]
    connect?: employee_roleWhereUniqueInput | employee_roleWhereUniqueInput[]
    update?: employee_roleUpdateWithWhereUniqueWithoutRolesInput | employee_roleUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: employee_roleUpdateManyWithWhereWithoutRolesInput | employee_roleUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: employee_roleScalarWhereInput | employee_roleScalarWhereInput[]
  }

  export type employee_roleUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<employee_roleCreateWithoutRolesInput, employee_roleUncheckedCreateWithoutRolesInput> | employee_roleCreateWithoutRolesInput[] | employee_roleUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: employee_roleCreateOrConnectWithoutRolesInput | employee_roleCreateOrConnectWithoutRolesInput[]
    upsert?: employee_roleUpsertWithWhereUniqueWithoutRolesInput | employee_roleUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: employee_roleCreateManyRolesInputEnvelope
    set?: employee_roleWhereUniqueInput | employee_roleWhereUniqueInput[]
    disconnect?: employee_roleWhereUniqueInput | employee_roleWhereUniqueInput[]
    delete?: employee_roleWhereUniqueInput | employee_roleWhereUniqueInput[]
    connect?: employee_roleWhereUniqueInput | employee_roleWhereUniqueInput[]
    update?: employee_roleUpdateWithWhereUniqueWithoutRolesInput | employee_roleUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: employee_roleUpdateManyWithWhereWithoutRolesInput | employee_roleUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: employee_roleScalarWhereInput | employee_roleScalarWhereInput[]
  }

  export type school_infoCreateNestedOneWithoutSchool_emailInput = {
    create?: XOR<school_infoCreateWithoutSchool_emailInput, school_infoUncheckedCreateWithoutSchool_emailInput>
    connectOrCreate?: school_infoCreateOrConnectWithoutSchool_emailInput
    connect?: school_infoWhereUniqueInput
  }

  export type school_infoUpdateOneRequiredWithoutSchool_emailNestedInput = {
    create?: XOR<school_infoCreateWithoutSchool_emailInput, school_infoUncheckedCreateWithoutSchool_emailInput>
    connectOrCreate?: school_infoCreateOrConnectWithoutSchool_emailInput
    upsert?: school_infoUpsertWithoutSchool_emailInput
    connect?: school_infoWhereUniqueInput
    update?: XOR<XOR<school_infoUpdateToOneWithWhereWithoutSchool_emailInput, school_infoUpdateWithoutSchool_emailInput>, school_infoUncheckedUpdateWithoutSchool_emailInput>
  }

  export type school_emailCreateNestedManyWithoutSchool_infoInput = {
    create?: XOR<school_emailCreateWithoutSchool_infoInput, school_emailUncheckedCreateWithoutSchool_infoInput> | school_emailCreateWithoutSchool_infoInput[] | school_emailUncheckedCreateWithoutSchool_infoInput[]
    connectOrCreate?: school_emailCreateOrConnectWithoutSchool_infoInput | school_emailCreateOrConnectWithoutSchool_infoInput[]
    createMany?: school_emailCreateManySchool_infoInputEnvelope
    connect?: school_emailWhereUniqueInput | school_emailWhereUniqueInput[]
  }

  export type school_numCreateNestedManyWithoutSchool_infoInput = {
    create?: XOR<school_numCreateWithoutSchool_infoInput, school_numUncheckedCreateWithoutSchool_infoInput> | school_numCreateWithoutSchool_infoInput[] | school_numUncheckedCreateWithoutSchool_infoInput[]
    connectOrCreate?: school_numCreateOrConnectWithoutSchool_infoInput | school_numCreateOrConnectWithoutSchool_infoInput[]
    createMany?: school_numCreateManySchool_infoInputEnvelope
    connect?: school_numWhereUniqueInput | school_numWhereUniqueInput[]
  }

  export type school_emailUncheckedCreateNestedManyWithoutSchool_infoInput = {
    create?: XOR<school_emailCreateWithoutSchool_infoInput, school_emailUncheckedCreateWithoutSchool_infoInput> | school_emailCreateWithoutSchool_infoInput[] | school_emailUncheckedCreateWithoutSchool_infoInput[]
    connectOrCreate?: school_emailCreateOrConnectWithoutSchool_infoInput | school_emailCreateOrConnectWithoutSchool_infoInput[]
    createMany?: school_emailCreateManySchool_infoInputEnvelope
    connect?: school_emailWhereUniqueInput | school_emailWhereUniqueInput[]
  }

  export type school_numUncheckedCreateNestedManyWithoutSchool_infoInput = {
    create?: XOR<school_numCreateWithoutSchool_infoInput, school_numUncheckedCreateWithoutSchool_infoInput> | school_numCreateWithoutSchool_infoInput[] | school_numUncheckedCreateWithoutSchool_infoInput[]
    connectOrCreate?: school_numCreateOrConnectWithoutSchool_infoInput | school_numCreateOrConnectWithoutSchool_infoInput[]
    createMany?: school_numCreateManySchool_infoInputEnvelope
    connect?: school_numWhereUniqueInput | school_numWhereUniqueInput[]
  }

  export type school_emailUpdateManyWithoutSchool_infoNestedInput = {
    create?: XOR<school_emailCreateWithoutSchool_infoInput, school_emailUncheckedCreateWithoutSchool_infoInput> | school_emailCreateWithoutSchool_infoInput[] | school_emailUncheckedCreateWithoutSchool_infoInput[]
    connectOrCreate?: school_emailCreateOrConnectWithoutSchool_infoInput | school_emailCreateOrConnectWithoutSchool_infoInput[]
    upsert?: school_emailUpsertWithWhereUniqueWithoutSchool_infoInput | school_emailUpsertWithWhereUniqueWithoutSchool_infoInput[]
    createMany?: school_emailCreateManySchool_infoInputEnvelope
    set?: school_emailWhereUniqueInput | school_emailWhereUniqueInput[]
    disconnect?: school_emailWhereUniqueInput | school_emailWhereUniqueInput[]
    delete?: school_emailWhereUniqueInput | school_emailWhereUniqueInput[]
    connect?: school_emailWhereUniqueInput | school_emailWhereUniqueInput[]
    update?: school_emailUpdateWithWhereUniqueWithoutSchool_infoInput | school_emailUpdateWithWhereUniqueWithoutSchool_infoInput[]
    updateMany?: school_emailUpdateManyWithWhereWithoutSchool_infoInput | school_emailUpdateManyWithWhereWithoutSchool_infoInput[]
    deleteMany?: school_emailScalarWhereInput | school_emailScalarWhereInput[]
  }

  export type school_numUpdateManyWithoutSchool_infoNestedInput = {
    create?: XOR<school_numCreateWithoutSchool_infoInput, school_numUncheckedCreateWithoutSchool_infoInput> | school_numCreateWithoutSchool_infoInput[] | school_numUncheckedCreateWithoutSchool_infoInput[]
    connectOrCreate?: school_numCreateOrConnectWithoutSchool_infoInput | school_numCreateOrConnectWithoutSchool_infoInput[]
    upsert?: school_numUpsertWithWhereUniqueWithoutSchool_infoInput | school_numUpsertWithWhereUniqueWithoutSchool_infoInput[]
    createMany?: school_numCreateManySchool_infoInputEnvelope
    set?: school_numWhereUniqueInput | school_numWhereUniqueInput[]
    disconnect?: school_numWhereUniqueInput | school_numWhereUniqueInput[]
    delete?: school_numWhereUniqueInput | school_numWhereUniqueInput[]
    connect?: school_numWhereUniqueInput | school_numWhereUniqueInput[]
    update?: school_numUpdateWithWhereUniqueWithoutSchool_infoInput | school_numUpdateWithWhereUniqueWithoutSchool_infoInput[]
    updateMany?: school_numUpdateManyWithWhereWithoutSchool_infoInput | school_numUpdateManyWithWhereWithoutSchool_infoInput[]
    deleteMany?: school_numScalarWhereInput | school_numScalarWhereInput[]
  }

  export type school_emailUncheckedUpdateManyWithoutSchool_infoNestedInput = {
    create?: XOR<school_emailCreateWithoutSchool_infoInput, school_emailUncheckedCreateWithoutSchool_infoInput> | school_emailCreateWithoutSchool_infoInput[] | school_emailUncheckedCreateWithoutSchool_infoInput[]
    connectOrCreate?: school_emailCreateOrConnectWithoutSchool_infoInput | school_emailCreateOrConnectWithoutSchool_infoInput[]
    upsert?: school_emailUpsertWithWhereUniqueWithoutSchool_infoInput | school_emailUpsertWithWhereUniqueWithoutSchool_infoInput[]
    createMany?: school_emailCreateManySchool_infoInputEnvelope
    set?: school_emailWhereUniqueInput | school_emailWhereUniqueInput[]
    disconnect?: school_emailWhereUniqueInput | school_emailWhereUniqueInput[]
    delete?: school_emailWhereUniqueInput | school_emailWhereUniqueInput[]
    connect?: school_emailWhereUniqueInput | school_emailWhereUniqueInput[]
    update?: school_emailUpdateWithWhereUniqueWithoutSchool_infoInput | school_emailUpdateWithWhereUniqueWithoutSchool_infoInput[]
    updateMany?: school_emailUpdateManyWithWhereWithoutSchool_infoInput | school_emailUpdateManyWithWhereWithoutSchool_infoInput[]
    deleteMany?: school_emailScalarWhereInput | school_emailScalarWhereInput[]
  }

  export type school_numUncheckedUpdateManyWithoutSchool_infoNestedInput = {
    create?: XOR<school_numCreateWithoutSchool_infoInput, school_numUncheckedCreateWithoutSchool_infoInput> | school_numCreateWithoutSchool_infoInput[] | school_numUncheckedCreateWithoutSchool_infoInput[]
    connectOrCreate?: school_numCreateOrConnectWithoutSchool_infoInput | school_numCreateOrConnectWithoutSchool_infoInput[]
    upsert?: school_numUpsertWithWhereUniqueWithoutSchool_infoInput | school_numUpsertWithWhereUniqueWithoutSchool_infoInput[]
    createMany?: school_numCreateManySchool_infoInputEnvelope
    set?: school_numWhereUniqueInput | school_numWhereUniqueInput[]
    disconnect?: school_numWhereUniqueInput | school_numWhereUniqueInput[]
    delete?: school_numWhereUniqueInput | school_numWhereUniqueInput[]
    connect?: school_numWhereUniqueInput | school_numWhereUniqueInput[]
    update?: school_numUpdateWithWhereUniqueWithoutSchool_infoInput | school_numUpdateWithWhereUniqueWithoutSchool_infoInput[]
    updateMany?: school_numUpdateManyWithWhereWithoutSchool_infoInput | school_numUpdateManyWithWhereWithoutSchool_infoInput[]
    deleteMany?: school_numScalarWhereInput | school_numScalarWhereInput[]
  }

  export type school_infoCreateNestedOneWithoutSchool_numInput = {
    create?: XOR<school_infoCreateWithoutSchool_numInput, school_infoUncheckedCreateWithoutSchool_numInput>
    connectOrCreate?: school_infoCreateOrConnectWithoutSchool_numInput
    connect?: school_infoWhereUniqueInput
  }

  export type school_infoUpdateOneRequiredWithoutSchool_numNestedInput = {
    create?: XOR<school_infoCreateWithoutSchool_numInput, school_infoUncheckedCreateWithoutSchool_numInput>
    connectOrCreate?: school_infoCreateOrConnectWithoutSchool_numInput
    upsert?: school_infoUpsertWithoutSchool_numInput
    connect?: school_infoWhereUniqueInput
    update?: XOR<XOR<school_infoUpdateToOneWithWhereWithoutSchool_numInput, school_infoUpdateWithoutSchool_numInput>, school_infoUncheckedUpdateWithoutSchool_numInput>
  }

  export type final_gradeCreateNestedManyWithoutStudentInput = {
    create?: XOR<final_gradeCreateWithoutStudentInput, final_gradeUncheckedCreateWithoutStudentInput> | final_gradeCreateWithoutStudentInput[] | final_gradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: final_gradeCreateOrConnectWithoutStudentInput | final_gradeCreateOrConnectWithoutStudentInput[]
    createMany?: final_gradeCreateManyStudentInputEnvelope
    connect?: final_gradeWhereUniqueInput | final_gradeWhereUniqueInput[]
  }

  export type parentCreateNestedOneWithoutStudent_student_father_idToparentInput = {
    create?: XOR<parentCreateWithoutStudent_student_father_idToparentInput, parentUncheckedCreateWithoutStudent_student_father_idToparentInput>
    connectOrCreate?: parentCreateOrConnectWithoutStudent_student_father_idToparentInput
    connect?: parentWhereUniqueInput
  }

  export type parentCreateNestedOneWithoutStudent_student_mother_idToparentInput = {
    create?: XOR<parentCreateWithoutStudent_student_mother_idToparentInput, parentUncheckedCreateWithoutStudent_student_mother_idToparentInput>
    connectOrCreate?: parentCreateOrConnectWithoutStudent_student_mother_idToparentInput
    connect?: parentWhereUniqueInput
  }

  export type test_resultCreateNestedManyWithoutStudentInput = {
    create?: XOR<test_resultCreateWithoutStudentInput, test_resultUncheckedCreateWithoutStudentInput> | test_resultCreateWithoutStudentInput[] | test_resultUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: test_resultCreateOrConnectWithoutStudentInput | test_resultCreateOrConnectWithoutStudentInput[]
    createMany?: test_resultCreateManyStudentInputEnvelope
    connect?: test_resultWhereUniqueInput | test_resultWhereUniqueInput[]
  }

  export type final_gradeUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<final_gradeCreateWithoutStudentInput, final_gradeUncheckedCreateWithoutStudentInput> | final_gradeCreateWithoutStudentInput[] | final_gradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: final_gradeCreateOrConnectWithoutStudentInput | final_gradeCreateOrConnectWithoutStudentInput[]
    createMany?: final_gradeCreateManyStudentInputEnvelope
    connect?: final_gradeWhereUniqueInput | final_gradeWhereUniqueInput[]
  }

  export type test_resultUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<test_resultCreateWithoutStudentInput, test_resultUncheckedCreateWithoutStudentInput> | test_resultCreateWithoutStudentInput[] | test_resultUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: test_resultCreateOrConnectWithoutStudentInput | test_resultCreateOrConnectWithoutStudentInput[]
    createMany?: test_resultCreateManyStudentInputEnvelope
    connect?: test_resultWhereUniqueInput | test_resultWhereUniqueInput[]
  }

  export type final_gradeUpdateManyWithoutStudentNestedInput = {
    create?: XOR<final_gradeCreateWithoutStudentInput, final_gradeUncheckedCreateWithoutStudentInput> | final_gradeCreateWithoutStudentInput[] | final_gradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: final_gradeCreateOrConnectWithoutStudentInput | final_gradeCreateOrConnectWithoutStudentInput[]
    upsert?: final_gradeUpsertWithWhereUniqueWithoutStudentInput | final_gradeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: final_gradeCreateManyStudentInputEnvelope
    set?: final_gradeWhereUniqueInput | final_gradeWhereUniqueInput[]
    disconnect?: final_gradeWhereUniqueInput | final_gradeWhereUniqueInput[]
    delete?: final_gradeWhereUniqueInput | final_gradeWhereUniqueInput[]
    connect?: final_gradeWhereUniqueInput | final_gradeWhereUniqueInput[]
    update?: final_gradeUpdateWithWhereUniqueWithoutStudentInput | final_gradeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: final_gradeUpdateManyWithWhereWithoutStudentInput | final_gradeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: final_gradeScalarWhereInput | final_gradeScalarWhereInput[]
  }

  export type parentUpdateOneRequiredWithoutStudent_student_father_idToparentNestedInput = {
    create?: XOR<parentCreateWithoutStudent_student_father_idToparentInput, parentUncheckedCreateWithoutStudent_student_father_idToparentInput>
    connectOrCreate?: parentCreateOrConnectWithoutStudent_student_father_idToparentInput
    upsert?: parentUpsertWithoutStudent_student_father_idToparentInput
    connect?: parentWhereUniqueInput
    update?: XOR<XOR<parentUpdateToOneWithWhereWithoutStudent_student_father_idToparentInput, parentUpdateWithoutStudent_student_father_idToparentInput>, parentUncheckedUpdateWithoutStudent_student_father_idToparentInput>
  }

  export type parentUpdateOneRequiredWithoutStudent_student_mother_idToparentNestedInput = {
    create?: XOR<parentCreateWithoutStudent_student_mother_idToparentInput, parentUncheckedCreateWithoutStudent_student_mother_idToparentInput>
    connectOrCreate?: parentCreateOrConnectWithoutStudent_student_mother_idToparentInput
    upsert?: parentUpsertWithoutStudent_student_mother_idToparentInput
    connect?: parentWhereUniqueInput
    update?: XOR<XOR<parentUpdateToOneWithWhereWithoutStudent_student_mother_idToparentInput, parentUpdateWithoutStudent_student_mother_idToparentInput>, parentUncheckedUpdateWithoutStudent_student_mother_idToparentInput>
  }

  export type test_resultUpdateManyWithoutStudentNestedInput = {
    create?: XOR<test_resultCreateWithoutStudentInput, test_resultUncheckedCreateWithoutStudentInput> | test_resultCreateWithoutStudentInput[] | test_resultUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: test_resultCreateOrConnectWithoutStudentInput | test_resultCreateOrConnectWithoutStudentInput[]
    upsert?: test_resultUpsertWithWhereUniqueWithoutStudentInput | test_resultUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: test_resultCreateManyStudentInputEnvelope
    set?: test_resultWhereUniqueInput | test_resultWhereUniqueInput[]
    disconnect?: test_resultWhereUniqueInput | test_resultWhereUniqueInput[]
    delete?: test_resultWhereUniqueInput | test_resultWhereUniqueInput[]
    connect?: test_resultWhereUniqueInput | test_resultWhereUniqueInput[]
    update?: test_resultUpdateWithWhereUniqueWithoutStudentInput | test_resultUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: test_resultUpdateManyWithWhereWithoutStudentInput | test_resultUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: test_resultScalarWhereInput | test_resultScalarWhereInput[]
  }

  export type final_gradeUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<final_gradeCreateWithoutStudentInput, final_gradeUncheckedCreateWithoutStudentInput> | final_gradeCreateWithoutStudentInput[] | final_gradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: final_gradeCreateOrConnectWithoutStudentInput | final_gradeCreateOrConnectWithoutStudentInput[]
    upsert?: final_gradeUpsertWithWhereUniqueWithoutStudentInput | final_gradeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: final_gradeCreateManyStudentInputEnvelope
    set?: final_gradeWhereUniqueInput | final_gradeWhereUniqueInput[]
    disconnect?: final_gradeWhereUniqueInput | final_gradeWhereUniqueInput[]
    delete?: final_gradeWhereUniqueInput | final_gradeWhereUniqueInput[]
    connect?: final_gradeWhereUniqueInput | final_gradeWhereUniqueInput[]
    update?: final_gradeUpdateWithWhereUniqueWithoutStudentInput | final_gradeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: final_gradeUpdateManyWithWhereWithoutStudentInput | final_gradeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: final_gradeScalarWhereInput | final_gradeScalarWhereInput[]
  }

  export type test_resultUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<test_resultCreateWithoutStudentInput, test_resultUncheckedCreateWithoutStudentInput> | test_resultCreateWithoutStudentInput[] | test_resultUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: test_resultCreateOrConnectWithoutStudentInput | test_resultCreateOrConnectWithoutStudentInput[]
    upsert?: test_resultUpsertWithWhereUniqueWithoutStudentInput | test_resultUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: test_resultCreateManyStudentInputEnvelope
    set?: test_resultWhereUniqueInput | test_resultWhereUniqueInput[]
    disconnect?: test_resultWhereUniqueInput | test_resultWhereUniqueInput[]
    delete?: test_resultWhereUniqueInput | test_resultWhereUniqueInput[]
    connect?: test_resultWhereUniqueInput | test_resultWhereUniqueInput[]
    update?: test_resultUpdateWithWhereUniqueWithoutStudentInput | test_resultUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: test_resultUpdateManyWithWhereWithoutStudentInput | test_resultUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: test_resultScalarWhereInput | test_resultScalarWhereInput[]
  }

  export type agendaCreateNestedManyWithoutSubject_classInput = {
    create?: XOR<agendaCreateWithoutSubject_classInput, agendaUncheckedCreateWithoutSubject_classInput> | agendaCreateWithoutSubject_classInput[] | agendaUncheckedCreateWithoutSubject_classInput[]
    connectOrCreate?: agendaCreateOrConnectWithoutSubject_classInput | agendaCreateOrConnectWithoutSubject_classInput[]
    createMany?: agendaCreateManySubject_classInputEnvelope
    connect?: agendaWhereUniqueInput | agendaWhereUniqueInput[]
  }

  export type employeeCreateNestedOneWithoutSubject_classInput = {
    create?: XOR<employeeCreateWithoutSubject_classInput, employeeUncheckedCreateWithoutSubject_classInput>
    connectOrCreate?: employeeCreateOrConnectWithoutSubject_classInput
    connect?: employeeWhereUniqueInput
  }

  export type subjectsCreateNestedOneWithoutSubject_classInput = {
    create?: XOR<subjectsCreateWithoutSubject_classInput, subjectsUncheckedCreateWithoutSubject_classInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutSubject_classInput
    connect?: subjectsWhereUniqueInput
  }

  export type testCreateNestedManyWithoutSubject_classInput = {
    create?: XOR<testCreateWithoutSubject_classInput, testUncheckedCreateWithoutSubject_classInput> | testCreateWithoutSubject_classInput[] | testUncheckedCreateWithoutSubject_classInput[]
    connectOrCreate?: testCreateOrConnectWithoutSubject_classInput | testCreateOrConnectWithoutSubject_classInput[]
    createMany?: testCreateManySubject_classInputEnvelope
    connect?: testWhereUniqueInput | testWhereUniqueInput[]
  }

  export type agendaUncheckedCreateNestedManyWithoutSubject_classInput = {
    create?: XOR<agendaCreateWithoutSubject_classInput, agendaUncheckedCreateWithoutSubject_classInput> | agendaCreateWithoutSubject_classInput[] | agendaUncheckedCreateWithoutSubject_classInput[]
    connectOrCreate?: agendaCreateOrConnectWithoutSubject_classInput | agendaCreateOrConnectWithoutSubject_classInput[]
    createMany?: agendaCreateManySubject_classInputEnvelope
    connect?: agendaWhereUniqueInput | agendaWhereUniqueInput[]
  }

  export type testUncheckedCreateNestedManyWithoutSubject_classInput = {
    create?: XOR<testCreateWithoutSubject_classInput, testUncheckedCreateWithoutSubject_classInput> | testCreateWithoutSubject_classInput[] | testUncheckedCreateWithoutSubject_classInput[]
    connectOrCreate?: testCreateOrConnectWithoutSubject_classInput | testCreateOrConnectWithoutSubject_classInput[]
    createMany?: testCreateManySubject_classInputEnvelope
    connect?: testWhereUniqueInput | testWhereUniqueInput[]
  }

  export type agendaUpdateManyWithoutSubject_classNestedInput = {
    create?: XOR<agendaCreateWithoutSubject_classInput, agendaUncheckedCreateWithoutSubject_classInput> | agendaCreateWithoutSubject_classInput[] | agendaUncheckedCreateWithoutSubject_classInput[]
    connectOrCreate?: agendaCreateOrConnectWithoutSubject_classInput | agendaCreateOrConnectWithoutSubject_classInput[]
    upsert?: agendaUpsertWithWhereUniqueWithoutSubject_classInput | agendaUpsertWithWhereUniqueWithoutSubject_classInput[]
    createMany?: agendaCreateManySubject_classInputEnvelope
    set?: agendaWhereUniqueInput | agendaWhereUniqueInput[]
    disconnect?: agendaWhereUniqueInput | agendaWhereUniqueInput[]
    delete?: agendaWhereUniqueInput | agendaWhereUniqueInput[]
    connect?: agendaWhereUniqueInput | agendaWhereUniqueInput[]
    update?: agendaUpdateWithWhereUniqueWithoutSubject_classInput | agendaUpdateWithWhereUniqueWithoutSubject_classInput[]
    updateMany?: agendaUpdateManyWithWhereWithoutSubject_classInput | agendaUpdateManyWithWhereWithoutSubject_classInput[]
    deleteMany?: agendaScalarWhereInput | agendaScalarWhereInput[]
  }

  export type employeeUpdateOneWithoutSubject_classNestedInput = {
    create?: XOR<employeeCreateWithoutSubject_classInput, employeeUncheckedCreateWithoutSubject_classInput>
    connectOrCreate?: employeeCreateOrConnectWithoutSubject_classInput
    upsert?: employeeUpsertWithoutSubject_classInput
    disconnect?: employeeWhereInput | boolean
    delete?: employeeWhereInput | boolean
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutSubject_classInput, employeeUpdateWithoutSubject_classInput>, employeeUncheckedUpdateWithoutSubject_classInput>
  }

  export type subjectsUpdateOneRequiredWithoutSubject_classNestedInput = {
    create?: XOR<subjectsCreateWithoutSubject_classInput, subjectsUncheckedCreateWithoutSubject_classInput>
    connectOrCreate?: subjectsCreateOrConnectWithoutSubject_classInput
    upsert?: subjectsUpsertWithoutSubject_classInput
    connect?: subjectsWhereUniqueInput
    update?: XOR<XOR<subjectsUpdateToOneWithWhereWithoutSubject_classInput, subjectsUpdateWithoutSubject_classInput>, subjectsUncheckedUpdateWithoutSubject_classInput>
  }

  export type testUpdateManyWithoutSubject_classNestedInput = {
    create?: XOR<testCreateWithoutSubject_classInput, testUncheckedCreateWithoutSubject_classInput> | testCreateWithoutSubject_classInput[] | testUncheckedCreateWithoutSubject_classInput[]
    connectOrCreate?: testCreateOrConnectWithoutSubject_classInput | testCreateOrConnectWithoutSubject_classInput[]
    upsert?: testUpsertWithWhereUniqueWithoutSubject_classInput | testUpsertWithWhereUniqueWithoutSubject_classInput[]
    createMany?: testCreateManySubject_classInputEnvelope
    set?: testWhereUniqueInput | testWhereUniqueInput[]
    disconnect?: testWhereUniqueInput | testWhereUniqueInput[]
    delete?: testWhereUniqueInput | testWhereUniqueInput[]
    connect?: testWhereUniqueInput | testWhereUniqueInput[]
    update?: testUpdateWithWhereUniqueWithoutSubject_classInput | testUpdateWithWhereUniqueWithoutSubject_classInput[]
    updateMany?: testUpdateManyWithWhereWithoutSubject_classInput | testUpdateManyWithWhereWithoutSubject_classInput[]
    deleteMany?: testScalarWhereInput | testScalarWhereInput[]
  }

  export type agendaUncheckedUpdateManyWithoutSubject_classNestedInput = {
    create?: XOR<agendaCreateWithoutSubject_classInput, agendaUncheckedCreateWithoutSubject_classInput> | agendaCreateWithoutSubject_classInput[] | agendaUncheckedCreateWithoutSubject_classInput[]
    connectOrCreate?: agendaCreateOrConnectWithoutSubject_classInput | agendaCreateOrConnectWithoutSubject_classInput[]
    upsert?: agendaUpsertWithWhereUniqueWithoutSubject_classInput | agendaUpsertWithWhereUniqueWithoutSubject_classInput[]
    createMany?: agendaCreateManySubject_classInputEnvelope
    set?: agendaWhereUniqueInput | agendaWhereUniqueInput[]
    disconnect?: agendaWhereUniqueInput | agendaWhereUniqueInput[]
    delete?: agendaWhereUniqueInput | agendaWhereUniqueInput[]
    connect?: agendaWhereUniqueInput | agendaWhereUniqueInput[]
    update?: agendaUpdateWithWhereUniqueWithoutSubject_classInput | agendaUpdateWithWhereUniqueWithoutSubject_classInput[]
    updateMany?: agendaUpdateManyWithWhereWithoutSubject_classInput | agendaUpdateManyWithWhereWithoutSubject_classInput[]
    deleteMany?: agendaScalarWhereInput | agendaScalarWhereInput[]
  }

  export type testUncheckedUpdateManyWithoutSubject_classNestedInput = {
    create?: XOR<testCreateWithoutSubject_classInput, testUncheckedCreateWithoutSubject_classInput> | testCreateWithoutSubject_classInput[] | testUncheckedCreateWithoutSubject_classInput[]
    connectOrCreate?: testCreateOrConnectWithoutSubject_classInput | testCreateOrConnectWithoutSubject_classInput[]
    upsert?: testUpsertWithWhereUniqueWithoutSubject_classInput | testUpsertWithWhereUniqueWithoutSubject_classInput[]
    createMany?: testCreateManySubject_classInputEnvelope
    set?: testWhereUniqueInput | testWhereUniqueInput[]
    disconnect?: testWhereUniqueInput | testWhereUniqueInput[]
    delete?: testWhereUniqueInput | testWhereUniqueInput[]
    connect?: testWhereUniqueInput | testWhereUniqueInput[]
    update?: testUpdateWithWhereUniqueWithoutSubject_classInput | testUpdateWithWhereUniqueWithoutSubject_classInput[]
    updateMany?: testUpdateManyWithWhereWithoutSubject_classInput | testUpdateManyWithWhereWithoutSubject_classInput[]
    deleteMany?: testScalarWhereInput | testScalarWhereInput[]
  }

  export type final_gradeCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<final_gradeCreateWithoutSubjectsInput, final_gradeUncheckedCreateWithoutSubjectsInput> | final_gradeCreateWithoutSubjectsInput[] | final_gradeUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: final_gradeCreateOrConnectWithoutSubjectsInput | final_gradeCreateOrConnectWithoutSubjectsInput[]
    createMany?: final_gradeCreateManySubjectsInputEnvelope
    connect?: final_gradeWhereUniqueInput | final_gradeWhereUniqueInput[]
  }

  export type subject_classCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<subject_classCreateWithoutSubjectsInput, subject_classUncheckedCreateWithoutSubjectsInput> | subject_classCreateWithoutSubjectsInput[] | subject_classUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: subject_classCreateOrConnectWithoutSubjectsInput | subject_classCreateOrConnectWithoutSubjectsInput[]
    createMany?: subject_classCreateManySubjectsInputEnvelope
    connect?: subject_classWhereUniqueInput | subject_classWhereUniqueInput[]
  }

  export type final_gradeUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<final_gradeCreateWithoutSubjectsInput, final_gradeUncheckedCreateWithoutSubjectsInput> | final_gradeCreateWithoutSubjectsInput[] | final_gradeUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: final_gradeCreateOrConnectWithoutSubjectsInput | final_gradeCreateOrConnectWithoutSubjectsInput[]
    createMany?: final_gradeCreateManySubjectsInputEnvelope
    connect?: final_gradeWhereUniqueInput | final_gradeWhereUniqueInput[]
  }

  export type subject_classUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<subject_classCreateWithoutSubjectsInput, subject_classUncheckedCreateWithoutSubjectsInput> | subject_classCreateWithoutSubjectsInput[] | subject_classUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: subject_classCreateOrConnectWithoutSubjectsInput | subject_classCreateOrConnectWithoutSubjectsInput[]
    createMany?: subject_classCreateManySubjectsInputEnvelope
    connect?: subject_classWhereUniqueInput | subject_classWhereUniqueInput[]
  }

  export type NullableEnumsubjects_subject_catFieldUpdateOperationsInput = {
    set?: $Enums.subjects_subject_cat | null
  }

  export type final_gradeUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<final_gradeCreateWithoutSubjectsInput, final_gradeUncheckedCreateWithoutSubjectsInput> | final_gradeCreateWithoutSubjectsInput[] | final_gradeUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: final_gradeCreateOrConnectWithoutSubjectsInput | final_gradeCreateOrConnectWithoutSubjectsInput[]
    upsert?: final_gradeUpsertWithWhereUniqueWithoutSubjectsInput | final_gradeUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: final_gradeCreateManySubjectsInputEnvelope
    set?: final_gradeWhereUniqueInput | final_gradeWhereUniqueInput[]
    disconnect?: final_gradeWhereUniqueInput | final_gradeWhereUniqueInput[]
    delete?: final_gradeWhereUniqueInput | final_gradeWhereUniqueInput[]
    connect?: final_gradeWhereUniqueInput | final_gradeWhereUniqueInput[]
    update?: final_gradeUpdateWithWhereUniqueWithoutSubjectsInput | final_gradeUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: final_gradeUpdateManyWithWhereWithoutSubjectsInput | final_gradeUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: final_gradeScalarWhereInput | final_gradeScalarWhereInput[]
  }

  export type subject_classUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<subject_classCreateWithoutSubjectsInput, subject_classUncheckedCreateWithoutSubjectsInput> | subject_classCreateWithoutSubjectsInput[] | subject_classUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: subject_classCreateOrConnectWithoutSubjectsInput | subject_classCreateOrConnectWithoutSubjectsInput[]
    upsert?: subject_classUpsertWithWhereUniqueWithoutSubjectsInput | subject_classUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: subject_classCreateManySubjectsInputEnvelope
    set?: subject_classWhereUniqueInput | subject_classWhereUniqueInput[]
    disconnect?: subject_classWhereUniqueInput | subject_classWhereUniqueInput[]
    delete?: subject_classWhereUniqueInput | subject_classWhereUniqueInput[]
    connect?: subject_classWhereUniqueInput | subject_classWhereUniqueInput[]
    update?: subject_classUpdateWithWhereUniqueWithoutSubjectsInput | subject_classUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: subject_classUpdateManyWithWhereWithoutSubjectsInput | subject_classUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: subject_classScalarWhereInput | subject_classScalarWhereInput[]
  }

  export type final_gradeUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<final_gradeCreateWithoutSubjectsInput, final_gradeUncheckedCreateWithoutSubjectsInput> | final_gradeCreateWithoutSubjectsInput[] | final_gradeUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: final_gradeCreateOrConnectWithoutSubjectsInput | final_gradeCreateOrConnectWithoutSubjectsInput[]
    upsert?: final_gradeUpsertWithWhereUniqueWithoutSubjectsInput | final_gradeUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: final_gradeCreateManySubjectsInputEnvelope
    set?: final_gradeWhereUniqueInput | final_gradeWhereUniqueInput[]
    disconnect?: final_gradeWhereUniqueInput | final_gradeWhereUniqueInput[]
    delete?: final_gradeWhereUniqueInput | final_gradeWhereUniqueInput[]
    connect?: final_gradeWhereUniqueInput | final_gradeWhereUniqueInput[]
    update?: final_gradeUpdateWithWhereUniqueWithoutSubjectsInput | final_gradeUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: final_gradeUpdateManyWithWhereWithoutSubjectsInput | final_gradeUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: final_gradeScalarWhereInput | final_gradeScalarWhereInput[]
  }

  export type subject_classUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<subject_classCreateWithoutSubjectsInput, subject_classUncheckedCreateWithoutSubjectsInput> | subject_classCreateWithoutSubjectsInput[] | subject_classUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: subject_classCreateOrConnectWithoutSubjectsInput | subject_classCreateOrConnectWithoutSubjectsInput[]
    upsert?: subject_classUpsertWithWhereUniqueWithoutSubjectsInput | subject_classUpsertWithWhereUniqueWithoutSubjectsInput[]
    createMany?: subject_classCreateManySubjectsInputEnvelope
    set?: subject_classWhereUniqueInput | subject_classWhereUniqueInput[]
    disconnect?: subject_classWhereUniqueInput | subject_classWhereUniqueInput[]
    delete?: subject_classWhereUniqueInput | subject_classWhereUniqueInput[]
    connect?: subject_classWhereUniqueInput | subject_classWhereUniqueInput[]
    update?: subject_classUpdateWithWhereUniqueWithoutSubjectsInput | subject_classUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: subject_classUpdateManyWithWhereWithoutSubjectsInput | subject_classUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: subject_classScalarWhereInput | subject_classScalarWhereInput[]
  }

  export type subject_classCreateNestedOneWithoutTestInput = {
    create?: XOR<subject_classCreateWithoutTestInput, subject_classUncheckedCreateWithoutTestInput>
    connectOrCreate?: subject_classCreateOrConnectWithoutTestInput
    connect?: subject_classWhereUniqueInput
  }

  export type test_resultCreateNestedManyWithoutTestInput = {
    create?: XOR<test_resultCreateWithoutTestInput, test_resultUncheckedCreateWithoutTestInput> | test_resultCreateWithoutTestInput[] | test_resultUncheckedCreateWithoutTestInput[]
    connectOrCreate?: test_resultCreateOrConnectWithoutTestInput | test_resultCreateOrConnectWithoutTestInput[]
    createMany?: test_resultCreateManyTestInputEnvelope
    connect?: test_resultWhereUniqueInput | test_resultWhereUniqueInput[]
  }

  export type test_resultUncheckedCreateNestedManyWithoutTestInput = {
    create?: XOR<test_resultCreateWithoutTestInput, test_resultUncheckedCreateWithoutTestInput> | test_resultCreateWithoutTestInput[] | test_resultUncheckedCreateWithoutTestInput[]
    connectOrCreate?: test_resultCreateOrConnectWithoutTestInput | test_resultCreateOrConnectWithoutTestInput[]
    createMany?: test_resultCreateManyTestInputEnvelope
    connect?: test_resultWhereUniqueInput | test_resultWhereUniqueInput[]
  }

  export type NullableEnumtest_test_periodFieldUpdateOperationsInput = {
    set?: $Enums.test_test_period | null
  }

  export type subject_classUpdateOneWithoutTestNestedInput = {
    create?: XOR<subject_classCreateWithoutTestInput, subject_classUncheckedCreateWithoutTestInput>
    connectOrCreate?: subject_classCreateOrConnectWithoutTestInput
    upsert?: subject_classUpsertWithoutTestInput
    disconnect?: subject_classWhereInput | boolean
    delete?: subject_classWhereInput | boolean
    connect?: subject_classWhereUniqueInput
    update?: XOR<XOR<subject_classUpdateToOneWithWhereWithoutTestInput, subject_classUpdateWithoutTestInput>, subject_classUncheckedUpdateWithoutTestInput>
  }

  export type test_resultUpdateManyWithoutTestNestedInput = {
    create?: XOR<test_resultCreateWithoutTestInput, test_resultUncheckedCreateWithoutTestInput> | test_resultCreateWithoutTestInput[] | test_resultUncheckedCreateWithoutTestInput[]
    connectOrCreate?: test_resultCreateOrConnectWithoutTestInput | test_resultCreateOrConnectWithoutTestInput[]
    upsert?: test_resultUpsertWithWhereUniqueWithoutTestInput | test_resultUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: test_resultCreateManyTestInputEnvelope
    set?: test_resultWhereUniqueInput | test_resultWhereUniqueInput[]
    disconnect?: test_resultWhereUniqueInput | test_resultWhereUniqueInput[]
    delete?: test_resultWhereUniqueInput | test_resultWhereUniqueInput[]
    connect?: test_resultWhereUniqueInput | test_resultWhereUniqueInput[]
    update?: test_resultUpdateWithWhereUniqueWithoutTestInput | test_resultUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: test_resultUpdateManyWithWhereWithoutTestInput | test_resultUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: test_resultScalarWhereInput | test_resultScalarWhereInput[]
  }

  export type test_resultUncheckedUpdateManyWithoutTestNestedInput = {
    create?: XOR<test_resultCreateWithoutTestInput, test_resultUncheckedCreateWithoutTestInput> | test_resultCreateWithoutTestInput[] | test_resultUncheckedCreateWithoutTestInput[]
    connectOrCreate?: test_resultCreateOrConnectWithoutTestInput | test_resultCreateOrConnectWithoutTestInput[]
    upsert?: test_resultUpsertWithWhereUniqueWithoutTestInput | test_resultUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: test_resultCreateManyTestInputEnvelope
    set?: test_resultWhereUniqueInput | test_resultWhereUniqueInput[]
    disconnect?: test_resultWhereUniqueInput | test_resultWhereUniqueInput[]
    delete?: test_resultWhereUniqueInput | test_resultWhereUniqueInput[]
    connect?: test_resultWhereUniqueInput | test_resultWhereUniqueInput[]
    update?: test_resultUpdateWithWhereUniqueWithoutTestInput | test_resultUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: test_resultUpdateManyWithWhereWithoutTestInput | test_resultUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: test_resultScalarWhereInput | test_resultScalarWhereInput[]
  }

  export type testCreateNestedOneWithoutTest_resultInput = {
    create?: XOR<testCreateWithoutTest_resultInput, testUncheckedCreateWithoutTest_resultInput>
    connectOrCreate?: testCreateOrConnectWithoutTest_resultInput
    connect?: testWhereUniqueInput
  }

  export type studentCreateNestedOneWithoutTest_resultInput = {
    create?: XOR<studentCreateWithoutTest_resultInput, studentUncheckedCreateWithoutTest_resultInput>
    connectOrCreate?: studentCreateOrConnectWithoutTest_resultInput
    connect?: studentWhereUniqueInput
  }

  export type testUpdateOneRequiredWithoutTest_resultNestedInput = {
    create?: XOR<testCreateWithoutTest_resultInput, testUncheckedCreateWithoutTest_resultInput>
    connectOrCreate?: testCreateOrConnectWithoutTest_resultInput
    upsert?: testUpsertWithoutTest_resultInput
    connect?: testWhereUniqueInput
    update?: XOR<XOR<testUpdateToOneWithWhereWithoutTest_resultInput, testUpdateWithoutTest_resultInput>, testUncheckedUpdateWithoutTest_resultInput>
  }

  export type studentUpdateOneWithoutTest_resultNestedInput = {
    create?: XOR<studentCreateWithoutTest_resultInput, studentUncheckedCreateWithoutTest_resultInput>
    connectOrCreate?: studentCreateOrConnectWithoutTest_resultInput
    upsert?: studentUpsertWithoutTest_resultInput
    disconnect?: studentWhereInput | boolean
    delete?: studentWhereInput | boolean
    connect?: studentWhereUniqueInput
    update?: XOR<XOR<studentUpdateToOneWithWhereWithoutTest_resultInput, studentUpdateWithoutTest_resultInput>, studentUncheckedUpdateWithoutTest_resultInput>
  }

  export type active_classCreateNestedManyWithoutRenamedclassInput = {
    create?: XOR<active_classCreateWithoutRenamedclassInput, active_classUncheckedCreateWithoutRenamedclassInput> | active_classCreateWithoutRenamedclassInput[] | active_classUncheckedCreateWithoutRenamedclassInput[]
    connectOrCreate?: active_classCreateOrConnectWithoutRenamedclassInput | active_classCreateOrConnectWithoutRenamedclassInput[]
    createMany?: active_classCreateManyRenamedclassInputEnvelope
    connect?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
  }

  export type active_classUncheckedCreateNestedManyWithoutRenamedclassInput = {
    create?: XOR<active_classCreateWithoutRenamedclassInput, active_classUncheckedCreateWithoutRenamedclassInput> | active_classCreateWithoutRenamedclassInput[] | active_classUncheckedCreateWithoutRenamedclassInput[]
    connectOrCreate?: active_classCreateOrConnectWithoutRenamedclassInput | active_classCreateOrConnectWithoutRenamedclassInput[]
    createMany?: active_classCreateManyRenamedclassInputEnvelope
    connect?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
  }

  export type active_classUpdateManyWithoutRenamedclassNestedInput = {
    create?: XOR<active_classCreateWithoutRenamedclassInput, active_classUncheckedCreateWithoutRenamedclassInput> | active_classCreateWithoutRenamedclassInput[] | active_classUncheckedCreateWithoutRenamedclassInput[]
    connectOrCreate?: active_classCreateOrConnectWithoutRenamedclassInput | active_classCreateOrConnectWithoutRenamedclassInput[]
    upsert?: active_classUpsertWithWhereUniqueWithoutRenamedclassInput | active_classUpsertWithWhereUniqueWithoutRenamedclassInput[]
    createMany?: active_classCreateManyRenamedclassInputEnvelope
    set?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    disconnect?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    delete?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    connect?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    update?: active_classUpdateWithWhereUniqueWithoutRenamedclassInput | active_classUpdateWithWhereUniqueWithoutRenamedclassInput[]
    updateMany?: active_classUpdateManyWithWhereWithoutRenamedclassInput | active_classUpdateManyWithWhereWithoutRenamedclassInput[]
    deleteMany?: active_classScalarWhereInput | active_classScalarWhereInput[]
  }

  export type active_classUncheckedUpdateManyWithoutRenamedclassNestedInput = {
    create?: XOR<active_classCreateWithoutRenamedclassInput, active_classUncheckedCreateWithoutRenamedclassInput> | active_classCreateWithoutRenamedclassInput[] | active_classUncheckedCreateWithoutRenamedclassInput[]
    connectOrCreate?: active_classCreateOrConnectWithoutRenamedclassInput | active_classCreateOrConnectWithoutRenamedclassInput[]
    upsert?: active_classUpsertWithWhereUniqueWithoutRenamedclassInput | active_classUpsertWithWhereUniqueWithoutRenamedclassInput[]
    createMany?: active_classCreateManyRenamedclassInputEnvelope
    set?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    disconnect?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    delete?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    connect?: active_classWhereUniqueInput | active_classWhereUniqueInput[]
    update?: active_classUpdateWithWhereUniqueWithoutRenamedclassInput | active_classUpdateWithWhereUniqueWithoutRenamedclassInput[]
    updateMany?: active_classUpdateManyWithWhereWithoutRenamedclassInput | active_classUpdateManyWithWhereWithoutRenamedclassInput[]
    deleteMany?: active_classScalarWhereInput | active_classScalarWhereInput[]
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Uint8Array
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumfinal_grade_test_periodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.final_grade_test_period | Enumfinal_grade_test_periodFieldRefInput<$PrismaModel> | null
    in?: $Enums.final_grade_test_period[] | null
    notIn?: $Enums.final_grade_test_period[] | null
    not?: NestedEnumfinal_grade_test_periodNullableFilter<$PrismaModel> | $Enums.final_grade_test_period | null
  }

  export type NestedEnumfinal_grade_test_periodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.final_grade_test_period | Enumfinal_grade_test_periodFieldRefInput<$PrismaModel> | null
    in?: $Enums.final_grade_test_period[] | null
    notIn?: $Enums.final_grade_test_period[] | null
    not?: NestedEnumfinal_grade_test_periodNullableWithAggregatesFilter<$PrismaModel> | $Enums.final_grade_test_period | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumfinal_grade_test_periodNullableFilter<$PrismaModel>
    _max?: NestedEnumfinal_grade_test_periodNullableFilter<$PrismaModel>
  }

  export type NestedEnumsubjects_subject_catNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.subjects_subject_cat | Enumsubjects_subject_catFieldRefInput<$PrismaModel> | null
    in?: $Enums.subjects_subject_cat[] | null
    notIn?: $Enums.subjects_subject_cat[] | null
    not?: NestedEnumsubjects_subject_catNullableFilter<$PrismaModel> | $Enums.subjects_subject_cat | null
  }

  export type NestedEnumsubjects_subject_catNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.subjects_subject_cat | Enumsubjects_subject_catFieldRefInput<$PrismaModel> | null
    in?: $Enums.subjects_subject_cat[] | null
    notIn?: $Enums.subjects_subject_cat[] | null
    not?: NestedEnumsubjects_subject_catNullableWithAggregatesFilter<$PrismaModel> | $Enums.subjects_subject_cat | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumsubjects_subject_catNullableFilter<$PrismaModel>
    _max?: NestedEnumsubjects_subject_catNullableFilter<$PrismaModel>
  }

  export type NestedEnumtest_test_periodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.test_test_period | Enumtest_test_periodFieldRefInput<$PrismaModel> | null
    in?: $Enums.test_test_period[] | null
    notIn?: $Enums.test_test_period[] | null
    not?: NestedEnumtest_test_periodNullableFilter<$PrismaModel> | $Enums.test_test_period | null
  }

  export type NestedEnumtest_test_periodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.test_test_period | Enumtest_test_periodFieldRefInput<$PrismaModel> | null
    in?: $Enums.test_test_period[] | null
    notIn?: $Enums.test_test_period[] | null
    not?: NestedEnumtest_test_periodNullableWithAggregatesFilter<$PrismaModel> | $Enums.test_test_period | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumtest_test_periodNullableFilter<$PrismaModel>
    _max?: NestedEnumtest_test_periodNullableFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[]
    notIn?: Uint8Array[]
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[]
    notIn?: Uint8Array[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type classesCreateWithoutActive_classInput = {
    class_code: string
    class_name?: string | null
    class_base?: string | null
  }

  export type classesUncheckedCreateWithoutActive_classInput = {
    class_code: string
    class_name?: string | null
    class_base?: string | null
  }

  export type classesCreateOrConnectWithoutActive_classInput = {
    where: classesWhereUniqueInput
    create: XOR<classesCreateWithoutActive_classInput, classesUncheckedCreateWithoutActive_classInput>
  }

  export type periodCreateWithoutActive_class_active_class_periodToperiodInput = {
    period: number
    period_status: string
  }

  export type periodUncheckedCreateWithoutActive_class_active_class_periodToperiodInput = {
    period: number
    period_status: string
  }

  export type periodCreateOrConnectWithoutActive_class_active_class_periodToperiodInput = {
    where: periodWhereUniqueInput
    create: XOR<periodCreateWithoutActive_class_active_class_periodToperiodInput, periodUncheckedCreateWithoutActive_class_active_class_periodToperiodInput>
  }

  export type employeeCreateWithoutActive_classInput = {
    employee_fn: string
    employee_ln: string
    employee_dob: Date | string
    employee_join?: Date | string | null
    employee_img?: string | null
    employee_info?: string | null
    employee_degree?: string | null
    employee_exp?: Date | string | null
    employee_sal1?: number
    employee_sal2?: number | null
    employee_wh?: number | null
    employee_role?: employee_roleCreateNestedManyWithoutEmployeeInput
    subject_class?: subject_classCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutActive_classInput = {
    employee_id?: number
    employee_fn: string
    employee_ln: string
    employee_dob: Date | string
    employee_join?: Date | string | null
    employee_img?: string | null
    employee_info?: string | null
    employee_degree?: string | null
    employee_exp?: Date | string | null
    employee_sal1?: number
    employee_sal2?: number | null
    employee_wh?: number | null
    employee_role?: employee_roleUncheckedCreateNestedManyWithoutEmployeeInput
    subject_class?: subject_classUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutActive_classInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutActive_classInput, employeeUncheckedCreateWithoutActive_classInput>
  }

  export type classesUpsertWithoutActive_classInput = {
    update: XOR<classesUpdateWithoutActive_classInput, classesUncheckedUpdateWithoutActive_classInput>
    create: XOR<classesCreateWithoutActive_classInput, classesUncheckedCreateWithoutActive_classInput>
    where?: classesWhereInput
  }

  export type classesUpdateToOneWithWhereWithoutActive_classInput = {
    where?: classesWhereInput
    data: XOR<classesUpdateWithoutActive_classInput, classesUncheckedUpdateWithoutActive_classInput>
  }

  export type classesUpdateWithoutActive_classInput = {
    class_code?: StringFieldUpdateOperationsInput | string
    class_name?: NullableStringFieldUpdateOperationsInput | string | null
    class_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type classesUncheckedUpdateWithoutActive_classInput = {
    class_code?: StringFieldUpdateOperationsInput | string
    class_name?: NullableStringFieldUpdateOperationsInput | string | null
    class_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type periodUpsertWithoutActive_class_active_class_periodToperiodInput = {
    update: XOR<periodUpdateWithoutActive_class_active_class_periodToperiodInput, periodUncheckedUpdateWithoutActive_class_active_class_periodToperiodInput>
    create: XOR<periodCreateWithoutActive_class_active_class_periodToperiodInput, periodUncheckedCreateWithoutActive_class_active_class_periodToperiodInput>
    where?: periodWhereInput
  }

  export type periodUpdateToOneWithWhereWithoutActive_class_active_class_periodToperiodInput = {
    where?: periodWhereInput
    data: XOR<periodUpdateWithoutActive_class_active_class_periodToperiodInput, periodUncheckedUpdateWithoutActive_class_active_class_periodToperiodInput>
  }

  export type periodUpdateWithoutActive_class_active_class_periodToperiodInput = {
    period?: IntFieldUpdateOperationsInput | number
    period_status?: StringFieldUpdateOperationsInput | string
  }

  export type periodUncheckedUpdateWithoutActive_class_active_class_periodToperiodInput = {
    period?: IntFieldUpdateOperationsInput | number
    period_status?: StringFieldUpdateOperationsInput | string
  }

  export type employeeUpsertWithoutActive_classInput = {
    update: XOR<employeeUpdateWithoutActive_classInput, employeeUncheckedUpdateWithoutActive_classInput>
    create: XOR<employeeCreateWithoutActive_classInput, employeeUncheckedCreateWithoutActive_classInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutActive_classInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutActive_classInput, employeeUncheckedUpdateWithoutActive_classInput>
  }

  export type employeeUpdateWithoutActive_classInput = {
    employee_fn?: StringFieldUpdateOperationsInput | string
    employee_ln?: StringFieldUpdateOperationsInput | string
    employee_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    employee_join?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_img?: NullableStringFieldUpdateOperationsInput | string | null
    employee_info?: NullableStringFieldUpdateOperationsInput | string | null
    employee_degree?: NullableStringFieldUpdateOperationsInput | string | null
    employee_exp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_sal1?: FloatFieldUpdateOperationsInput | number
    employee_sal2?: NullableFloatFieldUpdateOperationsInput | number | null
    employee_wh?: NullableFloatFieldUpdateOperationsInput | number | null
    employee_role?: employee_roleUpdateManyWithoutEmployeeNestedInput
    subject_class?: subject_classUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutActive_classInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_fn?: StringFieldUpdateOperationsInput | string
    employee_ln?: StringFieldUpdateOperationsInput | string
    employee_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    employee_join?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_img?: NullableStringFieldUpdateOperationsInput | string | null
    employee_info?: NullableStringFieldUpdateOperationsInput | string | null
    employee_degree?: NullableStringFieldUpdateOperationsInput | string | null
    employee_exp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_sal1?: FloatFieldUpdateOperationsInput | number
    employee_sal2?: NullableFloatFieldUpdateOperationsInput | number | null
    employee_wh?: NullableFloatFieldUpdateOperationsInput | number | null
    employee_role?: employee_roleUncheckedUpdateManyWithoutEmployeeNestedInput
    subject_class?: subject_classUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type subject_classCreateWithoutAgendaInput = {
    employee?: employeeCreateNestedOneWithoutSubject_classInput
    subjects: subjectsCreateNestedOneWithoutSubject_classInput
    test?: testCreateNestedManyWithoutSubject_classInput
  }

  export type subject_classUncheckedCreateWithoutAgendaInput = {
    subject_class_id?: number
    subject_code: string
    instructor?: number | null
    test?: testUncheckedCreateNestedManyWithoutSubject_classInput
  }

  export type subject_classCreateOrConnectWithoutAgendaInput = {
    where: subject_classWhereUniqueInput
    create: XOR<subject_classCreateWithoutAgendaInput, subject_classUncheckedCreateWithoutAgendaInput>
  }

  export type subject_classUpsertWithoutAgendaInput = {
    update: XOR<subject_classUpdateWithoutAgendaInput, subject_classUncheckedUpdateWithoutAgendaInput>
    create: XOR<subject_classCreateWithoutAgendaInput, subject_classUncheckedCreateWithoutAgendaInput>
    where?: subject_classWhereInput
  }

  export type subject_classUpdateToOneWithWhereWithoutAgendaInput = {
    where?: subject_classWhereInput
    data: XOR<subject_classUpdateWithoutAgendaInput, subject_classUncheckedUpdateWithoutAgendaInput>
  }

  export type subject_classUpdateWithoutAgendaInput = {
    employee?: employeeUpdateOneWithoutSubject_classNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutSubject_classNestedInput
    test?: testUpdateManyWithoutSubject_classNestedInput
  }

  export type subject_classUncheckedUpdateWithoutAgendaInput = {
    subject_class_id?: IntFieldUpdateOperationsInput | number
    subject_code?: StringFieldUpdateOperationsInput | string
    instructor?: NullableIntFieldUpdateOperationsInput | number | null
    test?: testUncheckedUpdateManyWithoutSubject_classNestedInput
  }

  export type active_classCreateWithoutEmployeeInput = {
    Renamedclass?: classesCreateNestedOneWithoutActive_classInput
    period_active_class_periodToperiod?: periodCreateNestedOneWithoutActive_class_active_class_periodToperiodInput
  }

  export type active_classUncheckedCreateWithoutEmployeeInput = {
    active_class_id?: number
    class_code?: string | null
    period?: number | null
  }

  export type active_classCreateOrConnectWithoutEmployeeInput = {
    where: active_classWhereUniqueInput
    create: XOR<active_classCreateWithoutEmployeeInput, active_classUncheckedCreateWithoutEmployeeInput>
  }

  export type active_classCreateManyEmployeeInputEnvelope = {
    data: active_classCreateManyEmployeeInput | active_classCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type employee_roleCreateWithoutEmployeeInput = {
    roles: rolesCreateNestedOneWithoutEmployee_roleInput
  }

  export type employee_roleUncheckedCreateWithoutEmployeeInput = {
    employee_role_id?: number
    role_id: number
  }

  export type employee_roleCreateOrConnectWithoutEmployeeInput = {
    where: employee_roleWhereUniqueInput
    create: XOR<employee_roleCreateWithoutEmployeeInput, employee_roleUncheckedCreateWithoutEmployeeInput>
  }

  export type employee_roleCreateManyEmployeeInputEnvelope = {
    data: employee_roleCreateManyEmployeeInput | employee_roleCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type subject_classCreateWithoutEmployeeInput = {
    agenda?: agendaCreateNestedManyWithoutSubject_classInput
    subjects: subjectsCreateNestedOneWithoutSubject_classInput
    test?: testCreateNestedManyWithoutSubject_classInput
  }

  export type subject_classUncheckedCreateWithoutEmployeeInput = {
    subject_class_id?: number
    subject_code: string
    agenda?: agendaUncheckedCreateNestedManyWithoutSubject_classInput
    test?: testUncheckedCreateNestedManyWithoutSubject_classInput
  }

  export type subject_classCreateOrConnectWithoutEmployeeInput = {
    where: subject_classWhereUniqueInput
    create: XOR<subject_classCreateWithoutEmployeeInput, subject_classUncheckedCreateWithoutEmployeeInput>
  }

  export type subject_classCreateManyEmployeeInputEnvelope = {
    data: subject_classCreateManyEmployeeInput | subject_classCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type active_classUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: active_classWhereUniqueInput
    update: XOR<active_classUpdateWithoutEmployeeInput, active_classUncheckedUpdateWithoutEmployeeInput>
    create: XOR<active_classCreateWithoutEmployeeInput, active_classUncheckedCreateWithoutEmployeeInput>
  }

  export type active_classUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: active_classWhereUniqueInput
    data: XOR<active_classUpdateWithoutEmployeeInput, active_classUncheckedUpdateWithoutEmployeeInput>
  }

  export type active_classUpdateManyWithWhereWithoutEmployeeInput = {
    where: active_classScalarWhereInput
    data: XOR<active_classUpdateManyMutationInput, active_classUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type active_classScalarWhereInput = {
    AND?: active_classScalarWhereInput | active_classScalarWhereInput[]
    OR?: active_classScalarWhereInput[]
    NOT?: active_classScalarWhereInput | active_classScalarWhereInput[]
    active_class_id?: IntFilter<"active_class"> | number
    class_code?: StringNullableFilter<"active_class"> | string | null
    period?: IntNullableFilter<"active_class"> | number | null
    class_coordinator?: IntNullableFilter<"active_class"> | number | null
  }

  export type employee_roleUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: employee_roleWhereUniqueInput
    update: XOR<employee_roleUpdateWithoutEmployeeInput, employee_roleUncheckedUpdateWithoutEmployeeInput>
    create: XOR<employee_roleCreateWithoutEmployeeInput, employee_roleUncheckedCreateWithoutEmployeeInput>
  }

  export type employee_roleUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: employee_roleWhereUniqueInput
    data: XOR<employee_roleUpdateWithoutEmployeeInput, employee_roleUncheckedUpdateWithoutEmployeeInput>
  }

  export type employee_roleUpdateManyWithWhereWithoutEmployeeInput = {
    where: employee_roleScalarWhereInput
    data: XOR<employee_roleUpdateManyMutationInput, employee_roleUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type employee_roleScalarWhereInput = {
    AND?: employee_roleScalarWhereInput | employee_roleScalarWhereInput[]
    OR?: employee_roleScalarWhereInput[]
    NOT?: employee_roleScalarWhereInput | employee_roleScalarWhereInput[]
    employee_role_id?: IntFilter<"employee_role"> | number
    role_id?: IntFilter<"employee_role"> | number
    employee_id?: IntFilter<"employee_role"> | number
  }

  export type subject_classUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: subject_classWhereUniqueInput
    update: XOR<subject_classUpdateWithoutEmployeeInput, subject_classUncheckedUpdateWithoutEmployeeInput>
    create: XOR<subject_classCreateWithoutEmployeeInput, subject_classUncheckedCreateWithoutEmployeeInput>
  }

  export type subject_classUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: subject_classWhereUniqueInput
    data: XOR<subject_classUpdateWithoutEmployeeInput, subject_classUncheckedUpdateWithoutEmployeeInput>
  }

  export type subject_classUpdateManyWithWhereWithoutEmployeeInput = {
    where: subject_classScalarWhereInput
    data: XOR<subject_classUpdateManyMutationInput, subject_classUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type subject_classScalarWhereInput = {
    AND?: subject_classScalarWhereInput | subject_classScalarWhereInput[]
    OR?: subject_classScalarWhereInput[]
    NOT?: subject_classScalarWhereInput | subject_classScalarWhereInput[]
    subject_class_id?: IntFilter<"subject_class"> | number
    subject_code?: StringFilter<"subject_class"> | string
    instructor?: IntNullableFilter<"subject_class"> | number | null
  }

  export type rolesCreateWithoutEmployee_roleInput = {
    role_name: string
    role_description?: string | null
  }

  export type rolesUncheckedCreateWithoutEmployee_roleInput = {
    role_id?: number
    role_name: string
    role_description?: string | null
  }

  export type rolesCreateOrConnectWithoutEmployee_roleInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutEmployee_roleInput, rolesUncheckedCreateWithoutEmployee_roleInput>
  }

  export type employeeCreateWithoutEmployee_roleInput = {
    employee_fn: string
    employee_ln: string
    employee_dob: Date | string
    employee_join?: Date | string | null
    employee_img?: string | null
    employee_info?: string | null
    employee_degree?: string | null
    employee_exp?: Date | string | null
    employee_sal1?: number
    employee_sal2?: number | null
    employee_wh?: number | null
    active_class?: active_classCreateNestedManyWithoutEmployeeInput
    subject_class?: subject_classCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutEmployee_roleInput = {
    employee_id?: number
    employee_fn: string
    employee_ln: string
    employee_dob: Date | string
    employee_join?: Date | string | null
    employee_img?: string | null
    employee_info?: string | null
    employee_degree?: string | null
    employee_exp?: Date | string | null
    employee_sal1?: number
    employee_sal2?: number | null
    employee_wh?: number | null
    active_class?: active_classUncheckedCreateNestedManyWithoutEmployeeInput
    subject_class?: subject_classUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutEmployee_roleInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutEmployee_roleInput, employeeUncheckedCreateWithoutEmployee_roleInput>
  }

  export type rolesUpsertWithoutEmployee_roleInput = {
    update: XOR<rolesUpdateWithoutEmployee_roleInput, rolesUncheckedUpdateWithoutEmployee_roleInput>
    create: XOR<rolesCreateWithoutEmployee_roleInput, rolesUncheckedCreateWithoutEmployee_roleInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutEmployee_roleInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutEmployee_roleInput, rolesUncheckedUpdateWithoutEmployee_roleInput>
  }

  export type rolesUpdateWithoutEmployee_roleInput = {
    role_name?: StringFieldUpdateOperationsInput | string
    role_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rolesUncheckedUpdateWithoutEmployee_roleInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    role_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type employeeUpsertWithoutEmployee_roleInput = {
    update: XOR<employeeUpdateWithoutEmployee_roleInput, employeeUncheckedUpdateWithoutEmployee_roleInput>
    create: XOR<employeeCreateWithoutEmployee_roleInput, employeeUncheckedCreateWithoutEmployee_roleInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutEmployee_roleInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutEmployee_roleInput, employeeUncheckedUpdateWithoutEmployee_roleInput>
  }

  export type employeeUpdateWithoutEmployee_roleInput = {
    employee_fn?: StringFieldUpdateOperationsInput | string
    employee_ln?: StringFieldUpdateOperationsInput | string
    employee_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    employee_join?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_img?: NullableStringFieldUpdateOperationsInput | string | null
    employee_info?: NullableStringFieldUpdateOperationsInput | string | null
    employee_degree?: NullableStringFieldUpdateOperationsInput | string | null
    employee_exp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_sal1?: FloatFieldUpdateOperationsInput | number
    employee_sal2?: NullableFloatFieldUpdateOperationsInput | number | null
    employee_wh?: NullableFloatFieldUpdateOperationsInput | number | null
    active_class?: active_classUpdateManyWithoutEmployeeNestedInput
    subject_class?: subject_classUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutEmployee_roleInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_fn?: StringFieldUpdateOperationsInput | string
    employee_ln?: StringFieldUpdateOperationsInput | string
    employee_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    employee_join?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_img?: NullableStringFieldUpdateOperationsInput | string | null
    employee_info?: NullableStringFieldUpdateOperationsInput | string | null
    employee_degree?: NullableStringFieldUpdateOperationsInput | string | null
    employee_exp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_sal1?: FloatFieldUpdateOperationsInput | number
    employee_sal2?: NullableFloatFieldUpdateOperationsInput | number | null
    employee_wh?: NullableFloatFieldUpdateOperationsInput | number | null
    active_class?: active_classUncheckedUpdateManyWithoutEmployeeNestedInput
    subject_class?: subject_classUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type subjectsCreateWithoutFinal_gradeInput = {
    subject_code: string
    subject_name: string
    subject_cat?: $Enums.subjects_subject_cat | null
    subject_class?: subject_classCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsUncheckedCreateWithoutFinal_gradeInput = {
    subject_code: string
    subject_name: string
    subject_cat?: $Enums.subjects_subject_cat | null
    subject_class?: subject_classUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsCreateOrConnectWithoutFinal_gradeInput = {
    where: subjectsWhereUniqueInput
    create: XOR<subjectsCreateWithoutFinal_gradeInput, subjectsUncheckedCreateWithoutFinal_gradeInput>
  }

  export type studentCreateWithoutFinal_gradeInput = {
    student_id: string
    student_fname: string
    student_lname: string
    student_dob: Date | string
    student_account: string
    student_pass: string
    note?: string | null
    parent_student_father_idToparent: parentCreateNestedOneWithoutStudent_student_father_idToparentInput
    parent_student_mother_idToparent: parentCreateNestedOneWithoutStudent_student_mother_idToparentInput
    test_result?: test_resultCreateNestedManyWithoutStudentInput
  }

  export type studentUncheckedCreateWithoutFinal_gradeInput = {
    student_id: string
    mother_id: number
    father_id: number
    student_fname: string
    student_lname: string
    student_dob: Date | string
    student_account: string
    student_pass: string
    note?: string | null
    test_result?: test_resultUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentCreateOrConnectWithoutFinal_gradeInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutFinal_gradeInput, studentUncheckedCreateWithoutFinal_gradeInput>
  }

  export type subjectsUpsertWithoutFinal_gradeInput = {
    update: XOR<subjectsUpdateWithoutFinal_gradeInput, subjectsUncheckedUpdateWithoutFinal_gradeInput>
    create: XOR<subjectsCreateWithoutFinal_gradeInput, subjectsUncheckedCreateWithoutFinal_gradeInput>
    where?: subjectsWhereInput
  }

  export type subjectsUpdateToOneWithWhereWithoutFinal_gradeInput = {
    where?: subjectsWhereInput
    data: XOR<subjectsUpdateWithoutFinal_gradeInput, subjectsUncheckedUpdateWithoutFinal_gradeInput>
  }

  export type subjectsUpdateWithoutFinal_gradeInput = {
    subject_code?: StringFieldUpdateOperationsInput | string
    subject_name?: StringFieldUpdateOperationsInput | string
    subject_cat?: NullableEnumsubjects_subject_catFieldUpdateOperationsInput | $Enums.subjects_subject_cat | null
    subject_class?: subject_classUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectsUncheckedUpdateWithoutFinal_gradeInput = {
    subject_code?: StringFieldUpdateOperationsInput | string
    subject_name?: StringFieldUpdateOperationsInput | string
    subject_cat?: NullableEnumsubjects_subject_catFieldUpdateOperationsInput | $Enums.subjects_subject_cat | null
    subject_class?: subject_classUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type studentUpsertWithoutFinal_gradeInput = {
    update: XOR<studentUpdateWithoutFinal_gradeInput, studentUncheckedUpdateWithoutFinal_gradeInput>
    create: XOR<studentCreateWithoutFinal_gradeInput, studentUncheckedCreateWithoutFinal_gradeInput>
    where?: studentWhereInput
  }

  export type studentUpdateToOneWithWhereWithoutFinal_gradeInput = {
    where?: studentWhereInput
    data: XOR<studentUpdateWithoutFinal_gradeInput, studentUncheckedUpdateWithoutFinal_gradeInput>
  }

  export type studentUpdateWithoutFinal_gradeInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    student_fname?: StringFieldUpdateOperationsInput | string
    student_lname?: StringFieldUpdateOperationsInput | string
    student_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    student_account?: StringFieldUpdateOperationsInput | string
    student_pass?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    parent_student_father_idToparent?: parentUpdateOneRequiredWithoutStudent_student_father_idToparentNestedInput
    parent_student_mother_idToparent?: parentUpdateOneRequiredWithoutStudent_student_mother_idToparentNestedInput
    test_result?: test_resultUpdateManyWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateWithoutFinal_gradeInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    mother_id?: IntFieldUpdateOperationsInput | number
    father_id?: IntFieldUpdateOperationsInput | number
    student_fname?: StringFieldUpdateOperationsInput | string
    student_lname?: StringFieldUpdateOperationsInput | string
    student_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    student_account?: StringFieldUpdateOperationsInput | string
    student_pass?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    test_result?: test_resultUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type parentCreateWithoutJobInput = {
    parent_fn: string
    parent_ln: string
    parent_dob: Date | string
    parent_pers_number: string
    parent_pers_email?: string | null
    student_student_father_idToparent?: studentCreateNestedManyWithoutParent_student_father_idToparentInput
    student_student_mother_idToparent?: studentCreateNestedManyWithoutParent_student_mother_idToparentInput
  }

  export type parentUncheckedCreateWithoutJobInput = {
    parent_id?: number
    parent_fn: string
    parent_ln: string
    parent_dob: Date | string
    parent_pers_number: string
    parent_pers_email?: string | null
    student_student_father_idToparent?: studentUncheckedCreateNestedManyWithoutParent_student_father_idToparentInput
    student_student_mother_idToparent?: studentUncheckedCreateNestedManyWithoutParent_student_mother_idToparentInput
  }

  export type parentCreateOrConnectWithoutJobInput = {
    where: parentWhereUniqueInput
    create: XOR<parentCreateWithoutJobInput, parentUncheckedCreateWithoutJobInput>
  }

  export type parentUpsertWithoutJobInput = {
    update: XOR<parentUpdateWithoutJobInput, parentUncheckedUpdateWithoutJobInput>
    create: XOR<parentCreateWithoutJobInput, parentUncheckedCreateWithoutJobInput>
    where?: parentWhereInput
  }

  export type parentUpdateToOneWithWhereWithoutJobInput = {
    where?: parentWhereInput
    data: XOR<parentUpdateWithoutJobInput, parentUncheckedUpdateWithoutJobInput>
  }

  export type parentUpdateWithoutJobInput = {
    parent_fn?: StringFieldUpdateOperationsInput | string
    parent_ln?: StringFieldUpdateOperationsInput | string
    parent_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_pers_number?: StringFieldUpdateOperationsInput | string
    parent_pers_email?: NullableStringFieldUpdateOperationsInput | string | null
    student_student_father_idToparent?: studentUpdateManyWithoutParent_student_father_idToparentNestedInput
    student_student_mother_idToparent?: studentUpdateManyWithoutParent_student_mother_idToparentNestedInput
  }

  export type parentUncheckedUpdateWithoutJobInput = {
    parent_id?: IntFieldUpdateOperationsInput | number
    parent_fn?: StringFieldUpdateOperationsInput | string
    parent_ln?: StringFieldUpdateOperationsInput | string
    parent_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_pers_number?: StringFieldUpdateOperationsInput | string
    parent_pers_email?: NullableStringFieldUpdateOperationsInput | string | null
    student_student_father_idToparent?: studentUncheckedUpdateManyWithoutParent_student_father_idToparentNestedInput
    student_student_mother_idToparent?: studentUncheckedUpdateManyWithoutParent_student_mother_idToparentNestedInput
  }

  export type jobCreateWithoutParentInput = {
    job_company: string
    job_title: string
    work_email?: string | null
    work_number?: string | null
  }

  export type jobUncheckedCreateWithoutParentInput = {
    job_id?: number
    job_company: string
    job_title: string
    work_email?: string | null
    work_number?: string | null
  }

  export type jobCreateOrConnectWithoutParentInput = {
    where: jobWhereUniqueInput
    create: XOR<jobCreateWithoutParentInput, jobUncheckedCreateWithoutParentInput>
  }

  export type jobCreateManyParentInputEnvelope = {
    data: jobCreateManyParentInput | jobCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type studentCreateWithoutParent_student_father_idToparentInput = {
    student_id: string
    student_fname: string
    student_lname: string
    student_dob: Date | string
    student_account: string
    student_pass: string
    note?: string | null
    final_grade?: final_gradeCreateNestedManyWithoutStudentInput
    parent_student_mother_idToparent: parentCreateNestedOneWithoutStudent_student_mother_idToparentInput
    test_result?: test_resultCreateNestedManyWithoutStudentInput
  }

  export type studentUncheckedCreateWithoutParent_student_father_idToparentInput = {
    student_id: string
    mother_id: number
    student_fname: string
    student_lname: string
    student_dob: Date | string
    student_account: string
    student_pass: string
    note?: string | null
    final_grade?: final_gradeUncheckedCreateNestedManyWithoutStudentInput
    test_result?: test_resultUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentCreateOrConnectWithoutParent_student_father_idToparentInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutParent_student_father_idToparentInput, studentUncheckedCreateWithoutParent_student_father_idToparentInput>
  }

  export type studentCreateManyParent_student_father_idToparentInputEnvelope = {
    data: studentCreateManyParent_student_father_idToparentInput | studentCreateManyParent_student_father_idToparentInput[]
    skipDuplicates?: boolean
  }

  export type studentCreateWithoutParent_student_mother_idToparentInput = {
    student_id: string
    student_fname: string
    student_lname: string
    student_dob: Date | string
    student_account: string
    student_pass: string
    note?: string | null
    final_grade?: final_gradeCreateNestedManyWithoutStudentInput
    parent_student_father_idToparent: parentCreateNestedOneWithoutStudent_student_father_idToparentInput
    test_result?: test_resultCreateNestedManyWithoutStudentInput
  }

  export type studentUncheckedCreateWithoutParent_student_mother_idToparentInput = {
    student_id: string
    father_id: number
    student_fname: string
    student_lname: string
    student_dob: Date | string
    student_account: string
    student_pass: string
    note?: string | null
    final_grade?: final_gradeUncheckedCreateNestedManyWithoutStudentInput
    test_result?: test_resultUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentCreateOrConnectWithoutParent_student_mother_idToparentInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutParent_student_mother_idToparentInput, studentUncheckedCreateWithoutParent_student_mother_idToparentInput>
  }

  export type studentCreateManyParent_student_mother_idToparentInputEnvelope = {
    data: studentCreateManyParent_student_mother_idToparentInput | studentCreateManyParent_student_mother_idToparentInput[]
    skipDuplicates?: boolean
  }

  export type jobUpsertWithWhereUniqueWithoutParentInput = {
    where: jobWhereUniqueInput
    update: XOR<jobUpdateWithoutParentInput, jobUncheckedUpdateWithoutParentInput>
    create: XOR<jobCreateWithoutParentInput, jobUncheckedCreateWithoutParentInput>
  }

  export type jobUpdateWithWhereUniqueWithoutParentInput = {
    where: jobWhereUniqueInput
    data: XOR<jobUpdateWithoutParentInput, jobUncheckedUpdateWithoutParentInput>
  }

  export type jobUpdateManyWithWhereWithoutParentInput = {
    where: jobScalarWhereInput
    data: XOR<jobUpdateManyMutationInput, jobUncheckedUpdateManyWithoutParentInput>
  }

  export type jobScalarWhereInput = {
    AND?: jobScalarWhereInput | jobScalarWhereInput[]
    OR?: jobScalarWhereInput[]
    NOT?: jobScalarWhereInput | jobScalarWhereInput[]
    job_id?: IntFilter<"job"> | number
    parent_id?: IntFilter<"job"> | number
    job_company?: StringFilter<"job"> | string
    job_title?: StringFilter<"job"> | string
    work_email?: StringNullableFilter<"job"> | string | null
    work_number?: StringNullableFilter<"job"> | string | null
  }

  export type studentUpsertWithWhereUniqueWithoutParent_student_father_idToparentInput = {
    where: studentWhereUniqueInput
    update: XOR<studentUpdateWithoutParent_student_father_idToparentInput, studentUncheckedUpdateWithoutParent_student_father_idToparentInput>
    create: XOR<studentCreateWithoutParent_student_father_idToparentInput, studentUncheckedCreateWithoutParent_student_father_idToparentInput>
  }

  export type studentUpdateWithWhereUniqueWithoutParent_student_father_idToparentInput = {
    where: studentWhereUniqueInput
    data: XOR<studentUpdateWithoutParent_student_father_idToparentInput, studentUncheckedUpdateWithoutParent_student_father_idToparentInput>
  }

  export type studentUpdateManyWithWhereWithoutParent_student_father_idToparentInput = {
    where: studentScalarWhereInput
    data: XOR<studentUpdateManyMutationInput, studentUncheckedUpdateManyWithoutParent_student_father_idToparentInput>
  }

  export type studentScalarWhereInput = {
    AND?: studentScalarWhereInput | studentScalarWhereInput[]
    OR?: studentScalarWhereInput[]
    NOT?: studentScalarWhereInput | studentScalarWhereInput[]
    student_id?: StringFilter<"student"> | string
    mother_id?: IntFilter<"student"> | number
    father_id?: IntFilter<"student"> | number
    student_fname?: StringFilter<"student"> | string
    student_lname?: StringFilter<"student"> | string
    student_dob?: DateTimeFilter<"student"> | Date | string
    student_account?: StringFilter<"student"> | string
    student_pass?: StringFilter<"student"> | string
    note?: StringNullableFilter<"student"> | string | null
  }

  export type studentUpsertWithWhereUniqueWithoutParent_student_mother_idToparentInput = {
    where: studentWhereUniqueInput
    update: XOR<studentUpdateWithoutParent_student_mother_idToparentInput, studentUncheckedUpdateWithoutParent_student_mother_idToparentInput>
    create: XOR<studentCreateWithoutParent_student_mother_idToparentInput, studentUncheckedCreateWithoutParent_student_mother_idToparentInput>
  }

  export type studentUpdateWithWhereUniqueWithoutParent_student_mother_idToparentInput = {
    where: studentWhereUniqueInput
    data: XOR<studentUpdateWithoutParent_student_mother_idToparentInput, studentUncheckedUpdateWithoutParent_student_mother_idToparentInput>
  }

  export type studentUpdateManyWithWhereWithoutParent_student_mother_idToparentInput = {
    where: studentScalarWhereInput
    data: XOR<studentUpdateManyMutationInput, studentUncheckedUpdateManyWithoutParent_student_mother_idToparentInput>
  }

  export type active_classCreateWithoutPeriod_active_class_periodToperiodInput = {
    Renamedclass?: classesCreateNestedOneWithoutActive_classInput
    employee?: employeeCreateNestedOneWithoutActive_classInput
  }

  export type active_classUncheckedCreateWithoutPeriod_active_class_periodToperiodInput = {
    active_class_id?: number
    class_code?: string | null
    class_coordinator?: number | null
  }

  export type active_classCreateOrConnectWithoutPeriod_active_class_periodToperiodInput = {
    where: active_classWhereUniqueInput
    create: XOR<active_classCreateWithoutPeriod_active_class_periodToperiodInput, active_classUncheckedCreateWithoutPeriod_active_class_periodToperiodInput>
  }

  export type active_classCreateManyPeriod_active_class_periodToperiodInputEnvelope = {
    data: active_classCreateManyPeriod_active_class_periodToperiodInput | active_classCreateManyPeriod_active_class_periodToperiodInput[]
    skipDuplicates?: boolean
  }

  export type active_classUpsertWithWhereUniqueWithoutPeriod_active_class_periodToperiodInput = {
    where: active_classWhereUniqueInput
    update: XOR<active_classUpdateWithoutPeriod_active_class_periodToperiodInput, active_classUncheckedUpdateWithoutPeriod_active_class_periodToperiodInput>
    create: XOR<active_classCreateWithoutPeriod_active_class_periodToperiodInput, active_classUncheckedCreateWithoutPeriod_active_class_periodToperiodInput>
  }

  export type active_classUpdateWithWhereUniqueWithoutPeriod_active_class_periodToperiodInput = {
    where: active_classWhereUniqueInput
    data: XOR<active_classUpdateWithoutPeriod_active_class_periodToperiodInput, active_classUncheckedUpdateWithoutPeriod_active_class_periodToperiodInput>
  }

  export type active_classUpdateManyWithWhereWithoutPeriod_active_class_periodToperiodInput = {
    where: active_classScalarWhereInput
    data: XOR<active_classUpdateManyMutationInput, active_classUncheckedUpdateManyWithoutPeriod_active_class_periodToperiodInput>
  }

  export type employee_roleCreateWithoutRolesInput = {
    employee: employeeCreateNestedOneWithoutEmployee_roleInput
  }

  export type employee_roleUncheckedCreateWithoutRolesInput = {
    employee_role_id?: number
    employee_id: number
  }

  export type employee_roleCreateOrConnectWithoutRolesInput = {
    where: employee_roleWhereUniqueInput
    create: XOR<employee_roleCreateWithoutRolesInput, employee_roleUncheckedCreateWithoutRolesInput>
  }

  export type employee_roleCreateManyRolesInputEnvelope = {
    data: employee_roleCreateManyRolesInput | employee_roleCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type employee_roleUpsertWithWhereUniqueWithoutRolesInput = {
    where: employee_roleWhereUniqueInput
    update: XOR<employee_roleUpdateWithoutRolesInput, employee_roleUncheckedUpdateWithoutRolesInput>
    create: XOR<employee_roleCreateWithoutRolesInput, employee_roleUncheckedCreateWithoutRolesInput>
  }

  export type employee_roleUpdateWithWhereUniqueWithoutRolesInput = {
    where: employee_roleWhereUniqueInput
    data: XOR<employee_roleUpdateWithoutRolesInput, employee_roleUncheckedUpdateWithoutRolesInput>
  }

  export type employee_roleUpdateManyWithWhereWithoutRolesInput = {
    where: employee_roleScalarWhereInput
    data: XOR<employee_roleUpdateManyMutationInput, employee_roleUncheckedUpdateManyWithoutRolesInput>
  }

  export type school_infoCreateWithoutSchool_emailInput = {
    school_reg: number
    school_name: string
    school_address: string
    school_lat: number
    school_long: number
    school_princ: string
    school_num?: school_numCreateNestedManyWithoutSchool_infoInput
  }

  export type school_infoUncheckedCreateWithoutSchool_emailInput = {
    school_reg: number
    school_name: string
    school_address: string
    school_lat: number
    school_long: number
    school_princ: string
    school_num?: school_numUncheckedCreateNestedManyWithoutSchool_infoInput
  }

  export type school_infoCreateOrConnectWithoutSchool_emailInput = {
    where: school_infoWhereUniqueInput
    create: XOR<school_infoCreateWithoutSchool_emailInput, school_infoUncheckedCreateWithoutSchool_emailInput>
  }

  export type school_infoUpsertWithoutSchool_emailInput = {
    update: XOR<school_infoUpdateWithoutSchool_emailInput, school_infoUncheckedUpdateWithoutSchool_emailInput>
    create: XOR<school_infoCreateWithoutSchool_emailInput, school_infoUncheckedCreateWithoutSchool_emailInput>
    where?: school_infoWhereInput
  }

  export type school_infoUpdateToOneWithWhereWithoutSchool_emailInput = {
    where?: school_infoWhereInput
    data: XOR<school_infoUpdateWithoutSchool_emailInput, school_infoUncheckedUpdateWithoutSchool_emailInput>
  }

  export type school_infoUpdateWithoutSchool_emailInput = {
    school_reg?: IntFieldUpdateOperationsInput | number
    school_name?: StringFieldUpdateOperationsInput | string
    school_address?: StringFieldUpdateOperationsInput | string
    school_lat?: FloatFieldUpdateOperationsInput | number
    school_long?: FloatFieldUpdateOperationsInput | number
    school_princ?: StringFieldUpdateOperationsInput | string
    school_num?: school_numUpdateManyWithoutSchool_infoNestedInput
  }

  export type school_infoUncheckedUpdateWithoutSchool_emailInput = {
    school_reg?: IntFieldUpdateOperationsInput | number
    school_name?: StringFieldUpdateOperationsInput | string
    school_address?: StringFieldUpdateOperationsInput | string
    school_lat?: FloatFieldUpdateOperationsInput | number
    school_long?: FloatFieldUpdateOperationsInput | number
    school_princ?: StringFieldUpdateOperationsInput | string
    school_num?: school_numUncheckedUpdateManyWithoutSchool_infoNestedInput
  }

  export type school_emailCreateWithoutSchool_infoInput = {
    school_email: string
    school_email_label: string
  }

  export type school_emailUncheckedCreateWithoutSchool_infoInput = {
    school_num_id?: number
    school_email: string
    school_email_label: string
  }

  export type school_emailCreateOrConnectWithoutSchool_infoInput = {
    where: school_emailWhereUniqueInput
    create: XOR<school_emailCreateWithoutSchool_infoInput, school_emailUncheckedCreateWithoutSchool_infoInput>
  }

  export type school_emailCreateManySchool_infoInputEnvelope = {
    data: school_emailCreateManySchool_infoInput | school_emailCreateManySchool_infoInput[]
    skipDuplicates?: boolean
  }

  export type school_numCreateWithoutSchool_infoInput = {
    school_phone: string
    school_phone_label: string
  }

  export type school_numUncheckedCreateWithoutSchool_infoInput = {
    school_num_id?: number
    school_phone: string
    school_phone_label: string
  }

  export type school_numCreateOrConnectWithoutSchool_infoInput = {
    where: school_numWhereUniqueInput
    create: XOR<school_numCreateWithoutSchool_infoInput, school_numUncheckedCreateWithoutSchool_infoInput>
  }

  export type school_numCreateManySchool_infoInputEnvelope = {
    data: school_numCreateManySchool_infoInput | school_numCreateManySchool_infoInput[]
    skipDuplicates?: boolean
  }

  export type school_emailUpsertWithWhereUniqueWithoutSchool_infoInput = {
    where: school_emailWhereUniqueInput
    update: XOR<school_emailUpdateWithoutSchool_infoInput, school_emailUncheckedUpdateWithoutSchool_infoInput>
    create: XOR<school_emailCreateWithoutSchool_infoInput, school_emailUncheckedCreateWithoutSchool_infoInput>
  }

  export type school_emailUpdateWithWhereUniqueWithoutSchool_infoInput = {
    where: school_emailWhereUniqueInput
    data: XOR<school_emailUpdateWithoutSchool_infoInput, school_emailUncheckedUpdateWithoutSchool_infoInput>
  }

  export type school_emailUpdateManyWithWhereWithoutSchool_infoInput = {
    where: school_emailScalarWhereInput
    data: XOR<school_emailUpdateManyMutationInput, school_emailUncheckedUpdateManyWithoutSchool_infoInput>
  }

  export type school_emailScalarWhereInput = {
    AND?: school_emailScalarWhereInput | school_emailScalarWhereInput[]
    OR?: school_emailScalarWhereInput[]
    NOT?: school_emailScalarWhereInput | school_emailScalarWhereInput[]
    school_num_id?: IntFilter<"school_email"> | number
    school_reg?: IntFilter<"school_email"> | number
    school_email?: StringFilter<"school_email"> | string
    school_email_label?: StringFilter<"school_email"> | string
  }

  export type school_numUpsertWithWhereUniqueWithoutSchool_infoInput = {
    where: school_numWhereUniqueInput
    update: XOR<school_numUpdateWithoutSchool_infoInput, school_numUncheckedUpdateWithoutSchool_infoInput>
    create: XOR<school_numCreateWithoutSchool_infoInput, school_numUncheckedCreateWithoutSchool_infoInput>
  }

  export type school_numUpdateWithWhereUniqueWithoutSchool_infoInput = {
    where: school_numWhereUniqueInput
    data: XOR<school_numUpdateWithoutSchool_infoInput, school_numUncheckedUpdateWithoutSchool_infoInput>
  }

  export type school_numUpdateManyWithWhereWithoutSchool_infoInput = {
    where: school_numScalarWhereInput
    data: XOR<school_numUpdateManyMutationInput, school_numUncheckedUpdateManyWithoutSchool_infoInput>
  }

  export type school_numScalarWhereInput = {
    AND?: school_numScalarWhereInput | school_numScalarWhereInput[]
    OR?: school_numScalarWhereInput[]
    NOT?: school_numScalarWhereInput | school_numScalarWhereInput[]
    school_num_id?: IntFilter<"school_num"> | number
    school_reg?: IntFilter<"school_num"> | number
    school_phone?: StringFilter<"school_num"> | string
    school_phone_label?: StringFilter<"school_num"> | string
  }

  export type school_infoCreateWithoutSchool_numInput = {
    school_reg: number
    school_name: string
    school_address: string
    school_lat: number
    school_long: number
    school_princ: string
    school_email?: school_emailCreateNestedManyWithoutSchool_infoInput
  }

  export type school_infoUncheckedCreateWithoutSchool_numInput = {
    school_reg: number
    school_name: string
    school_address: string
    school_lat: number
    school_long: number
    school_princ: string
    school_email?: school_emailUncheckedCreateNestedManyWithoutSchool_infoInput
  }

  export type school_infoCreateOrConnectWithoutSchool_numInput = {
    where: school_infoWhereUniqueInput
    create: XOR<school_infoCreateWithoutSchool_numInput, school_infoUncheckedCreateWithoutSchool_numInput>
  }

  export type school_infoUpsertWithoutSchool_numInput = {
    update: XOR<school_infoUpdateWithoutSchool_numInput, school_infoUncheckedUpdateWithoutSchool_numInput>
    create: XOR<school_infoCreateWithoutSchool_numInput, school_infoUncheckedCreateWithoutSchool_numInput>
    where?: school_infoWhereInput
  }

  export type school_infoUpdateToOneWithWhereWithoutSchool_numInput = {
    where?: school_infoWhereInput
    data: XOR<school_infoUpdateWithoutSchool_numInput, school_infoUncheckedUpdateWithoutSchool_numInput>
  }

  export type school_infoUpdateWithoutSchool_numInput = {
    school_reg?: IntFieldUpdateOperationsInput | number
    school_name?: StringFieldUpdateOperationsInput | string
    school_address?: StringFieldUpdateOperationsInput | string
    school_lat?: FloatFieldUpdateOperationsInput | number
    school_long?: FloatFieldUpdateOperationsInput | number
    school_princ?: StringFieldUpdateOperationsInput | string
    school_email?: school_emailUpdateManyWithoutSchool_infoNestedInput
  }

  export type school_infoUncheckedUpdateWithoutSchool_numInput = {
    school_reg?: IntFieldUpdateOperationsInput | number
    school_name?: StringFieldUpdateOperationsInput | string
    school_address?: StringFieldUpdateOperationsInput | string
    school_lat?: FloatFieldUpdateOperationsInput | number
    school_long?: FloatFieldUpdateOperationsInput | number
    school_princ?: StringFieldUpdateOperationsInput | string
    school_email?: school_emailUncheckedUpdateManyWithoutSchool_infoNestedInput
  }

  export type final_gradeCreateWithoutStudentInput = {
    final_grade?: number | null
    test_period?: $Enums.final_grade_test_period | null
    created_at?: Date | string | null
    final_status?: string | null
    subjects?: subjectsCreateNestedOneWithoutFinal_gradeInput
  }

  export type final_gradeUncheckedCreateWithoutStudentInput = {
    final_grade_id?: number
    subject_code?: string | null
    final_grade?: number | null
    test_period?: $Enums.final_grade_test_period | null
    created_at?: Date | string | null
    final_status?: string | null
  }

  export type final_gradeCreateOrConnectWithoutStudentInput = {
    where: final_gradeWhereUniqueInput
    create: XOR<final_gradeCreateWithoutStudentInput, final_gradeUncheckedCreateWithoutStudentInput>
  }

  export type final_gradeCreateManyStudentInputEnvelope = {
    data: final_gradeCreateManyStudentInput | final_gradeCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type parentCreateWithoutStudent_student_father_idToparentInput = {
    parent_fn: string
    parent_ln: string
    parent_dob: Date | string
    parent_pers_number: string
    parent_pers_email?: string | null
    job?: jobCreateNestedManyWithoutParentInput
    student_student_mother_idToparent?: studentCreateNestedManyWithoutParent_student_mother_idToparentInput
  }

  export type parentUncheckedCreateWithoutStudent_student_father_idToparentInput = {
    parent_id?: number
    parent_fn: string
    parent_ln: string
    parent_dob: Date | string
    parent_pers_number: string
    parent_pers_email?: string | null
    job?: jobUncheckedCreateNestedManyWithoutParentInput
    student_student_mother_idToparent?: studentUncheckedCreateNestedManyWithoutParent_student_mother_idToparentInput
  }

  export type parentCreateOrConnectWithoutStudent_student_father_idToparentInput = {
    where: parentWhereUniqueInput
    create: XOR<parentCreateWithoutStudent_student_father_idToparentInput, parentUncheckedCreateWithoutStudent_student_father_idToparentInput>
  }

  export type parentCreateWithoutStudent_student_mother_idToparentInput = {
    parent_fn: string
    parent_ln: string
    parent_dob: Date | string
    parent_pers_number: string
    parent_pers_email?: string | null
    job?: jobCreateNestedManyWithoutParentInput
    student_student_father_idToparent?: studentCreateNestedManyWithoutParent_student_father_idToparentInput
  }

  export type parentUncheckedCreateWithoutStudent_student_mother_idToparentInput = {
    parent_id?: number
    parent_fn: string
    parent_ln: string
    parent_dob: Date | string
    parent_pers_number: string
    parent_pers_email?: string | null
    job?: jobUncheckedCreateNestedManyWithoutParentInput
    student_student_father_idToparent?: studentUncheckedCreateNestedManyWithoutParent_student_father_idToparentInput
  }

  export type parentCreateOrConnectWithoutStudent_student_mother_idToparentInput = {
    where: parentWhereUniqueInput
    create: XOR<parentCreateWithoutStudent_student_mother_idToparentInput, parentUncheckedCreateWithoutStudent_student_mother_idToparentInput>
  }

  export type test_resultCreateWithoutStudentInput = {
    test_result?: number
    test_note?: string | null
    test: testCreateNestedOneWithoutTest_resultInput
  }

  export type test_resultUncheckedCreateWithoutStudentInput = {
    test_result_id?: number
    test_id: number
    test_result?: number
    test_note?: string | null
  }

  export type test_resultCreateOrConnectWithoutStudentInput = {
    where: test_resultWhereUniqueInput
    create: XOR<test_resultCreateWithoutStudentInput, test_resultUncheckedCreateWithoutStudentInput>
  }

  export type test_resultCreateManyStudentInputEnvelope = {
    data: test_resultCreateManyStudentInput | test_resultCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type final_gradeUpsertWithWhereUniqueWithoutStudentInput = {
    where: final_gradeWhereUniqueInput
    update: XOR<final_gradeUpdateWithoutStudentInput, final_gradeUncheckedUpdateWithoutStudentInput>
    create: XOR<final_gradeCreateWithoutStudentInput, final_gradeUncheckedCreateWithoutStudentInput>
  }

  export type final_gradeUpdateWithWhereUniqueWithoutStudentInput = {
    where: final_gradeWhereUniqueInput
    data: XOR<final_gradeUpdateWithoutStudentInput, final_gradeUncheckedUpdateWithoutStudentInput>
  }

  export type final_gradeUpdateManyWithWhereWithoutStudentInput = {
    where: final_gradeScalarWhereInput
    data: XOR<final_gradeUpdateManyMutationInput, final_gradeUncheckedUpdateManyWithoutStudentInput>
  }

  export type final_gradeScalarWhereInput = {
    AND?: final_gradeScalarWhereInput | final_gradeScalarWhereInput[]
    OR?: final_gradeScalarWhereInput[]
    NOT?: final_gradeScalarWhereInput | final_gradeScalarWhereInput[]
    final_grade_id?: IntFilter<"final_grade"> | number
    subject_code?: StringNullableFilter<"final_grade"> | string | null
    final_grade?: FloatNullableFilter<"final_grade"> | number | null
    student_id?: StringNullableFilter<"final_grade"> | string | null
    test_period?: Enumfinal_grade_test_periodNullableFilter<"final_grade"> | $Enums.final_grade_test_period | null
    created_at?: DateTimeNullableFilter<"final_grade"> | Date | string | null
    final_status?: StringNullableFilter<"final_grade"> | string | null
  }

  export type parentUpsertWithoutStudent_student_father_idToparentInput = {
    update: XOR<parentUpdateWithoutStudent_student_father_idToparentInput, parentUncheckedUpdateWithoutStudent_student_father_idToparentInput>
    create: XOR<parentCreateWithoutStudent_student_father_idToparentInput, parentUncheckedCreateWithoutStudent_student_father_idToparentInput>
    where?: parentWhereInput
  }

  export type parentUpdateToOneWithWhereWithoutStudent_student_father_idToparentInput = {
    where?: parentWhereInput
    data: XOR<parentUpdateWithoutStudent_student_father_idToparentInput, parentUncheckedUpdateWithoutStudent_student_father_idToparentInput>
  }

  export type parentUpdateWithoutStudent_student_father_idToparentInput = {
    parent_fn?: StringFieldUpdateOperationsInput | string
    parent_ln?: StringFieldUpdateOperationsInput | string
    parent_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_pers_number?: StringFieldUpdateOperationsInput | string
    parent_pers_email?: NullableStringFieldUpdateOperationsInput | string | null
    job?: jobUpdateManyWithoutParentNestedInput
    student_student_mother_idToparent?: studentUpdateManyWithoutParent_student_mother_idToparentNestedInput
  }

  export type parentUncheckedUpdateWithoutStudent_student_father_idToparentInput = {
    parent_id?: IntFieldUpdateOperationsInput | number
    parent_fn?: StringFieldUpdateOperationsInput | string
    parent_ln?: StringFieldUpdateOperationsInput | string
    parent_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_pers_number?: StringFieldUpdateOperationsInput | string
    parent_pers_email?: NullableStringFieldUpdateOperationsInput | string | null
    job?: jobUncheckedUpdateManyWithoutParentNestedInput
    student_student_mother_idToparent?: studentUncheckedUpdateManyWithoutParent_student_mother_idToparentNestedInput
  }

  export type parentUpsertWithoutStudent_student_mother_idToparentInput = {
    update: XOR<parentUpdateWithoutStudent_student_mother_idToparentInput, parentUncheckedUpdateWithoutStudent_student_mother_idToparentInput>
    create: XOR<parentCreateWithoutStudent_student_mother_idToparentInput, parentUncheckedCreateWithoutStudent_student_mother_idToparentInput>
    where?: parentWhereInput
  }

  export type parentUpdateToOneWithWhereWithoutStudent_student_mother_idToparentInput = {
    where?: parentWhereInput
    data: XOR<parentUpdateWithoutStudent_student_mother_idToparentInput, parentUncheckedUpdateWithoutStudent_student_mother_idToparentInput>
  }

  export type parentUpdateWithoutStudent_student_mother_idToparentInput = {
    parent_fn?: StringFieldUpdateOperationsInput | string
    parent_ln?: StringFieldUpdateOperationsInput | string
    parent_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_pers_number?: StringFieldUpdateOperationsInput | string
    parent_pers_email?: NullableStringFieldUpdateOperationsInput | string | null
    job?: jobUpdateManyWithoutParentNestedInput
    student_student_father_idToparent?: studentUpdateManyWithoutParent_student_father_idToparentNestedInput
  }

  export type parentUncheckedUpdateWithoutStudent_student_mother_idToparentInput = {
    parent_id?: IntFieldUpdateOperationsInput | number
    parent_fn?: StringFieldUpdateOperationsInput | string
    parent_ln?: StringFieldUpdateOperationsInput | string
    parent_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_pers_number?: StringFieldUpdateOperationsInput | string
    parent_pers_email?: NullableStringFieldUpdateOperationsInput | string | null
    job?: jobUncheckedUpdateManyWithoutParentNestedInput
    student_student_father_idToparent?: studentUncheckedUpdateManyWithoutParent_student_father_idToparentNestedInput
  }

  export type test_resultUpsertWithWhereUniqueWithoutStudentInput = {
    where: test_resultWhereUniqueInput
    update: XOR<test_resultUpdateWithoutStudentInput, test_resultUncheckedUpdateWithoutStudentInput>
    create: XOR<test_resultCreateWithoutStudentInput, test_resultUncheckedCreateWithoutStudentInput>
  }

  export type test_resultUpdateWithWhereUniqueWithoutStudentInput = {
    where: test_resultWhereUniqueInput
    data: XOR<test_resultUpdateWithoutStudentInput, test_resultUncheckedUpdateWithoutStudentInput>
  }

  export type test_resultUpdateManyWithWhereWithoutStudentInput = {
    where: test_resultScalarWhereInput
    data: XOR<test_resultUpdateManyMutationInput, test_resultUncheckedUpdateManyWithoutStudentInput>
  }

  export type test_resultScalarWhereInput = {
    AND?: test_resultScalarWhereInput | test_resultScalarWhereInput[]
    OR?: test_resultScalarWhereInput[]
    NOT?: test_resultScalarWhereInput | test_resultScalarWhereInput[]
    test_result_id?: IntFilter<"test_result"> | number
    test_id?: IntFilter<"test_result"> | number
    student_id?: StringNullableFilter<"test_result"> | string | null
    test_result?: FloatFilter<"test_result"> | number
    test_note?: StringNullableFilter<"test_result"> | string | null
  }

  export type agendaCreateWithoutSubject_classInput = {
    agenda_title: string
    agenda_context: string
    agenda_annouced?: Date | string | null
    agenda_due?: Date | string | null
  }

  export type agendaUncheckedCreateWithoutSubject_classInput = {
    agenda_id?: number
    agenda_title: string
    agenda_context: string
    agenda_annouced?: Date | string | null
    agenda_due?: Date | string | null
  }

  export type agendaCreateOrConnectWithoutSubject_classInput = {
    where: agendaWhereUniqueInput
    create: XOR<agendaCreateWithoutSubject_classInput, agendaUncheckedCreateWithoutSubject_classInput>
  }

  export type agendaCreateManySubject_classInputEnvelope = {
    data: agendaCreateManySubject_classInput | agendaCreateManySubject_classInput[]
    skipDuplicates?: boolean
  }

  export type employeeCreateWithoutSubject_classInput = {
    employee_fn: string
    employee_ln: string
    employee_dob: Date | string
    employee_join?: Date | string | null
    employee_img?: string | null
    employee_info?: string | null
    employee_degree?: string | null
    employee_exp?: Date | string | null
    employee_sal1?: number
    employee_sal2?: number | null
    employee_wh?: number | null
    active_class?: active_classCreateNestedManyWithoutEmployeeInput
    employee_role?: employee_roleCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutSubject_classInput = {
    employee_id?: number
    employee_fn: string
    employee_ln: string
    employee_dob: Date | string
    employee_join?: Date | string | null
    employee_img?: string | null
    employee_info?: string | null
    employee_degree?: string | null
    employee_exp?: Date | string | null
    employee_sal1?: number
    employee_sal2?: number | null
    employee_wh?: number | null
    active_class?: active_classUncheckedCreateNestedManyWithoutEmployeeInput
    employee_role?: employee_roleUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutSubject_classInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutSubject_classInput, employeeUncheckedCreateWithoutSubject_classInput>
  }

  export type subjectsCreateWithoutSubject_classInput = {
    subject_code: string
    subject_name: string
    subject_cat?: $Enums.subjects_subject_cat | null
    final_grade?: final_gradeCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsUncheckedCreateWithoutSubject_classInput = {
    subject_code: string
    subject_name: string
    subject_cat?: $Enums.subjects_subject_cat | null
    final_grade?: final_gradeUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectsCreateOrConnectWithoutSubject_classInput = {
    where: subjectsWhereUniqueInput
    create: XOR<subjectsCreateWithoutSubject_classInput, subjectsUncheckedCreateWithoutSubject_classInput>
  }

  export type testCreateWithoutSubject_classInput = {
    test_title?: string | null
    test_description?: string | null
    test_total?: number | null
    test_visibility?: string | null
    test_annouced?: Date | string | null
    test_due?: Date | string | null
    test_period?: $Enums.test_test_period | null
    test_result?: test_resultCreateNestedManyWithoutTestInput
  }

  export type testUncheckedCreateWithoutSubject_classInput = {
    test_id?: number
    test_title?: string | null
    test_description?: string | null
    test_total?: number | null
    test_visibility?: string | null
    test_annouced?: Date | string | null
    test_due?: Date | string | null
    test_period?: $Enums.test_test_period | null
    test_result?: test_resultUncheckedCreateNestedManyWithoutTestInput
  }

  export type testCreateOrConnectWithoutSubject_classInput = {
    where: testWhereUniqueInput
    create: XOR<testCreateWithoutSubject_classInput, testUncheckedCreateWithoutSubject_classInput>
  }

  export type testCreateManySubject_classInputEnvelope = {
    data: testCreateManySubject_classInput | testCreateManySubject_classInput[]
    skipDuplicates?: boolean
  }

  export type agendaUpsertWithWhereUniqueWithoutSubject_classInput = {
    where: agendaWhereUniqueInput
    update: XOR<agendaUpdateWithoutSubject_classInput, agendaUncheckedUpdateWithoutSubject_classInput>
    create: XOR<agendaCreateWithoutSubject_classInput, agendaUncheckedCreateWithoutSubject_classInput>
  }

  export type agendaUpdateWithWhereUniqueWithoutSubject_classInput = {
    where: agendaWhereUniqueInput
    data: XOR<agendaUpdateWithoutSubject_classInput, agendaUncheckedUpdateWithoutSubject_classInput>
  }

  export type agendaUpdateManyWithWhereWithoutSubject_classInput = {
    where: agendaScalarWhereInput
    data: XOR<agendaUpdateManyMutationInput, agendaUncheckedUpdateManyWithoutSubject_classInput>
  }

  export type agendaScalarWhereInput = {
    AND?: agendaScalarWhereInput | agendaScalarWhereInput[]
    OR?: agendaScalarWhereInput[]
    NOT?: agendaScalarWhereInput | agendaScalarWhereInput[]
    agenda_id?: IntFilter<"agenda"> | number
    subject_class_id?: IntNullableFilter<"agenda"> | number | null
    agenda_title?: StringFilter<"agenda"> | string
    agenda_context?: StringFilter<"agenda"> | string
    agenda_annouced?: DateTimeNullableFilter<"agenda"> | Date | string | null
    agenda_due?: DateTimeNullableFilter<"agenda"> | Date | string | null
  }

  export type employeeUpsertWithoutSubject_classInput = {
    update: XOR<employeeUpdateWithoutSubject_classInput, employeeUncheckedUpdateWithoutSubject_classInput>
    create: XOR<employeeCreateWithoutSubject_classInput, employeeUncheckedCreateWithoutSubject_classInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutSubject_classInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutSubject_classInput, employeeUncheckedUpdateWithoutSubject_classInput>
  }

  export type employeeUpdateWithoutSubject_classInput = {
    employee_fn?: StringFieldUpdateOperationsInput | string
    employee_ln?: StringFieldUpdateOperationsInput | string
    employee_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    employee_join?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_img?: NullableStringFieldUpdateOperationsInput | string | null
    employee_info?: NullableStringFieldUpdateOperationsInput | string | null
    employee_degree?: NullableStringFieldUpdateOperationsInput | string | null
    employee_exp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_sal1?: FloatFieldUpdateOperationsInput | number
    employee_sal2?: NullableFloatFieldUpdateOperationsInput | number | null
    employee_wh?: NullableFloatFieldUpdateOperationsInput | number | null
    active_class?: active_classUpdateManyWithoutEmployeeNestedInput
    employee_role?: employee_roleUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutSubject_classInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    employee_fn?: StringFieldUpdateOperationsInput | string
    employee_ln?: StringFieldUpdateOperationsInput | string
    employee_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    employee_join?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_img?: NullableStringFieldUpdateOperationsInput | string | null
    employee_info?: NullableStringFieldUpdateOperationsInput | string | null
    employee_degree?: NullableStringFieldUpdateOperationsInput | string | null
    employee_exp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee_sal1?: FloatFieldUpdateOperationsInput | number
    employee_sal2?: NullableFloatFieldUpdateOperationsInput | number | null
    employee_wh?: NullableFloatFieldUpdateOperationsInput | number | null
    active_class?: active_classUncheckedUpdateManyWithoutEmployeeNestedInput
    employee_role?: employee_roleUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type subjectsUpsertWithoutSubject_classInput = {
    update: XOR<subjectsUpdateWithoutSubject_classInput, subjectsUncheckedUpdateWithoutSubject_classInput>
    create: XOR<subjectsCreateWithoutSubject_classInput, subjectsUncheckedCreateWithoutSubject_classInput>
    where?: subjectsWhereInput
  }

  export type subjectsUpdateToOneWithWhereWithoutSubject_classInput = {
    where?: subjectsWhereInput
    data: XOR<subjectsUpdateWithoutSubject_classInput, subjectsUncheckedUpdateWithoutSubject_classInput>
  }

  export type subjectsUpdateWithoutSubject_classInput = {
    subject_code?: StringFieldUpdateOperationsInput | string
    subject_name?: StringFieldUpdateOperationsInput | string
    subject_cat?: NullableEnumsubjects_subject_catFieldUpdateOperationsInput | $Enums.subjects_subject_cat | null
    final_grade?: final_gradeUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectsUncheckedUpdateWithoutSubject_classInput = {
    subject_code?: StringFieldUpdateOperationsInput | string
    subject_name?: StringFieldUpdateOperationsInput | string
    subject_cat?: NullableEnumsubjects_subject_catFieldUpdateOperationsInput | $Enums.subjects_subject_cat | null
    final_grade?: final_gradeUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type testUpsertWithWhereUniqueWithoutSubject_classInput = {
    where: testWhereUniqueInput
    update: XOR<testUpdateWithoutSubject_classInput, testUncheckedUpdateWithoutSubject_classInput>
    create: XOR<testCreateWithoutSubject_classInput, testUncheckedCreateWithoutSubject_classInput>
  }

  export type testUpdateWithWhereUniqueWithoutSubject_classInput = {
    where: testWhereUniqueInput
    data: XOR<testUpdateWithoutSubject_classInput, testUncheckedUpdateWithoutSubject_classInput>
  }

  export type testUpdateManyWithWhereWithoutSubject_classInput = {
    where: testScalarWhereInput
    data: XOR<testUpdateManyMutationInput, testUncheckedUpdateManyWithoutSubject_classInput>
  }

  export type testScalarWhereInput = {
    AND?: testScalarWhereInput | testScalarWhereInput[]
    OR?: testScalarWhereInput[]
    NOT?: testScalarWhereInput | testScalarWhereInput[]
    test_id?: IntFilter<"test"> | number
    test_title?: StringNullableFilter<"test"> | string | null
    test_description?: StringNullableFilter<"test"> | string | null
    subject_class_id?: IntNullableFilter<"test"> | number | null
    test_total?: IntNullableFilter<"test"> | number | null
    test_visibility?: StringNullableFilter<"test"> | string | null
    test_annouced?: DateTimeNullableFilter<"test"> | Date | string | null
    test_due?: DateTimeNullableFilter<"test"> | Date | string | null
    test_period?: Enumtest_test_periodNullableFilter<"test"> | $Enums.test_test_period | null
  }

  export type final_gradeCreateWithoutSubjectsInput = {
    final_grade?: number | null
    test_period?: $Enums.final_grade_test_period | null
    created_at?: Date | string | null
    final_status?: string | null
    student?: studentCreateNestedOneWithoutFinal_gradeInput
  }

  export type final_gradeUncheckedCreateWithoutSubjectsInput = {
    final_grade_id?: number
    final_grade?: number | null
    student_id?: string | null
    test_period?: $Enums.final_grade_test_period | null
    created_at?: Date | string | null
    final_status?: string | null
  }

  export type final_gradeCreateOrConnectWithoutSubjectsInput = {
    where: final_gradeWhereUniqueInput
    create: XOR<final_gradeCreateWithoutSubjectsInput, final_gradeUncheckedCreateWithoutSubjectsInput>
  }

  export type final_gradeCreateManySubjectsInputEnvelope = {
    data: final_gradeCreateManySubjectsInput | final_gradeCreateManySubjectsInput[]
    skipDuplicates?: boolean
  }

  export type subject_classCreateWithoutSubjectsInput = {
    agenda?: agendaCreateNestedManyWithoutSubject_classInput
    employee?: employeeCreateNestedOneWithoutSubject_classInput
    test?: testCreateNestedManyWithoutSubject_classInput
  }

  export type subject_classUncheckedCreateWithoutSubjectsInput = {
    subject_class_id?: number
    instructor?: number | null
    agenda?: agendaUncheckedCreateNestedManyWithoutSubject_classInput
    test?: testUncheckedCreateNestedManyWithoutSubject_classInput
  }

  export type subject_classCreateOrConnectWithoutSubjectsInput = {
    where: subject_classWhereUniqueInput
    create: XOR<subject_classCreateWithoutSubjectsInput, subject_classUncheckedCreateWithoutSubjectsInput>
  }

  export type subject_classCreateManySubjectsInputEnvelope = {
    data: subject_classCreateManySubjectsInput | subject_classCreateManySubjectsInput[]
    skipDuplicates?: boolean
  }

  export type final_gradeUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: final_gradeWhereUniqueInput
    update: XOR<final_gradeUpdateWithoutSubjectsInput, final_gradeUncheckedUpdateWithoutSubjectsInput>
    create: XOR<final_gradeCreateWithoutSubjectsInput, final_gradeUncheckedCreateWithoutSubjectsInput>
  }

  export type final_gradeUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: final_gradeWhereUniqueInput
    data: XOR<final_gradeUpdateWithoutSubjectsInput, final_gradeUncheckedUpdateWithoutSubjectsInput>
  }

  export type final_gradeUpdateManyWithWhereWithoutSubjectsInput = {
    where: final_gradeScalarWhereInput
    data: XOR<final_gradeUpdateManyMutationInput, final_gradeUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type subject_classUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: subject_classWhereUniqueInput
    update: XOR<subject_classUpdateWithoutSubjectsInput, subject_classUncheckedUpdateWithoutSubjectsInput>
    create: XOR<subject_classCreateWithoutSubjectsInput, subject_classUncheckedCreateWithoutSubjectsInput>
  }

  export type subject_classUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: subject_classWhereUniqueInput
    data: XOR<subject_classUpdateWithoutSubjectsInput, subject_classUncheckedUpdateWithoutSubjectsInput>
  }

  export type subject_classUpdateManyWithWhereWithoutSubjectsInput = {
    where: subject_classScalarWhereInput
    data: XOR<subject_classUpdateManyMutationInput, subject_classUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type subject_classCreateWithoutTestInput = {
    agenda?: agendaCreateNestedManyWithoutSubject_classInput
    employee?: employeeCreateNestedOneWithoutSubject_classInput
    subjects: subjectsCreateNestedOneWithoutSubject_classInput
  }

  export type subject_classUncheckedCreateWithoutTestInput = {
    subject_class_id?: number
    subject_code: string
    instructor?: number | null
    agenda?: agendaUncheckedCreateNestedManyWithoutSubject_classInput
  }

  export type subject_classCreateOrConnectWithoutTestInput = {
    where: subject_classWhereUniqueInput
    create: XOR<subject_classCreateWithoutTestInput, subject_classUncheckedCreateWithoutTestInput>
  }

  export type test_resultCreateWithoutTestInput = {
    test_result?: number
    test_note?: string | null
    student?: studentCreateNestedOneWithoutTest_resultInput
  }

  export type test_resultUncheckedCreateWithoutTestInput = {
    test_result_id?: number
    student_id?: string | null
    test_result?: number
    test_note?: string | null
  }

  export type test_resultCreateOrConnectWithoutTestInput = {
    where: test_resultWhereUniqueInput
    create: XOR<test_resultCreateWithoutTestInput, test_resultUncheckedCreateWithoutTestInput>
  }

  export type test_resultCreateManyTestInputEnvelope = {
    data: test_resultCreateManyTestInput | test_resultCreateManyTestInput[]
    skipDuplicates?: boolean
  }

  export type subject_classUpsertWithoutTestInput = {
    update: XOR<subject_classUpdateWithoutTestInput, subject_classUncheckedUpdateWithoutTestInput>
    create: XOR<subject_classCreateWithoutTestInput, subject_classUncheckedCreateWithoutTestInput>
    where?: subject_classWhereInput
  }

  export type subject_classUpdateToOneWithWhereWithoutTestInput = {
    where?: subject_classWhereInput
    data: XOR<subject_classUpdateWithoutTestInput, subject_classUncheckedUpdateWithoutTestInput>
  }

  export type subject_classUpdateWithoutTestInput = {
    agenda?: agendaUpdateManyWithoutSubject_classNestedInput
    employee?: employeeUpdateOneWithoutSubject_classNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutSubject_classNestedInput
  }

  export type subject_classUncheckedUpdateWithoutTestInput = {
    subject_class_id?: IntFieldUpdateOperationsInput | number
    subject_code?: StringFieldUpdateOperationsInput | string
    instructor?: NullableIntFieldUpdateOperationsInput | number | null
    agenda?: agendaUncheckedUpdateManyWithoutSubject_classNestedInput
  }

  export type test_resultUpsertWithWhereUniqueWithoutTestInput = {
    where: test_resultWhereUniqueInput
    update: XOR<test_resultUpdateWithoutTestInput, test_resultUncheckedUpdateWithoutTestInput>
    create: XOR<test_resultCreateWithoutTestInput, test_resultUncheckedCreateWithoutTestInput>
  }

  export type test_resultUpdateWithWhereUniqueWithoutTestInput = {
    where: test_resultWhereUniqueInput
    data: XOR<test_resultUpdateWithoutTestInput, test_resultUncheckedUpdateWithoutTestInput>
  }

  export type test_resultUpdateManyWithWhereWithoutTestInput = {
    where: test_resultScalarWhereInput
    data: XOR<test_resultUpdateManyMutationInput, test_resultUncheckedUpdateManyWithoutTestInput>
  }

  export type testCreateWithoutTest_resultInput = {
    test_title?: string | null
    test_description?: string | null
    test_total?: number | null
    test_visibility?: string | null
    test_annouced?: Date | string | null
    test_due?: Date | string | null
    test_period?: $Enums.test_test_period | null
    subject_class?: subject_classCreateNestedOneWithoutTestInput
  }

  export type testUncheckedCreateWithoutTest_resultInput = {
    test_id?: number
    test_title?: string | null
    test_description?: string | null
    subject_class_id?: number | null
    test_total?: number | null
    test_visibility?: string | null
    test_annouced?: Date | string | null
    test_due?: Date | string | null
    test_period?: $Enums.test_test_period | null
  }

  export type testCreateOrConnectWithoutTest_resultInput = {
    where: testWhereUniqueInput
    create: XOR<testCreateWithoutTest_resultInput, testUncheckedCreateWithoutTest_resultInput>
  }

  export type studentCreateWithoutTest_resultInput = {
    student_id: string
    student_fname: string
    student_lname: string
    student_dob: Date | string
    student_account: string
    student_pass: string
    note?: string | null
    final_grade?: final_gradeCreateNestedManyWithoutStudentInput
    parent_student_father_idToparent: parentCreateNestedOneWithoutStudent_student_father_idToparentInput
    parent_student_mother_idToparent: parentCreateNestedOneWithoutStudent_student_mother_idToparentInput
  }

  export type studentUncheckedCreateWithoutTest_resultInput = {
    student_id: string
    mother_id: number
    father_id: number
    student_fname: string
    student_lname: string
    student_dob: Date | string
    student_account: string
    student_pass: string
    note?: string | null
    final_grade?: final_gradeUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentCreateOrConnectWithoutTest_resultInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutTest_resultInput, studentUncheckedCreateWithoutTest_resultInput>
  }

  export type testUpsertWithoutTest_resultInput = {
    update: XOR<testUpdateWithoutTest_resultInput, testUncheckedUpdateWithoutTest_resultInput>
    create: XOR<testCreateWithoutTest_resultInput, testUncheckedCreateWithoutTest_resultInput>
    where?: testWhereInput
  }

  export type testUpdateToOneWithWhereWithoutTest_resultInput = {
    where?: testWhereInput
    data: XOR<testUpdateWithoutTest_resultInput, testUncheckedUpdateWithoutTest_resultInput>
  }

  export type testUpdateWithoutTest_resultInput = {
    test_title?: NullableStringFieldUpdateOperationsInput | string | null
    test_description?: NullableStringFieldUpdateOperationsInput | string | null
    test_total?: NullableIntFieldUpdateOperationsInput | number | null
    test_visibility?: NullableStringFieldUpdateOperationsInput | string | null
    test_annouced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_due?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_period?: NullableEnumtest_test_periodFieldUpdateOperationsInput | $Enums.test_test_period | null
    subject_class?: subject_classUpdateOneWithoutTestNestedInput
  }

  export type testUncheckedUpdateWithoutTest_resultInput = {
    test_id?: IntFieldUpdateOperationsInput | number
    test_title?: NullableStringFieldUpdateOperationsInput | string | null
    test_description?: NullableStringFieldUpdateOperationsInput | string | null
    subject_class_id?: NullableIntFieldUpdateOperationsInput | number | null
    test_total?: NullableIntFieldUpdateOperationsInput | number | null
    test_visibility?: NullableStringFieldUpdateOperationsInput | string | null
    test_annouced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_due?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_period?: NullableEnumtest_test_periodFieldUpdateOperationsInput | $Enums.test_test_period | null
  }

  export type studentUpsertWithoutTest_resultInput = {
    update: XOR<studentUpdateWithoutTest_resultInput, studentUncheckedUpdateWithoutTest_resultInput>
    create: XOR<studentCreateWithoutTest_resultInput, studentUncheckedCreateWithoutTest_resultInput>
    where?: studentWhereInput
  }

  export type studentUpdateToOneWithWhereWithoutTest_resultInput = {
    where?: studentWhereInput
    data: XOR<studentUpdateWithoutTest_resultInput, studentUncheckedUpdateWithoutTest_resultInput>
  }

  export type studentUpdateWithoutTest_resultInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    student_fname?: StringFieldUpdateOperationsInput | string
    student_lname?: StringFieldUpdateOperationsInput | string
    student_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    student_account?: StringFieldUpdateOperationsInput | string
    student_pass?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    final_grade?: final_gradeUpdateManyWithoutStudentNestedInput
    parent_student_father_idToparent?: parentUpdateOneRequiredWithoutStudent_student_father_idToparentNestedInput
    parent_student_mother_idToparent?: parentUpdateOneRequiredWithoutStudent_student_mother_idToparentNestedInput
  }

  export type studentUncheckedUpdateWithoutTest_resultInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    mother_id?: IntFieldUpdateOperationsInput | number
    father_id?: IntFieldUpdateOperationsInput | number
    student_fname?: StringFieldUpdateOperationsInput | string
    student_lname?: StringFieldUpdateOperationsInput | string
    student_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    student_account?: StringFieldUpdateOperationsInput | string
    student_pass?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    final_grade?: final_gradeUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type active_classCreateWithoutRenamedclassInput = {
    period_active_class_periodToperiod?: periodCreateNestedOneWithoutActive_class_active_class_periodToperiodInput
    employee?: employeeCreateNestedOneWithoutActive_classInput
  }

  export type active_classUncheckedCreateWithoutRenamedclassInput = {
    active_class_id?: number
    period?: number | null
    class_coordinator?: number | null
  }

  export type active_classCreateOrConnectWithoutRenamedclassInput = {
    where: active_classWhereUniqueInput
    create: XOR<active_classCreateWithoutRenamedclassInput, active_classUncheckedCreateWithoutRenamedclassInput>
  }

  export type active_classCreateManyRenamedclassInputEnvelope = {
    data: active_classCreateManyRenamedclassInput | active_classCreateManyRenamedclassInput[]
    skipDuplicates?: boolean
  }

  export type active_classUpsertWithWhereUniqueWithoutRenamedclassInput = {
    where: active_classWhereUniqueInput
    update: XOR<active_classUpdateWithoutRenamedclassInput, active_classUncheckedUpdateWithoutRenamedclassInput>
    create: XOR<active_classCreateWithoutRenamedclassInput, active_classUncheckedCreateWithoutRenamedclassInput>
  }

  export type active_classUpdateWithWhereUniqueWithoutRenamedclassInput = {
    where: active_classWhereUniqueInput
    data: XOR<active_classUpdateWithoutRenamedclassInput, active_classUncheckedUpdateWithoutRenamedclassInput>
  }

  export type active_classUpdateManyWithWhereWithoutRenamedclassInput = {
    where: active_classScalarWhereInput
    data: XOR<active_classUpdateManyMutationInput, active_classUncheckedUpdateManyWithoutRenamedclassInput>
  }

  export type active_classCreateManyEmployeeInput = {
    active_class_id?: number
    class_code?: string | null
    period?: number | null
  }

  export type employee_roleCreateManyEmployeeInput = {
    employee_role_id?: number
    role_id: number
  }

  export type subject_classCreateManyEmployeeInput = {
    subject_class_id?: number
    subject_code: string
  }

  export type active_classUpdateWithoutEmployeeInput = {
    Renamedclass?: classesUpdateOneWithoutActive_classNestedInput
    period_active_class_periodToperiod?: periodUpdateOneWithoutActive_class_active_class_periodToperiodNestedInput
  }

  export type active_classUncheckedUpdateWithoutEmployeeInput = {
    active_class_id?: IntFieldUpdateOperationsInput | number
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type active_classUncheckedUpdateManyWithoutEmployeeInput = {
    active_class_id?: IntFieldUpdateOperationsInput | number
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type employee_roleUpdateWithoutEmployeeInput = {
    roles?: rolesUpdateOneRequiredWithoutEmployee_roleNestedInput
  }

  export type employee_roleUncheckedUpdateWithoutEmployeeInput = {
    employee_role_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type employee_roleUncheckedUpdateManyWithoutEmployeeInput = {
    employee_role_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type subject_classUpdateWithoutEmployeeInput = {
    agenda?: agendaUpdateManyWithoutSubject_classNestedInput
    subjects?: subjectsUpdateOneRequiredWithoutSubject_classNestedInput
    test?: testUpdateManyWithoutSubject_classNestedInput
  }

  export type subject_classUncheckedUpdateWithoutEmployeeInput = {
    subject_class_id?: IntFieldUpdateOperationsInput | number
    subject_code?: StringFieldUpdateOperationsInput | string
    agenda?: agendaUncheckedUpdateManyWithoutSubject_classNestedInput
    test?: testUncheckedUpdateManyWithoutSubject_classNestedInput
  }

  export type subject_classUncheckedUpdateManyWithoutEmployeeInput = {
    subject_class_id?: IntFieldUpdateOperationsInput | number
    subject_code?: StringFieldUpdateOperationsInput | string
  }

  export type jobCreateManyParentInput = {
    job_id?: number
    job_company: string
    job_title: string
    work_email?: string | null
    work_number?: string | null
  }

  export type studentCreateManyParent_student_father_idToparentInput = {
    student_id: string
    mother_id: number
    student_fname: string
    student_lname: string
    student_dob: Date | string
    student_account: string
    student_pass: string
    note?: string | null
  }

  export type studentCreateManyParent_student_mother_idToparentInput = {
    student_id: string
    father_id: number
    student_fname: string
    student_lname: string
    student_dob: Date | string
    student_account: string
    student_pass: string
    note?: string | null
  }

  export type jobUpdateWithoutParentInput = {
    job_company?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    work_email?: NullableStringFieldUpdateOperationsInput | string | null
    work_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type jobUncheckedUpdateWithoutParentInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    job_company?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    work_email?: NullableStringFieldUpdateOperationsInput | string | null
    work_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type jobUncheckedUpdateManyWithoutParentInput = {
    job_id?: IntFieldUpdateOperationsInput | number
    job_company?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    work_email?: NullableStringFieldUpdateOperationsInput | string | null
    work_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type studentUpdateWithoutParent_student_father_idToparentInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    student_fname?: StringFieldUpdateOperationsInput | string
    student_lname?: StringFieldUpdateOperationsInput | string
    student_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    student_account?: StringFieldUpdateOperationsInput | string
    student_pass?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    final_grade?: final_gradeUpdateManyWithoutStudentNestedInput
    parent_student_mother_idToparent?: parentUpdateOneRequiredWithoutStudent_student_mother_idToparentNestedInput
    test_result?: test_resultUpdateManyWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateWithoutParent_student_father_idToparentInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    mother_id?: IntFieldUpdateOperationsInput | number
    student_fname?: StringFieldUpdateOperationsInput | string
    student_lname?: StringFieldUpdateOperationsInput | string
    student_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    student_account?: StringFieldUpdateOperationsInput | string
    student_pass?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    final_grade?: final_gradeUncheckedUpdateManyWithoutStudentNestedInput
    test_result?: test_resultUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateManyWithoutParent_student_father_idToparentInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    mother_id?: IntFieldUpdateOperationsInput | number
    student_fname?: StringFieldUpdateOperationsInput | string
    student_lname?: StringFieldUpdateOperationsInput | string
    student_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    student_account?: StringFieldUpdateOperationsInput | string
    student_pass?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type studentUpdateWithoutParent_student_mother_idToparentInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    student_fname?: StringFieldUpdateOperationsInput | string
    student_lname?: StringFieldUpdateOperationsInput | string
    student_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    student_account?: StringFieldUpdateOperationsInput | string
    student_pass?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    final_grade?: final_gradeUpdateManyWithoutStudentNestedInput
    parent_student_father_idToparent?: parentUpdateOneRequiredWithoutStudent_student_father_idToparentNestedInput
    test_result?: test_resultUpdateManyWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateWithoutParent_student_mother_idToparentInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    father_id?: IntFieldUpdateOperationsInput | number
    student_fname?: StringFieldUpdateOperationsInput | string
    student_lname?: StringFieldUpdateOperationsInput | string
    student_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    student_account?: StringFieldUpdateOperationsInput | string
    student_pass?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    final_grade?: final_gradeUncheckedUpdateManyWithoutStudentNestedInput
    test_result?: test_resultUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateManyWithoutParent_student_mother_idToparentInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    father_id?: IntFieldUpdateOperationsInput | number
    student_fname?: StringFieldUpdateOperationsInput | string
    student_lname?: StringFieldUpdateOperationsInput | string
    student_dob?: DateTimeFieldUpdateOperationsInput | Date | string
    student_account?: StringFieldUpdateOperationsInput | string
    student_pass?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type active_classCreateManyPeriod_active_class_periodToperiodInput = {
    active_class_id?: number
    class_code?: string | null
    class_coordinator?: number | null
  }

  export type active_classUpdateWithoutPeriod_active_class_periodToperiodInput = {
    Renamedclass?: classesUpdateOneWithoutActive_classNestedInput
    employee?: employeeUpdateOneWithoutActive_classNestedInput
  }

  export type active_classUncheckedUpdateWithoutPeriod_active_class_periodToperiodInput = {
    active_class_id?: IntFieldUpdateOperationsInput | number
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    class_coordinator?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type active_classUncheckedUpdateManyWithoutPeriod_active_class_periodToperiodInput = {
    active_class_id?: IntFieldUpdateOperationsInput | number
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    class_coordinator?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type employee_roleCreateManyRolesInput = {
    employee_role_id?: number
    employee_id: number
  }

  export type employee_roleUpdateWithoutRolesInput = {
    employee?: employeeUpdateOneRequiredWithoutEmployee_roleNestedInput
  }

  export type employee_roleUncheckedUpdateWithoutRolesInput = {
    employee_role_id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
  }

  export type employee_roleUncheckedUpdateManyWithoutRolesInput = {
    employee_role_id?: IntFieldUpdateOperationsInput | number
    employee_id?: IntFieldUpdateOperationsInput | number
  }

  export type school_emailCreateManySchool_infoInput = {
    school_num_id?: number
    school_email: string
    school_email_label: string
  }

  export type school_numCreateManySchool_infoInput = {
    school_num_id?: number
    school_phone: string
    school_phone_label: string
  }

  export type school_emailUpdateWithoutSchool_infoInput = {
    school_email?: StringFieldUpdateOperationsInput | string
    school_email_label?: StringFieldUpdateOperationsInput | string
  }

  export type school_emailUncheckedUpdateWithoutSchool_infoInput = {
    school_num_id?: IntFieldUpdateOperationsInput | number
    school_email?: StringFieldUpdateOperationsInput | string
    school_email_label?: StringFieldUpdateOperationsInput | string
  }

  export type school_emailUncheckedUpdateManyWithoutSchool_infoInput = {
    school_num_id?: IntFieldUpdateOperationsInput | number
    school_email?: StringFieldUpdateOperationsInput | string
    school_email_label?: StringFieldUpdateOperationsInput | string
  }

  export type school_numUpdateWithoutSchool_infoInput = {
    school_phone?: StringFieldUpdateOperationsInput | string
    school_phone_label?: StringFieldUpdateOperationsInput | string
  }

  export type school_numUncheckedUpdateWithoutSchool_infoInput = {
    school_num_id?: IntFieldUpdateOperationsInput | number
    school_phone?: StringFieldUpdateOperationsInput | string
    school_phone_label?: StringFieldUpdateOperationsInput | string
  }

  export type school_numUncheckedUpdateManyWithoutSchool_infoInput = {
    school_num_id?: IntFieldUpdateOperationsInput | number
    school_phone?: StringFieldUpdateOperationsInput | string
    school_phone_label?: StringFieldUpdateOperationsInput | string
  }

  export type final_gradeCreateManyStudentInput = {
    final_grade_id?: number
    subject_code?: string | null
    final_grade?: number | null
    test_period?: $Enums.final_grade_test_period | null
    created_at?: Date | string | null
    final_status?: string | null
  }

  export type test_resultCreateManyStudentInput = {
    test_result_id?: number
    test_id: number
    test_result?: number
    test_note?: string | null
  }

  export type final_gradeUpdateWithoutStudentInput = {
    final_grade?: NullableFloatFieldUpdateOperationsInput | number | null
    test_period?: NullableEnumfinal_grade_test_periodFieldUpdateOperationsInput | $Enums.final_grade_test_period | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_status?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: subjectsUpdateOneWithoutFinal_gradeNestedInput
  }

  export type final_gradeUncheckedUpdateWithoutStudentInput = {
    final_grade_id?: IntFieldUpdateOperationsInput | number
    subject_code?: NullableStringFieldUpdateOperationsInput | string | null
    final_grade?: NullableFloatFieldUpdateOperationsInput | number | null
    test_period?: NullableEnumfinal_grade_test_periodFieldUpdateOperationsInput | $Enums.final_grade_test_period | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type final_gradeUncheckedUpdateManyWithoutStudentInput = {
    final_grade_id?: IntFieldUpdateOperationsInput | number
    subject_code?: NullableStringFieldUpdateOperationsInput | string | null
    final_grade?: NullableFloatFieldUpdateOperationsInput | number | null
    test_period?: NullableEnumfinal_grade_test_periodFieldUpdateOperationsInput | $Enums.final_grade_test_period | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type test_resultUpdateWithoutStudentInput = {
    test_result?: FloatFieldUpdateOperationsInput | number
    test_note?: NullableStringFieldUpdateOperationsInput | string | null
    test?: testUpdateOneRequiredWithoutTest_resultNestedInput
  }

  export type test_resultUncheckedUpdateWithoutStudentInput = {
    test_result_id?: IntFieldUpdateOperationsInput | number
    test_id?: IntFieldUpdateOperationsInput | number
    test_result?: FloatFieldUpdateOperationsInput | number
    test_note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type test_resultUncheckedUpdateManyWithoutStudentInput = {
    test_result_id?: IntFieldUpdateOperationsInput | number
    test_id?: IntFieldUpdateOperationsInput | number
    test_result?: FloatFieldUpdateOperationsInput | number
    test_note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type agendaCreateManySubject_classInput = {
    agenda_id?: number
    agenda_title: string
    agenda_context: string
    agenda_annouced?: Date | string | null
    agenda_due?: Date | string | null
  }

  export type testCreateManySubject_classInput = {
    test_id?: number
    test_title?: string | null
    test_description?: string | null
    test_total?: number | null
    test_visibility?: string | null
    test_annouced?: Date | string | null
    test_due?: Date | string | null
    test_period?: $Enums.test_test_period | null
  }

  export type agendaUpdateWithoutSubject_classInput = {
    agenda_title?: StringFieldUpdateOperationsInput | string
    agenda_context?: StringFieldUpdateOperationsInput | string
    agenda_annouced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agenda_due?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type agendaUncheckedUpdateWithoutSubject_classInput = {
    agenda_id?: IntFieldUpdateOperationsInput | number
    agenda_title?: StringFieldUpdateOperationsInput | string
    agenda_context?: StringFieldUpdateOperationsInput | string
    agenda_annouced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agenda_due?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type agendaUncheckedUpdateManyWithoutSubject_classInput = {
    agenda_id?: IntFieldUpdateOperationsInput | number
    agenda_title?: StringFieldUpdateOperationsInput | string
    agenda_context?: StringFieldUpdateOperationsInput | string
    agenda_annouced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agenda_due?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type testUpdateWithoutSubject_classInput = {
    test_title?: NullableStringFieldUpdateOperationsInput | string | null
    test_description?: NullableStringFieldUpdateOperationsInput | string | null
    test_total?: NullableIntFieldUpdateOperationsInput | number | null
    test_visibility?: NullableStringFieldUpdateOperationsInput | string | null
    test_annouced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_due?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_period?: NullableEnumtest_test_periodFieldUpdateOperationsInput | $Enums.test_test_period | null
    test_result?: test_resultUpdateManyWithoutTestNestedInput
  }

  export type testUncheckedUpdateWithoutSubject_classInput = {
    test_id?: IntFieldUpdateOperationsInput | number
    test_title?: NullableStringFieldUpdateOperationsInput | string | null
    test_description?: NullableStringFieldUpdateOperationsInput | string | null
    test_total?: NullableIntFieldUpdateOperationsInput | number | null
    test_visibility?: NullableStringFieldUpdateOperationsInput | string | null
    test_annouced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_due?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_period?: NullableEnumtest_test_periodFieldUpdateOperationsInput | $Enums.test_test_period | null
    test_result?: test_resultUncheckedUpdateManyWithoutTestNestedInput
  }

  export type testUncheckedUpdateManyWithoutSubject_classInput = {
    test_id?: IntFieldUpdateOperationsInput | number
    test_title?: NullableStringFieldUpdateOperationsInput | string | null
    test_description?: NullableStringFieldUpdateOperationsInput | string | null
    test_total?: NullableIntFieldUpdateOperationsInput | number | null
    test_visibility?: NullableStringFieldUpdateOperationsInput | string | null
    test_annouced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_due?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_period?: NullableEnumtest_test_periodFieldUpdateOperationsInput | $Enums.test_test_period | null
  }

  export type final_gradeCreateManySubjectsInput = {
    final_grade_id?: number
    final_grade?: number | null
    student_id?: string | null
    test_period?: $Enums.final_grade_test_period | null
    created_at?: Date | string | null
    final_status?: string | null
  }

  export type subject_classCreateManySubjectsInput = {
    subject_class_id?: number
    instructor?: number | null
  }

  export type final_gradeUpdateWithoutSubjectsInput = {
    final_grade?: NullableFloatFieldUpdateOperationsInput | number | null
    test_period?: NullableEnumfinal_grade_test_periodFieldUpdateOperationsInput | $Enums.final_grade_test_period | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_status?: NullableStringFieldUpdateOperationsInput | string | null
    student?: studentUpdateOneWithoutFinal_gradeNestedInput
  }

  export type final_gradeUncheckedUpdateWithoutSubjectsInput = {
    final_grade_id?: IntFieldUpdateOperationsInput | number
    final_grade?: NullableFloatFieldUpdateOperationsInput | number | null
    student_id?: NullableStringFieldUpdateOperationsInput | string | null
    test_period?: NullableEnumfinal_grade_test_periodFieldUpdateOperationsInput | $Enums.final_grade_test_period | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type final_gradeUncheckedUpdateManyWithoutSubjectsInput = {
    final_grade_id?: IntFieldUpdateOperationsInput | number
    final_grade?: NullableFloatFieldUpdateOperationsInput | number | null
    student_id?: NullableStringFieldUpdateOperationsInput | string | null
    test_period?: NullableEnumfinal_grade_test_periodFieldUpdateOperationsInput | $Enums.final_grade_test_period | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type subject_classUpdateWithoutSubjectsInput = {
    agenda?: agendaUpdateManyWithoutSubject_classNestedInput
    employee?: employeeUpdateOneWithoutSubject_classNestedInput
    test?: testUpdateManyWithoutSubject_classNestedInput
  }

  export type subject_classUncheckedUpdateWithoutSubjectsInput = {
    subject_class_id?: IntFieldUpdateOperationsInput | number
    instructor?: NullableIntFieldUpdateOperationsInput | number | null
    agenda?: agendaUncheckedUpdateManyWithoutSubject_classNestedInput
    test?: testUncheckedUpdateManyWithoutSubject_classNestedInput
  }

  export type subject_classUncheckedUpdateManyWithoutSubjectsInput = {
    subject_class_id?: IntFieldUpdateOperationsInput | number
    instructor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type test_resultCreateManyTestInput = {
    test_result_id?: number
    student_id?: string | null
    test_result?: number
    test_note?: string | null
  }

  export type test_resultUpdateWithoutTestInput = {
    test_result?: FloatFieldUpdateOperationsInput | number
    test_note?: NullableStringFieldUpdateOperationsInput | string | null
    student?: studentUpdateOneWithoutTest_resultNestedInput
  }

  export type test_resultUncheckedUpdateWithoutTestInput = {
    test_result_id?: IntFieldUpdateOperationsInput | number
    student_id?: NullableStringFieldUpdateOperationsInput | string | null
    test_result?: FloatFieldUpdateOperationsInput | number
    test_note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type test_resultUncheckedUpdateManyWithoutTestInput = {
    test_result_id?: IntFieldUpdateOperationsInput | number
    student_id?: NullableStringFieldUpdateOperationsInput | string | null
    test_result?: FloatFieldUpdateOperationsInput | number
    test_note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type active_classCreateManyRenamedclassInput = {
    active_class_id?: number
    period?: number | null
    class_coordinator?: number | null
  }

  export type active_classUpdateWithoutRenamedclassInput = {
    period_active_class_periodToperiod?: periodUpdateOneWithoutActive_class_active_class_periodToperiodNestedInput
    employee?: employeeUpdateOneWithoutActive_classNestedInput
  }

  export type active_classUncheckedUpdateWithoutRenamedclassInput = {
    active_class_id?: IntFieldUpdateOperationsInput | number
    period?: NullableIntFieldUpdateOperationsInput | number | null
    class_coordinator?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type active_classUncheckedUpdateManyWithoutRenamedclassInput = {
    active_class_id?: IntFieldUpdateOperationsInput | number
    period?: NullableIntFieldUpdateOperationsInput | number | null
    class_coordinator?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}